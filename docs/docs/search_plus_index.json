{"./":{"url":"./","title":"鸿蒙OS开发文档","keywords":"","body":"手册简介 华为自有开源操作系统鸿蒙OS，鸿蒙OS凭借多终端开发IDE，多语言统一编译，分布式架构Kit提供屏幕布局控件以及交互的自动适配，支持控件拖拽，面向预览的可视化编程，从而使开发者可以基于同一工程高效构建多端自动运行App，实现真正的一次开发，多端部署，在跨设备之间实现共享生态。 "},"dao-du.html":{"url":"dao-du.html","title":"导读","keywords":"","body":""},"xi-tong-ding-yi.html":{"url":"xi-tong-ding-yi.html","title":"系统定义","keywords":"","body":"系统定义 HarmonyOS 是一款“面向未来”、面向全场景（移动办公、运动健康、社交通信、媒体娱乐等）的分布式操作系统。在传统的单设备系统能力的基础上，HarmonyOS 提出了基于同一套系统能力、适配多种终端形态的分布式理念，能够支持多种终端设备。 对消费者而言，HarmonyOS 能够将生活场景中的各类终端进行能力整合，形成一个“超级虚拟终端”，可以实现不同的终端设备之间的快速连接、能力互助、资源共享，匹配合适的设备、提供流畅的全场景体验。 对应用开发者而言，HarmonyOS 采用了多种分布式技术，使得应用程序的开发实现与不同终端设备的形态差异无关，降低了开发难度和成本。这能够让开发者聚焦上层业务逻辑，更加便捷、高效地开发应用。 对设备开发者而言，HarmonyOS 采用了组件化的设计方案，可以根据设备的资源能力和业务特征进行灵活裁剪，满足不同形态的终端设备对于操作系统的要求。 HarmonyOS提供了支持多种开发语言的API，供开发者进行应用开发。支持的开发语言包括Java、XML（Extensible Markup Language）、C/C++ 、 JS（JavaScript）、CSS（Cascading Style Sheets）和HML（HarmonyOS Markup Language）。 技术架构 HarmonyOS整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 > 子系统 > 功能/模块”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的子系统或功能/模块。HarmonyOS技术架构如下所示。 Play Video3192 内核层 内核子系统： HarmonyOS 采用多内核设计，支持针对不同资源受限设备选用适合的OS内核。内核抽象层（KAL，Kernel Abstract Layer）通过屏蔽多内核差异，对上层提供基础的内核能力，包括进程/线程管理、内存管理、文件系统、网络管理和外设管理等。 驱动子系统： 硬件驱动框架（HDF） 是 HarmonyOS 硬件生态开放的基础，提供统一外设访问能力和驱动开发、管理框架。 系统服务层 系统服务层是HarmonyOS的核心能力集合，通过框架层对应用程序提供服务。该层包含以下几个部分： 系统基本能力子系统集：为分布式应用在 HarmonyOS多设备上的运行、调度、迁移等操作提供了基础能力，由分布式软总线、分布式数据管理、分布式任务调度、方舟多语言运行时、公共基础库、多模输入、图形、安全、AI等子系统组成。其中，方舟运行时提供了C/C++/JS多语言运行时和基础的系统类库，也为使用方舟编译器静态化的Java程序（即应用程序或框架层中使用Java语言开发的部分）提供运行时。 基础软件服务子系统集：为HarmonyOS提供公共的、通用的软件服务，由事件通知、电话、多媒体、DFX（Design For X） 、MSDP&DV等子系统组成。 增强软件服务子系统集：为HarmonyOS提供针对不同设备的、差异化的能力增强型软件服务，由智慧屏专有业务、穿戴专有业务、IoT专有业务等子系统组成。 硬件服务子系统集：为HarmonyOS提供硬件服务，由位置服务、生物特征识别、穿戴专有硬件服务、IoT专有硬件服务等子系统组成。 根据不同设备形态的部署环境，基础软件服务子系统集、增强软件服务子系统集、硬件服务子系统集内部可以按子系统粒度裁剪，每个子系统内部又可以按功能粒度裁剪。 框架层 框架层为HarmonyOS应用开发提供了Java/C/C++/JS等多语言的用户程序框架和Ability框架，两种UI框架（包括适用于Java语言的Java UI框架、适用于JS语言的JS UI框架），以及各种软硬件服务对外开放的多语言框架API。根据系统的组件化裁剪程度，HarmonyOS设备支持的API也会有所不同。 应用层 应用层包括系统应用和第三方非系统应用。HarmonyOS的应用由一个或多个FA（Feature Ability）或PA（Particle Ability）组成。其中，FA有UI界面，提供与用户交互的能力；而PA无UI界面，提供后台运行任务的能力以及统一的数据访问抽象。FA在进行用户交互时所需的后台数据访问也需要由对应的PA提供支撑。基于FA/PA开发的应用，能够实现特定的业务功能，支持跨设备调度与分发，为用户提供一致、高效的应用体验。 "},"ji-zhu-te-zheng.html":{"url":"ji-zhu-te-zheng.html","title":"技术特征","keywords":"","body":"技术特性 硬件互助，资源共享 多种设备之间能够实现硬件互助、资源共享，依赖的关键技术包括分布式软总线、分布式设备虚拟化、分布式数据管理、分布式任务调度等。 分布式软总线 分布式软总线是手机、平板、智能穿戴、智慧屏、车机等分布式设备的通信基座，为设备之间的互联互通提供了统一的分布式通信能力，为设备之间的无感发现和零等待传输创造了条件。开发者只需聚焦于业务逻辑的实现，无需关注组网方式与底层协议。分布式软总线示意图见图1。 典型应用场景举例： 智能家居场景：在烹饪时，手机可以通过碰一碰和烤箱连接，并将自动按照菜谱设置烹调参数，控制烤箱来制作菜肴。与此类似，料理机、油烟机、空气净化器、空调、灯、窗帘等都可以在手机端显示并通过手机控制。设备之间即连即用，无需繁琐的配置。 多屏联动课堂：老师通过智慧屏授课，与学生开展互动，营造课堂氛围；学生通过手机完成课程学习和随堂问答。统一、全连接的逻辑网络确保了传输通道的高带宽、低时延、高可靠。 图1 分布式软总线示意图 分布式设备虚拟化 分布式设备虚拟化平台可以实现不同设备的资源融合、设备管理、数据处理，多种设备共同形成一个超级虚拟终端。针对不同类型的任务，为用户匹配并选择能力合适的执行硬件，让业务连续地在不同设备间流转，充分发挥不同设备的能力优势，如显示能力、摄像能力、音频能力、交互能力以及传感器能力等。分布式设备虚拟化示意图见图2。 典型应用场景举例： 视频通话场景：在做家务时接听视频电话，可以将手机与智慧屏连接，并将智慧屏的屏幕、摄像头与音箱虚拟化为本地资源，替代手机自身的屏幕、摄像头、听筒与扬声器，实现一边做家务、一边通过智慧屏和音箱来视频通话。 游戏场景：在智慧屏上玩游戏时，可以将手机虚拟化为遥控器，借助手机的重力传感器、加速度传感器、触控能力，为玩家提供更便捷、更流畅的游戏体验。 图2 分布式设备虚拟化示意图 分布式数据管理 分布式数据管理基于分布式软总线的能力，实现应用程序数据和用户数据的分布式管理。用户数据不再与单一物理设备绑定，业务逻辑与数据存储分离，跨设备的数据处理如同本地数据处理一样方便快捷，让开发者能够轻松实现全场景、多设备下的数据存储、共享和访问，为打造一致、流畅的用户体验创造了基础条件。分布式数据管理示意图见图3。 典型应用场景举例： 协同办公场景：将手机上的文档投屏到智慧屏，在智慧屏上对文档执行翻页、缩放、涂鸦等操作，文档的最新状态可以在手机上同步显示。 家庭出游场景：一家人出游时，妈妈用手机拍了很多照片。通过家庭照片共享，爸爸可以在自己的手机上浏览、收藏和保存这些照片，家中的爷爷奶奶也可以通过智慧屏浏览这些照片。 图3 分布式数据管理示意图 分布式任务调度 分布式任务调度基于分布式软总线、分布式数据管理、分布式Profile等技术特性，构建统一的分布式服务管理（发现、同步、注册、调用）机制，支持对跨设备的应用进行远程启动、远程调用、远程连接以及迁移等操作，能够根据不同设备的能力、位置、业务运行状态、资源使用情况，以及用户的习惯和意图，选择合适的设备运行分布式任务。 图4以应用迁移为例，简要地展示了分布式任务调度能力。 典型应用场景举例： 导航场景：如果用户驾车出行，上车前，在手机上规划好导航路线；上车后，导航自动迁移到车机和车载音箱；下车后，导航自动迁移回手机。如果用户骑车出行，在手机上规划好导航路线，骑行时手表可以接续导航。 外卖场景：在手机上点外卖后，可以将订单信息迁移到手表上，随时查看外卖的配送状态。 图4 分布式任务调度示意图 一次开发，多端部署 HarmonyOS提供了用户程序框架、Ability框架以及UI框架，支持应用开发过程中多终端的业务逻辑和界面逻辑进行复用，能够实现应用的一次开发、多端部署，提升了跨设备应用的开发效率。一次开发、多端部署示意图见图5。 其中，UI框架支持Java和JS两种开发语言，并提供了丰富的多态控件，可以在手机、平板、智能穿戴、智慧屏、车机上显示不同的UI效果。采用业界主流设计方式，提供多种响应式布局方案，支持栅格化布局，满足不同屏幕的界面适配能力。 图5 一次开发、多端部署示意图 统一OS，弹性部署 HarmonyOS通过组件化和小型化等设计方法，支持多种终端设备按需弹性部署，能够适配不同类别的硬件资源和功能需求。支撑通过编译链关系去自动生成组件化的依赖关系，形成组件树依赖图，支撑产品系统的便捷开发，降低硬件设备的开发门槛。 支持各组件的选择（组件可有可无） ：根据硬件的形态和需求，可以选择所需的组件。 支持组件内功能集的配置（组件可大可小） ：根据硬件的资源情况和功能需求，可以选择配置组件中的功能集。例如，选择配置图形框架组件中的部分控件。 支持组件间依赖的关联（平台可大可小） ：根据编译链关系，可以自动生成组件化的依赖关系。例如，选择图形框架组件，将会自动选择依赖的图形引擎组件等。 "},"xi-tong-an-quan.html":{"url":"xi-tong-an-quan.html","title":"系统安全","keywords":"","body":"系统安全 在搭载HarmonyOS的分布式终端上，可以保证“正确的人，通过正确的设备，正确地使用数据”。 通过“分布式多端协同身份认证”来保证“正确的人”。 通过“在分布式终端上构筑可信运行环境”来保证“正确的设备”。 通过“分布式数据在跨终端流动的过程中，对数据进行分类分级管理”来保证“正确地使用数据”。 正确的人 在分布式终端场景下，“正确的人”指通过身份认证的数据访问者和业务操作者。“正确的人”是确保用户数据不被非法访问、用户隐私不泄露的前提条件。HarmonyOS通过以下三个方面来实现协同身份认证： 零信任模型：HarmonyOS基于零信任模型，实现对用户的认证和对数据的访问控制。当用户需要跨设备访问数据资源或者发起高安全等级的业务操作（例如，对安防设备的操作）时，HarmonyOS会对用户进行身份认证，确保其身份的可靠性。 多因素融合认证：HarmonyOS通过用户身份管理，将不同设备上标识同一用户的认证凭据关联起来，用于标识一个用户，来提高认证的准确度。 协同互助认证：HarmonyOS、通过将硬件和认证能力解耦（即信息采集和认证可以在不同的设备上完成），来实现不同设备的资源池化以及能力的互助与共享，让高安全等级的设备协助低安全等级的设备完成用户身份认证。 正确的设备 在分布式终端场景下，只有保证用户使用的设备是安全可靠的，才能保证用户数据在虚拟终端上得到有效保护，避免用户隐私泄露。 安全启动确保源头每个虚拟设备运行的系统固件和应用程序是完整的、未经篡改的。通过安全启动，各个设备厂商的镜像包就不易被非法替换为恶意程序，从而保护用户的数据和隐私安全。 可信执行环境提供了基于硬件的可信执行环境（TEE，Trusted Execution Environment）来保护用户的个人敏感数据的存储和处理，确保数据不泄露。由于分布式终端硬件的安全能力不同，对于用户的敏感个人数据，需要使用高安全等级的设备进行存储和处理。HarmonyOS使用基于数学可证明的形式化开发和验证的TEE微内核，获得了商用OS内核CC EAL5+的认证评级。 设备证书认证支持为具备可信执行环境的设备预置设备证书，用于向其他虚拟终端证明自己的安全能力。对于有TEE环境的设备，通过预置PKI（Public Key Infrastructure）设备证书给设备身份提供证明，确保设备是合法制造生产的。设备证书在产线进行预置，设备证书的私钥写入并安全保存在设备的TEE环境中，且只在TEE内进行使用。在必须传输用户的敏感数据（例如密钥、加密的生物特征等信息）时，会在使用设备证书进行安全环境验证后，建立从一个设备的TEE到另一设备的TEE之间的安全通道，实现安全传输。如图1所示。 图1 设备证书使用示意图 正确地使用数据 在分布式终端场景下，需要确保用户能够正确地使用数据。HarmonyOS围绕数据的生成、存储、使用、传输以及销毁过程进行全生命周期的保护，从而保证个人数据与隐私、以及系统的机密数据（如密钥）不泄漏。 数据生成：根据数据所在的国家或组织的法律法规与标准规范，对数据进行分类分级，并且根据分类设置相应的保护等级。每个保护等级的数据从生成开始，在其存储、使用、传输的整个生命周期都需要根据对应的安全策略提供不同强度的安全防护。虚拟超级终端的访问控制系统支持依据标签的访问控制策略，保证数据只能在可以提供足够安全防护的虚拟终端之间存储、使用和传输。 数据存储：HarmonyOS通过区分数据的安全等级，存储到不同安全防护能力的分区，对数据进行安全保护，并提供密钥全生命周期的跨设备无缝流动和跨设备密钥访问控制能力，支撑分布式身份认证协同、分布式数据共享等业务。 数据使用：HarmonyOS通过硬件为设备提供可信执行环境。用户的个人敏感数据仅在分布式虚拟终端的可信执行环境中进行使用，确保用户数据的安全和隐私不泄露。 数据传输：为了保证数据在虚拟超级终端之间安全流转，需要各设备是正确可信的，建立了信任关系（多个设备通过华为帐号建立配对关系），并能够在验证信任关系后，建立安全的连接通道，按照数据流动的规则，安全地传输数据。当设备之间进行通信时，需要基于设备的身份凭据对设备进行身份认证，并在此基础上，建立安全的加密传输通道。 数据销毁：销毁密钥即销毁数据。数据在虚拟终端的存储，都建立在密钥的基础上。当销毁数据时，只需要销毁对应的密钥即完成了数据的销毁。 "},"ying-yong-ji-chu-zhi-shi.html":{"url":"ying-yong-ji-chu-zhi-shi.html","title":"应用基础知识","keywords":"","body":"应用基础知识 用户应用程序 用户应用程序泛指运行在设备的操作系统之上，为用户提供特定服务的程序，简称“应用”。 在HarmonyOS上运行的应用，有两种形态： 传统方式的需要安装的应用。 提供特定功能，免安装的应用（即 原子化服务 ）。 在HarmonyOS文档中，如无特殊说明，“应用”所指代的对象包括上述两种形态。 用户应用程序包结构 HarmonyOS的用户应用程序包以APPPack（Application Package）形式发布，它是由一个或多个HAP（HarmonyOS Ability Package）以及描述每个HAP属性的pack.info组成。HAP是Ability的部署包，HarmonyOS应用代码围绕Ability组件展开。 一个HAP是由代码、资源、第三方库及应用配置文件组成的模块包，可分为entry和feature两种模块类型，如图1所示。 entry ：应用的主模块。一个APP中，对于同一设备类型必须有且只有一个entry类型的HAP，可独立安装运行。 feature ：应用的动态特性模块。一个APP可以包含一个或多个feature类型的HAP，也可以不含。只有包含Ability的HAP才能够独立运行。 图1 APP逻辑视图 Ability Ability是应用所具备的能力的抽象，一个应用可以包含一个或多个Ability。Ability分为两种类型：FA（Feature Ability）和PA（Particle Ability）。FA/PA是应用的基本组成单元，能够实现特定的业务功能。FA有UI界面，而PA无UI界面。 库文件 库文件是应用依赖的第三方代码（例如so、jar、bin、har等二进制文件），存放在libs目录。 资源文件 应用的资源文件（字符串、图片、音频等）存放于resources目录下，便于开发者使用和维护，详见资源文件的分类。 配置文件 配置文件 (config.json) 是应用的Ability信息，用于声明应用的Ability，以及应用所需权限等信息，详见应用配置文件。 pack.info 描述应用软件包中每个HAP的属性，由IDE编译生成，应用市场根据该文件进行拆包和HAP的分类存储。HAP的具体属性包括： delivery-with-install: 表示该HAP是否支持随应用安装。 “true” 表示支持随应用安装； “false” 表示不支持随应用安装。 name：HAP文件名。 module-type：模块类型，entry或feature。 device-type：表示支持该HAP运行的设备类型。 HAR HAR（HarmonyOS Ability Resources）可以提供构建应用所需的所有内容，包括源代码、资源文件和config.json文件。HAR不同于HAP，HAR不能独立安装运行在设备上，只能作为应用模块的依赖项被引用。 "},"jian-jie.html":{"url":"jian-jie.html","title":"简介","keywords":"","body":"简介 应用的每个HAP的根目录下都存在一个“config.json”配置文件，文件内容主要涵盖以下三个方面： 应用的全局配置信息，包含应用的包名、生产厂商、版本号等基本信息。 应用在具体设备上的配置信息，包含应用的备份恢复、网络安全等能力。 HAP包的配置信息，包含每个Ability必须定义的基本属性（如包名、类名、类型以及Ability提供的能力），以及应用访问系统或其他应用受保护部分所需的权限等。 配置文件的组成 配置文件“config.json”采用JSON文件格式，其中包含了一系列配置项，每个配置项由属性和值两部分构成： 属性 属性出现顺序不分先后，且每个属性最多只允许出现一次。 值 每个属性的值为JSON的基本数据类型（数值、字符串、布尔值、数组、对象或者null类型）。如果属性值需要引用资源文件，可参见资源文件。 "},"pei-zhi-wen-jian-de-yuan-su.html":{"url":"pei-zhi-wen-jian-de-yuan-su.html","title":"配置文件的元素","keywords":"","body":"配置文件的元素 此部分提供配置文件“config.json”中所有属性的详细解释。 DevEco Studio提供了两种编辑“config.json”文件的方式。在“config.json”的编辑窗口中，可在右上角切换代码编辑视图或可视化编辑视图。 图1 config.json文件的可视化编辑视图 配置文件的内部结构 “config.json”由“app”、“deviceConfig”和“module”三个部分组成，缺一不可。配置文件的内部结构说明参见表1。 属性名称 含义 数据类型 是否可缺省 app 表示应用的全局配置信息。同一个应用的不同HAP包的“app”配置必须保持一致。 对象 否 deviceConfig 表示应用在具体设备上的配置信息。 对象 否 module 表示HAP包的配置信息。该标签下的配置只对当前HAP包生效。 对象 否 app对象的内部结构 app对象包含应用的全局配置信息，内部结构说明参见表2。 属性名称 子属性名称 含义 数据类型 是否可缺省 bundleName - 表示应用的包名，用于标识应用的唯一性。包名是由字母、数字、下划线（_）和点号（.）组成的字符串，必须以字母开头。支持的字符串长度为7~127字节。包名通常采用反域名形式表示（例如，com.huawei.himusic）。建议第一级为域名后缀“com”，第二级为厂商/个人名，第三级为应用名，也可以采用多级。 字符串 否 vendor - 表示对应用开发厂商的描述。字符串长度不超过255字节。 字符串 可缺省，缺省值为空。 version - 表示应用的版本信息。 对象 否 code 表示应用的版本号，仅用于HarmonyOS管理该应用，对用户不可见。取值为大于零的整数。 数值 否 name 表示应用的版本号，用于向用户呈现。取值可以自定义。 字符串 否 minCompatibleVersionCode 表示应用可兼容的最低版本号，用于在跨设备场景下，判断其他设备上该应用的版本是否兼容。 数值 可缺省，缺省值为code标签值。 apiVersion - 表示应用依赖的HarmonyOS的API版本。 对象 否 compatible 表示应用运行需要的API最小版本。取值为大于零的整数。 数值 否 target 表示应用运行需要的API目标版本。取值为大于零的整数。 数值 可缺省，缺省值为应用所在设备的当前API版本。 releaseType 表示应用运行需要的API目标版本的类型。取值为“CanaryN”、“BetaN”或者“Release”，其中，N代表大于零的整数。Canary：受限发布的版本。Beta：公开发布的Beta版本。Release：公开发布的正式版本。 字符串 可缺省，缺省值为“Release”。 multiFrameworkBundle - 表示应用是否为混合打包的HarmonyOS应用。混合打包场景配置为“true”，非混合打包场景配置为“false”。该标签值由IDE自动配置。 布尔类型 可缺省，缺省值为“false”。 smartWindowSize - 该标签用于在悬浮窗场景下表示应用的模拟窗口的尺寸。配置格式为“正整数*正整数”，单位为vp。正整数取值范围为[200,2000]。 字符串 可缺省，缺省值为空。 smartWindowDeviceType - 表示应用可以在哪些设备上使用模拟窗口打开。取值为：智能手机：phone平板：tablet智慧屏：tv 字符串数组 可缺省，缺省值为空。 targetBundleList - 表示允许以免安装方式拉起的其他HarmonyOS应用，列表取值为每个HarmonyOS应用的bundleName，多个bundleName之间用英文“,”区分，最多配置10个bundleName。如果被拉起的应用不支持免安装方式，则拉起失败。 字符串 否 app示例： \"app\": { \"bundleName\": \"com.huawei.hiworld.example\", \"vendor\": \"huawei\", \"version\": { \"code\": 2, \"name\": \"2.0\" } \"apiVersion\": { \"compatible\": 3, \"target\": 3, \"releaseType\": \"Beta1\" } } deviceConfig对象的内部结构 deviceConfig包含在具体设备上的应用配置信息，可以包含default、phone、tablet、tv、car、wearable、liteWearable和smartVision等属性。default标签内的配置是适用于所有设备通用，其他设备类型如果有特殊的需求，则需要在该设备类型的标签下进行配置。内部结构说明参见表3。 属性名称 含义 数据类型 是否可缺省 default 表示所有设备通用的应用配置信息。 对象 否 phone 表示手机类设备的应用信息配置。 对象 可缺省，缺省为空 tablet 表示平板的应用配置信息。 对象 可缺省，缺省为空。 tv 表示智慧屏特有的应用配置信息。 对象 可缺省，缺省为空。 car 表示车机特有的应用配置信息。 对象 可缺省，缺省为空。 wearable 表示智能穿戴特有的应用配置信息。 对象 可缺省，缺省为空。 liteWearable 表示轻量级智能穿戴特有的应用配置信息。 对象 可缺省，缺省为空。 smartVision 表示智能摄像头特有的应用配置信息。 对象 可缺省，缺省为空。 default、phone、tablet、tv、car、wearable、liteWearable和smartVision等对象的内部结构说明，可参见表4。 属性名称 含义 数据类型 是否可缺省 jointUserId 表示应用的共享userid。通常情况下，不同的应用运行在不同的进程中，应用的资源是无法共享。如果开发者的多个应用之间需要共享资源，则可以通过相同的jointUserId值实现，前提是这些应用的签名相同。该标签仅对系统应用生效，且仅适用于手机、平板、智慧屏、车机、智能穿戴。该字段在API Version 3及更高版本不再支持配置。 字符串 可缺省，缺省为空。 process 表示应用或者Ability的进程名。如果在“deviceConfig”标签下配置了“process”标签，则该应用的所有Ability都运行在这个进程中。 如果在“abilities”标签下也为某个Ability配置了“process”标签，则该Ability就运行在这个进程中。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为应用的软件包名。 supportBackup 表示应用是否支持备份和恢复。如果配置为“false”，则不支持为该应用执行备份或恢复操作。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省为“false”。 compressNativeLibs 表示libs库是否以压缩存储的方式打包到HAP包。如果配置为“false”，则libs库以不压缩的方式存储，HAP包在安装时无需解压libs，运行时会直接从HAP内加载libs库。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省为“true”。 network 表示网络安全性配置。该标签允许应用通过配置文件的安全声明来自定义其网络安全，无需修改应用代码。 对象 可缺省，缺省为空。 属性名称 含义 数据类型 是否可缺省 cleartextTraffic 表示是否允许应用使用明文网络流量（例如，明文HTTP）。true：允许应用使用明文流量的请求。false：拒绝应用使用明文流量的请求。 布尔类型 可缺省，缺省为“false”。 securityConfig 表示应用的网络安全配置信息。 对象 可缺省，缺省为空。 属性名称 子属性名称 含义 数据类型 是否可缺省 domainSettings - 表示自定义的网域范围的安全配置，支持多层嵌套，即一个domainSettings对象中允许嵌套更小网域范围的domainSettings对象。 对象 可缺省，缺省为空。 cleartextPermitted 表示自定义的网域范围内是否允许明文流量传输。当usesCleartext和securityConfig同时存在时，自定义网域是否允许明文流量传输以cleartextPermitted的取值为准。true：允许明文流量传输。false：拒绝明文流量传输。 布尔类型 否 domains 表示域名配置信息，包含两个参数：subdomains和name。subdomains（布尔类型）：表示是否包含子域名。如果为 “true”，此网域规则将与相应网域及所有子网域（包括子网域的子网域）匹配。否则，该规则仅适用于精确匹配项。name（字符串）：表示域名名称。 对象数组 否 deviceConfig示例： \"deviceConfig\": { \"default\": { \"process\": \"com.huawei.hiworld.example\", \"supportBackup\": false, \"network\": { \"cleartextTraffic\": true, \"securityConfig\": { \"domainSettings\": { \"cleartextPermitted\": true, \"domains\": [ { \"subDomains\": true, \"name\": \"example.ohos.com\" } ] } } } } } module对象的内部结构 module对象包含HAP包的配置信息，内部结构说明参见表7。 属性名称 含义 数据类型 是否可缺省 mainAbility 表示HAP包的入口ability名称。该标签的值应配置为“module > abilities”中存在的Page类型ability的名称。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 如果存在page类型的ability，则该字段不可缺省。 package 表示HAP的包结构名称，在应用内应保证唯一性。采用反向域名格式（建议与HAP的工程目录保持一致）。字符串长度不超过127字节。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 否 name 表示HAP的类名。采用反向域名方式表示，前缀需要与同级的package标签指定的包名一致，也可采用“.”开头的命名方式。字符串长度不超过255字节。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 否 description 表示HAP的描述信息。字符串长度不超过255字节。如果字符串超出长度或者需要支持多语言，可以采用资源索引的方式添加描述内容。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。 supportedModes 表示应用支持的运行模式。当前只定义了驾驶模式（drive）。该标签仅适用于车机。 字符串数组 可缺省，缺省值为空。 deviceType 表示允许Ability运行的设备类型。系统预定义的设备类型包括：phone（手机）、tablet（平板）、tv（智慧屏）、car（车机）、wearable（智能穿戴）、liteWearable（轻量级智能穿戴）等。 字符串数组 否 distro 表示HAP发布的具体描述。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 对象 否 metaData 表示HAP的元信息。 对象 可缺省，缺省值为空。 abilities 表示当前模块内的所有Ability。采用对象数组格式，其中每个元素表示一个Ability对象。 对象数组 可缺省，缺省值为空。 js 表示基于JS UI框架开发的JS模块集合，其中的每个元素代表一个JS模块的信息。 对象数组 可缺省，缺省值为空。 shortcuts 表示应用的快捷方式信息。采用对象数组格式，其中的每个元素表示一个快捷方式对象。 对象数组 可缺省，缺省值为空。 defPermissions 表示应用定义的权限。应用调用者必须申请这些权限，才能正常调用该应用。 对象数组 可缺省，缺省值为空。 reqPermissions 表示应用运行时向系统申请的权限。 对象数组 可缺省，缺省值为空。 colorMode 表示应用自身的颜色模式。dark：表示按照深色模式选取资源。light：表示按照浅色模式选取资源。auto：表示跟随系统的颜色模式值选取资源。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为“auto”。 theme 表示应用的主题，标签值为自定义主题资源的索引，或系统资源的索引。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。 entryTheme 表示内部主题的关键字，标签值配置为该名称对应的资源索引。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。 resizeable 表示应用是否支持多窗口特性。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“true”。 module示例： \"module\": { \"mainAbility\": \"MainAbility\", \"package\": \"com.example.myapplication.entry\", \"name\": \".MyOHOSAbilityPackage\", \"description\": \"$string:description_application\", \"supportedModes\": [ \"drive\" ], \"deviceType\": [ \"car\" ], \"distro\": { \"deliveryWithInstall\": true, \"moduleName\": \"ohos_entry\", \"moduleType\": \"entry\" }, \"abilities\": [ ... ], \"shortcuts\": [ ... ], \"js\": [ ... ], \"reqPermissions\": [ ... ], \"defPermissions\": [ ... ], \"colorMode\": \"light\"} 属性名称 含义 数据类型 是否可缺省 deliveryWithInstall 表示当前HAP是否支持随应用安装。true：支持随应用安装。false：不支持随应用安装。说明该属性建议设置为true。设置false可能导致最终应用上架应用市场异常。 布尔类型 否 moduleName 表示当前HAP的名称。 字符串 否 moduleType 表示当前HAP的类型，包括两种类型：entry和feature。 字符串 否 installationFree 表示当前该FA是否支持免安装特性。true：表示支持免安装特性，且符合免安装约束。false：表示不支持免安装特性。 布尔类型 entry.hap可缺省，feature.hap不可缺省。 distro示例： \"distro\": { \"deliveryWithInstall\": true, \"moduleName\": \"ohos_entry\", \"moduleType\": \"entry\", \"installationFree\": true} 属性名称 子属性名称 含义 数据类型 是否可缺省 parameters - 表示调用Ability时所有调用参数的元信息。每个调用参数的元信息由以下三个标签组成：description、name、type。 对象 可缺省，缺省值为空。 description 表示对调用参数的描述，可以是表示描述内容的字符串，也可以是对描述内容的资源索引以支持多语言。 字符串 可缺省，缺省值为空。 name 表示调用参数的名称。 字符串 可缺省，缺省值为空。 type 表示调用参数的类型，如Integer。 字符串 否 results - 表示Ability返回值的元信息。每个返回值的元信息由以下三个标签组成：description、name、type。 对象 可缺省，缺省值为空。 description 表示对返回值的描述，可以是表示描述内容的字符串，也可以是对描述内容的资源索引以支持多语言。 字符串 可缺省，缺省值为空。 name 表示返回值的名字。 字符串 可缺省，缺省值为空。 type 表示返回值的类型，如Integer。 字符串 否 customizeData - 表示父级组件的自定义元信息，parameters和results在module中不可配。 对象 可缺省，缺省值为空。 name 表示数据项的键名称，字符串类型（最大长度255字节）。 字符串 可缺省，缺省值为空。 value 表示数据项的值，字符串类型（最大长度255字节）。 字符串 可缺省，缺省值为空。 extra 表示用户自定义数据格式，标签值为标识该数据的资源的索引值。 字符串 可缺省，缺省值为空。 metaData示例： \"metaData\": { \"parameters\" : [{ \"name\" : \"string\", \"type\" : \"Float\", \"description\" : \"$string:parameters_description\" }], \"results\" : [{ \"name\" : \"string\", \"type\" : \"Float\", \"description\" : \"$string:results_description\" }], \"customizeData\" : [{ \"name\" : \"string\", \"value\" : \"string\", \"extra\" : \"$string:customizeData_description\" }]} 属性名称 含义 数据类型 是否可缺省 name 表示Ability名称。取值可采用反向域名方式表示，由包名和类名组成，如“com.example.myapplication.MainAbility”；也可采用“.”开头的类名方式表示，如“.MainAbility”。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。说明在使用DevEco Studio新建项目时，默认生成首个Ability的配置，包括生成“MainAbility.java”文件，及“config.json”中“MainAbility”的配置。如使用其他IDE工具，可自定义名称。 字符串 否 description 表示对Ability的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。 字符串 可缺省，缺省值为空。 icon 表示Ability图标资源文件的索引。取值示例：$media:ability_icon。如果在该Ability的“skills”属性中，“actions”的取值包含 “action.system.home”，“entities”取值中包含“entity.system.home”，则该Ability的icon将同时作为应用的icon。如果存在多个符合条件的Ability，则取位置靠前的Ability的icon作为应用的icon。说明应用的“icon”和“label”是用户可感知配置项，需要区别于当前所有已有的应用“icon”或“label”（至少有一个不同）。 字符串 可缺省，缺省值为空。 label 表示Ability对用户显示的名称。取值可以是Ability名称，也可以是对该名称的资源索引，以支持多语言。如果在该Ability的“skills”属性中，“actions”的取值包含 “action.system.home”，“entities”取值中包含“entity.system.home”，则该Ability的label将同时作为应用的label。如果存在多个符合条件的Ability，则取位置靠前的Ability的label作为应用的label。说明应用的“icon”和“label”是用户可感知配置项，需要区别于当前所有已有的应用“icon”或“label”（至少有一个不同）。 字符串 可缺省，缺省值为空。 uri 表示Ability的统一资源标识符。格式为[scheme:][//authority][path][?query][#fragment]。 字符串 可缺省，对于data类型的Ability不可缺省。 launchType 表示Ability的启动模式，支持“standard”和“singleton”两种模式：standard：表示该Ability可以有多实例。“standard”模式适用于大多数应用场景。singleton：表示该Ability只可以有一个实例。例如，具有全局唯一性的呼叫来电界面即采用“singleton”模式。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为“standard”。 visible 表示Ability是否可以被其他应用调用。true：可以被其他应用调用。false：不能被其他应用调用。 布尔类型 可缺省，缺省值为“false”。 permissions 表示其他应用的Ability调用此Ability时需要申请的权限。通常采用反向域名格式，取值可以是系统预定义的权限，也可以是开发者自定义的权限。如果是自定义权限，取值必须与“defPermissions”标签中定义的某个权限的“name”标签值一致。 字符串数组 可缺省，缺省值为空。 skills 表示Ability能够接收的Intent的特征。 对象数组 可缺省，缺省值为空。 deviceCapability 表示Ability运行时要求设备具有的能力，采用字符串数组的格式表示。 字符串数组 可缺省，缺省值为空。 metaData 表示Ability的元信息。调用Ability时调用参数的元信息，例如：参数个数和类型。Ability执行完毕返回值的元信息，例如：返回值个数和类型。该标签仅适用于智慧屏、智能穿戴、车机。 对象 可缺省，缺省值为空。 type 表示Ability的类型。取值范围如下：page：表示基于Page模板开发的FA，用于提供与用户交互的能力。service：表示基于Service模板开发的PA，用于提供后台运行任务的能力。data：表示基于Data模板开发的PA，用于对外部提供统一的数据访问抽象。CA：表示支持其他应用以窗口方式调起该Ability。 字符串 否 orientation 表示该Ability的显示模式。该标签仅适用于page类型的Ability。取值范围如下：unspecified：由系统自动判断显示方向。landscape：横屏模式。portrait：竖屏模式。followRecent：跟随栈中最近的应用。 字符串 可缺省，缺省值为“unspecified”。 backgroundModes 表示后台服务的类型，可以为一个服务配置多个后台服务类型。该标签仅适用于service类型的Ability。取值范围如下：dataTransfer：通过网络/对端设备进行数据下载、备份、分享、传输等业务。audioPlayback：音频输出业务。audioRecording：音频输入业务。pictureInPicture：画中画、小窗口播放视频业务。voip：音视频电话、VOIP业务。location：定位、导航业务。bluetoothInteraction：蓝牙扫描、连接、传输业务。wifiInteraction：WLAN扫描、连接、传输业务。screenFetch：录屏、截屏业务。 字符串数组 可缺省，缺省值为空。 readPermission 表示读取Ability的数据所需的权限。该标签仅适用于data类型的Ability。取值为长度不超过255字节的字符串。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为空。 writePermission 表示向Ability写数据所需的权限。该标签仅适用于data类型的Ability。取值为长度不超过255字节的字符串。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为空。 configChanges 表示Ability关注的系统配置集合。当已关注的配置发生变更后，Ability会收到onConfigurationUpdated回调。取值范围：locale：表示语言区域发生变更。layout：表示屏幕布局发生变更。fontSize：表示字号发生变更。orientation：表示屏幕方向发生变更。density：表示显示密度发生变更。 字符串数组 可缺省，缺省为空。 mission 表示Ability指定的任务栈。该标签仅适用于page类型的Ability。默认情况下应用中所有Ability同属一个任务栈。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为应用的包名。 targetAbility 表示当前Ability重用的目标Ability。该标签仅适用于page类型的Ability。如果配置了targetAbility属性，则当前Ability（即别名Ability）的属性中仅“name”、“icon”、“label”、“visible”、“permissions”、“skills”生效，其它属性均沿用targetAbility中的属性值。目标Ability必须与别名Ability在同一应用中，且在配置文件中目标Ability必须在别名之前进行声明。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。表示当前Ability不是一个别名Ability。 multiUserShared 表示Ability是否支持多用户状态进行共享，该标签仅适用于data类型的Ability。配置为“true”时，表示在多用户下只有一份存储数据。需要注意的是，该属性会使visible属性失效。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“false”。 supportPipMode 表示Ability是否支持用户进入PIP模式（用于在在页面最上层悬浮小窗口，俗称“画中画”，常见于视频播放等场景）。该标签仅适用于page类型的Ability。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“false”。 formsEnabled 表示Ability是否支持卡片（forms）功能。该标签仅适用于page类型的Ability。true：支持卡片能力。false：不支持卡片能力。 布尔类型 可缺省，缺省值为“false”。 forms 表示服务卡片的属性。该标签仅当“formsEnabled”为“true”时，才能生效。 对象数组 可缺省，缺省值为空。 resizeable 表示Ability是否支持多窗口特性。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“true”。 abilities示例： \"abilities\": [ { \"name\": \".MainAbility\", \"description\": \"himusic main ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"permissions\": [ ], \"visible\": true, \"skills\": [ { \"actions\": [ \"action.system.home\" ], \"entities\": [ \"entity.system.home\" ] } ], \"configChanges\": [ \"locale\", \"layout\", \"fontSize\", \"orientation\" ], \"type\": \"page\" }, { \"name\": \".PlayService\", \"description\": \"himusic play ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"visible\": false, \"skills\": [ { \"actions\": [ \"action.play.music\", \"action.stop.music\" ], \"entities\": [ \"entity.audio\" ] } ], \"type\": \"service\", \"backgroundModes\": [ \"audioPlayback\" ] }, { \"name\": \".UserADataAbility\", \"type\": \"data\", \"uri\": \"dataability://com.huawei.hiworld.himusic.UserADataAbility\", \"visible\": true }] 属性名称 子属性名称 含义 数据类型 是否可缺省 actions - 表示能够接收的Intent的action值，可以包含一个或多个action。取值通常为系统预定义的action值，详见《API参考》中的ohos.aafwk.content.Intent类。 字符串数组 可缺省，缺省值为空。 entities - 表示能够接收的Intent的Ability的类别（如视频、桌面应用等），可以包含一个或多个entity。取值通常为系统预定义的类别，详见《API参考》中的ohos.aafwk.content.Intent类，也可以自定义。 字符串数组 可缺省，缺省值为空。 uris - 表示能够接收的Intent的uri，可以包含一个或者多个uri。 对象数组 可缺省，缺省值为空。 scheme 表示uri的scheme值。 字符串 不可缺省。 host 表示uri的host值。 字符串 可缺省，缺省值为空。 port 表示uri的port值。 字符串 可缺省，缺省值为空。 path 表示uri的path值。 字符串 可缺省，缺省值为空。 type 表示uri的type值。 字符串 可缺省，缺省值为空。 skills示例： \"skills\": [ { \"actions\": [ \"action.system.home\" ], \"entities\": [ \"entity.system.home\" ], \"uris\": [ { \"scheme\": \"http\", \"host\": \"www.xxx.com\", \"port\": \"8080\", \"path\": \"query/student/name\", \"type\": \"text/*\" } ] }] 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示JS Component的名字。该标签不可缺省，默认值为default。 字符串 否 pages - 表示JS Component的页面用于列举JS Component中每个页面的路由信息[页面路径+页面名称]。该标签不可缺省，取值为数组，数组第一个元素代表JS FA首页。 数组 否 window - 用于定义与显示窗口相关的配置。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 对象 可缺省。 designWidth 表示页面设计基准宽度。以此为基准，根据实际设备宽度来缩放元素大小。 数值 可缺省，缺省值为750px。 autoDesignWidth 表示页面设计基准宽度是否自动计算。当配置为true时，designWidth将会被忽略，设计基准宽度由设备宽度与屏幕密度计算得出。 布尔类型 可缺省，缺省值为“false”。 type - 表示JS应用的类型。取值范围如下：normal：标识该JS Component为应用实例。form：标识该JS Component为卡片实例。 字符串 可缺省，缺省值为“normal”。 js示例： \"js\": [ { \"name\": \"default\", \"pages\": [ \"pages/index/index\", \"pages/detail/detail\" ], \"window\": { \"designWidth\": 750, \"autoDesignWidth\": false }, \"type\": \"form\" }] 属性名称 子属性名称 含义 数据类型 是否可缺省 shortcutId - 表示快捷方式的ID。字符串的最大长度为63字节。 字符串 否 label - 表示快捷方式的标签信息，即快捷方式对外显示的文字描述信息。取值可以是描述性内容，也可以是标识label的资源索引。字符串最大长度为63字节。 字符串 可缺省，缺省为空。 intents - 表示快捷方式内定义的目标intent信息集合，每个intent可配置两个子标签，targetClass, targetBundle。 - 可缺省，缺省为空。 targetClass 表示快捷方式目标类名。 字符串 可缺省，缺省值为空。 targetBundle 表示快捷方式目标Ability所在应用的包名。 字符串 可缺省，缺省值为空。 shortcuts示例： \"shortcuts\": [ { \"shortcutId\": \"id\", \"label\": \"$string:shortcut\", \"intents\": [ { \"targetBundle\": \"com.huawei.hiworld.himusic\", \"targetClass\": \"com.huawei.hiworld.himusic.entry.MainAbility\" } ] }] 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示卡片的类名。字符串最大长度为127字节。 字符串 否 description - 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。 isDefault - 表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。true：默认卡片。false：非默认卡片。 布尔值 否 type - 表示卡片的类型。取值范围如下：Java：Java卡片。JS：JS卡片。 字符串 否 colorMode - 表示卡片的主题样式，取值范围如下：auto：自适应。dark：深色主题。light：浅色主题。 字符串 可缺省，缺省值为“auto”。 supportDimensions - 表示卡片支持的外观规格，取值范围：12：表示1行2列的二宫格。22：表示2行2列的四宫格。24：表示2行4列的八宫格。44：表示4行4列的十六宫格。 字符串数组 否 defaultDimension - 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否 landscapeLayouts - 表示卡片外观规格对应的横向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 portraitLayouts - 表示卡片外观规格对应的竖向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 updateEnabled - 表示卡片是否支持周期性刷新，取值范围：true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。false：表示不支持周期性刷新。 布尔类型 否 scheduledUpdateTime - 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 字符串 可缺省，缺省值为“0:0”。 updateDuration - 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。 数值 可缺省，缺省值为“0”。 formConfigAbility - 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。 jsComponentName - 表示JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。 字符串 否 metaData - 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。 customizeData - 表示自定义的卡片信息。 对象数组 可缺省，缺省值为空。 name 表示数据项的键名称。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 value 表示数据项的值。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 forms示例： \"forms\": [ { \"name\": \"Form_Js\", \"description\": \"It's Js Form\", \"type\": \"JS\", \"jsComponentName\": \"card\", \"colorMode\": \"auto\", \"isDefault\": true, \"updateEnabled\": true, \"scheduledUpdateTime\": \"11:00\", \"updateDuration\": 1, \"defaultDimension\": \"2*2\", \"supportDimensions\": [ \"2*2\", \"2*4\", \"4*4\" ] }, { \"name\": \"Form_Java\", \"description\": \"It's Java Form\", \"type\": \"Java\", \"colorMode\": \"auto\", \"isDefault\": false, \"updateEnabled\": true, \"scheduledUpdateTime\": \"21:05\", \"updateDuration\": 1, \"defaultDimension\": \"1*2\", \"supportDimensions\": [ \"1*2\" ], \"landscapeLayouts\": [ \"$layout:ability_form\" ], \"portraitLayouts\": [ \"$layout:ability_form\" ], \"formConfigAbility\": \"ability://com.example.myapplication.fa/.MainAbility\", \"metaData\": { \"customizeData\": [ { \"name\": \"originWidgetName\", \"value\": \"com.huawei.weather.testWidget\" } ] } }] HAP与HAR的配置文件的合并 如果应用模块中调用了HAR，在编译构建HAP时，需要将HAP的“config.json”文件与一个或多个HAR的“config.json”文件，合并为一个“config.json”文件。在合并过程中，不同文件的同一个标签的取值可能发生冲突，此时，需要通过配置mergeRule来解决冲突。 配置文件合并规则 HAP与HAR的“config.json”文件合并时，需要将HAR的配置信息全部合并到HAP的配置文件。合并规则参见表15。 HAP的优先级总是高于HAR。当HAP依赖于多个HAR时，先加载的HAR的优先级高于后加载的HAR，按照HAR的加载顺序依次合并到HAP文件。 序号 HAP HAR 合并结果 1 无标签值。 无标签值。 无标签值。 2 有标签值，取值为A。 无标签值。 有标签值，取值为A。 3 无标签值。 有标签值，取值为B。 有标签值，取值为B。 4 有标签值，取值为A。 有标签值，取值为A。 有标签值，取值为A。 5 有标签值，取值为A。 有标签值，取值为B。 冲突，需要添加mergeRule，详见mergeRule对象的使用。 mergeRule对象的使用 mergeRule通常在HAP的“config.json”文件中使用，可以在“abilities”、“defPermissions”、 “reqPermissions”、“js”等属性中添加。不同属性的合并策略，详见表16。 注意 HAR配置文件中不能包含“action.system.home”和“entity.system.home”配置项，否则会导致编译报错。 abilities对象中“name”字段的取值，必须为完整的类名，否则会导致合并出错。 属性名称 合并规则 一级 二级 三级 app - - 只保留HAP的“config.json”文件中的app对象。 deviceConfig - - 只保留HAP的“config.json”文件中的deviceConfig对象。 module package - 只保留HAP的“config.json”文件中的取值。 name - 只保留HAP的“config.json”文件中的取值。 description - 只保留HAP的“config.json”文件中的取值。 supportedModes - 只保留HAP的“config.json”文件中的取值。 deviceType - 只保留HAP的“config.json”文件中的取值。 distro - 只保留HAP的“config.json”文件中的取值。 shortcuts - 只保留HAP的“config.json”文件中的取值。 defPermissions - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 reqPermissions - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 js - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 abilities - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 permissions 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 skills 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 backgroundModes 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 configChanges 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 targetAbility 如果“targetAbility”与“abilities”中的“name”冲突，则导致编译报错。 其他 “abilities”中的其他属性如果发生合并冲突，则需要添加“mergeRule”字段。 属性名称 含义 数据类型 是否可缺省 remove 表示HAP与HAR的“config.json”文件合并时，需要移除的标签。 字符串数组 是 replace 表示HAP与HAR的“config.json”文件合并冲突时，需要替换的标签，始终保留高优先级的值。 字符串数组 是 mergeRule的使用示例： 在下面的示例中，HAP与HAR中的Ability的“name”取值相同，需要对两者“config.json”文件中的Ability进行合并。由于两个文件中的部分字段（例如“launchType”）存在冲突，需要在HAP的“abilities”标签下添加“mergeRule”。 合并前HAP的 “config.json” 文件，如下所示： 其中，remove表示合并后需要移除的子标签，replace表示合并后需要替换的子标签（HAP替换HAR）。 \"abilities\": [ { \"mergeRule\": { \"remove\": [\"orientation\"], \"replace\": [\"launchType\"] } \"name\": \"com.harmony.myapplication.entry.MainAbility\", \"type\": \"page\", \"launchType\": \"standard\", \"visible\": false }], 合并前HAR的 “config.json” 文件，如下所示： \"abilities\": [ { \"name\": \"com.harmony.myapplication.entry.MainAbility\", \"type\": \"page\", \"launchType\": \"singleton\", \"orientation\": \"portrait\", \"visible\": false }], 将上述两个 “config.json” 文件按照mergeRule进行合并，处理完成后mergeRule字段也会被移除。合并后的结果文件，如下所示： \"abilities\": [ { \"name\": \"com.harmony.myapplication.entry.MainAbility\", \"type\": \"page\", \"launchType\": \"standard\", \"visible\": false }], bundleName占位符的使用 HAR的“config.json”文件中多处需要使用包名，例如自定义权限、自定义action等场景，但是包名只有当HAR编译到HAP时才能确定下来。在编译之前，HAR中的包名可以采用占位符来表示，采用{bundleName}形式。 支持bundleName占位符的标签有actions、entities、permissions、readPermission、writePermission、defPermissions.name、uri。 使用示例： HAR中自定义action时，使用{bundleName}来代替包名。如下所示： \"skills\": [ { \"actions\": [ \"{bundleName}.ACTION_PLAY\" ], \"entities\": [ \"{bundleName}.ENTITY_PLAY\" ], }], 将HAP编译到bundleName为 “com.huawei.hiworld” 的HAP包后，原来的{bundleName}将被替换为HAP的实际包名。替换后的结果如下所示： \"app\": { \"bundleName\": \"com.huawei.hiworld\", ……},\"module\": { \"abilities\": [ { \"skills\": [ { \"actions\": [ \"com.huawei.hiworld.ACTION_PLAY\" ], \"entities\": [ \"com.huawei.hiworld.ENTITY_PLAY\" ], } ], "},"pei-zhi-wen-jian-shi-li.html":{"url":"pei-zhi-wen-jian-shi-li.html","title":"配置文件示例","keywords":"","body":"配置文件示例 以JSON文件为config.json的一个简单示例，该示例的应用声明为三个Ability。 { \"app\": { \"bundleName\": \"com.huawei.hiworld.himusic\", \"vendor\": \"huawei\", \"version\": { \"code\": 2, \"name\": \"2.0\" }, \"apiVersion\": { \"compatible\": 3, \"target\": 3, \"releaseType\": \"Beta1\" } }, \"deviceConfig\": { \"default\": { } }, \"module\": { \"mainAbility\": \"MainAbility\", \"package\": \"com.huawei.hiworld.himusic.entry\", \"name\": \".MainApplication\", \"supportedModes\": [ \"drive\" ], \"distro\": { \"moduleType\": \"entry\", \"deliveryWithInstall\": true, \"moduleName\": \"hap-car\" }, \"deviceType\": [ \"car\" ], \"abilities\": [ { \"name\": \".MainAbility\", \"description\": \"himusic main ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"visible\": true, \"skills\": [ { \"actions\": [ \"action.system.home\" ], \"entities\": [ \"entity.system.home\" ] } ], \"type\": \"page\", \"formsEnabled\": false }, { \"name\": \".PlayService\", \"description\": \"himusic play ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"visible\": false, \"skills\": [ { \"actions\": [ \"action.play.music\", \"action.stop.music\" ], \"entities\": [ \"entity.audio\" ] } ], \"type\": \"service\", \"backgroundModes\": [ \"audioPlayback\" ] }, { \"name\": \".UserADataAbility\", \"type\": \"data\", \"uri\": \"dataability://com.huawei.hiworld.himusic.UserADataAbility\", \"visible\": true } ], \"reqPermissions\": [ { \"name\": \"ohos.permission.DISTRIBUTED_DATASYNC\", \"reason\": \"\", \"usedScene\": { \"ability\": [ \"com.huawei.hiworld.himusic.entry.MainAbility\", \"com.huawei.hiworld.himusic.entry.PlayService\" ], \"when\": \"inuse\" } } ] } } "},"zi-yuan-wen-jian-de-fen-lei.html":{"url":"zi-yuan-wen-jian-de-fen-lei.html","title":"资源文件的分类","keywords":"","body":"资源文件的分类 更新时间: 2021-06-02 21:03 resources目录 应用的资源文件（字符串、图片、音频等）统一存放于resources目录下，便于开发者使用和维护。resources目录包括两大类目录，一类为base目录与限定词目录，另一类为rawfile目录，详见表1。 资源目录示例： resources|---base // 默认存在的目录| |---element| | |---string.json| |---media| | |---icon.png|---en_GB-vertical-car-mdpi // 限定词目录示例，需要开发者自行创建 | |---element| | |---string.json| |---media| | |---icon.png|---rawfile // 默认存在的目录 分类 base目录与限定词目录 rawfile目录 组织形式 按照两级目录形式来组织，目录命名必须符合规范，以便根据设备状态去匹配相应目录下的资源文件。一级子目录为base目录和限定词目录。base目录是默认存在的目录。当应用的resources资源目录中没有与设备状态匹配的限定词目录时，会自动引用该目录中的资源文件。限定词目录需要开发者自行创建。目录名称由一个或多个表征应用场景或设备特征的限定词组合而成，具体要求参见限定词目录。二级子目录为资源目录，用于存放字符串、颜色、布尔值等基础元素，以及媒体、动画、布局等资源文件，具体要求参见资源组目录。 支持创建多层子目录，目录名称可以自定义，文件夹内可以自由放置各类资源文件。rawfile目录的文件不会根据设备状态去匹配不同的资源。 编译方式 目录中的资源文件会被编译成二进制文件，并赋予资源文件ID。 目录中的资源文件会被直接打包进应用，不经过编译，也不会被赋予资源文件ID。 引用方式 通过指定资源类型（type）和资源名称（name）来引用，详见资源文件的引用方法。 通过指定文件路径和文件名来引用，详见资源文件的引用方法。 限定词目录 限定词目录可以由一个或多个表征应用场景或设备特征的限定词组合而成，包括移动国家码和移动网络码、语言、文字、国家或地区、横竖屏、设备类型、颜色模式和屏幕密度等维度，限定词之间通过下划线（_）或者中划线（-）连接。开发者在创建限定词目录时，需要掌握限定词目录的命名要求以及与限定词目录与设备状态的匹配规则。 限定词目录的命名**要求** 限定词的组合顺序：移动国家码移动网络码-语言文字_国家或地区-横竖屏-设备类型-深色模式-屏幕密度。开发者可以根据应用的使用场景和设备特征，选择其中的一类或几类限定词组成目录名称。 限定词的连接方式：语言、文字、国家或地区之间采用下划线（）连接，移动国家码和移动网络码之间也采用下划线（）连接，除此之外的其他限定词之间均采用中划线（-）连接。例如：zh_Hant_CN、zh_CN-car-ldpi。 限定词的取值范围：每类限定词的取值必须符合 表2 中的条件，否则，将无法匹配目录中的资源文件。 限定词类型 含义与取值说明 移动国家码和移动网络码 移动国家码（MCC）和移动网络码（MNC）的值取自设备注册的网络。MCC后面可以跟随MNC，使用下划线（）连接，也可以单独使用。例如：mcc460表示中国，mcc460_mnc00表示中国中国移动。详细取值范围，请查阅ITU-T E.212（国际电联相关标准）。 语言 表示设备使用的语言类型，由2~3个小写字母组成。例如：zh表示中文，en表示英语，mai表示迈蒂利语。详细取值范围，请查阅ISO 639（ISO制定的语言编码标准）。 文字 表示设备使用的文字类型，由1个大写字母（首字母）和3个小写字母组成。例如：Hans表示简体中文，Hant表示繁体中文。详细取值范围，请查阅ISO 15924（ISO制定的文字编码标准）。 国家或地区 表示用户所在的国家或地区，由2~3个大写字母或者3个数字组成。例如：CN表示中国，GB表示英国。详细取值范围，请查阅ISO 3166-1（ISO制定的国家和地区编码标准）。 横竖屏 表示设备的屏幕方向，取值如下：vertical：竖屏horizontal：横屏 设备类型 表示设备的类型，取值如下：phone：手机tablet：平板car：车机tv：智慧屏wearable：智能穿戴 颜色模式 表示设备的颜色模式，取值如下：dark：深色模式light：浅色模式 屏幕密度 表示设备的屏幕密度（单位为dpi），取值如下：sdpi：表示小规模的屏幕密度（Small-scale Dots Per Inch），适用于dpi取值为(0, 120]的设备。mdpi：表示中规模的屏幕密度（Medium-scale Dots Per Inch），适用于dpi取值为(120, 160]的设备。ldpi：表示大规模的屏幕密度（Large-scale Dots Per Inch），适用于dpi取值为(160, 240]的设备。xldpi：表示特大规模的屏幕密度（Extra Large-scale Dots Per Inch），适用于dpi取值为(240, 320]的设备。xxldpi：表示超大规模的屏幕密度（Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(320, 480]的设备。xxxldpi：表示超特大规模的屏幕密度（Extra Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(480, 640]的设备。 限定词目录与设备状态的匹配规则 在为设备匹配对应的资源文件时，限定词目录匹配的优先级从高到低依次为：移动国家码和移动网络码 > 区域（语言文字国家或地区）> 横竖屏 > 设备类型 > 颜色模式 > 屏幕密度。 如果限定词目录中包含移动国家码和移动网络码、语言、文字、横竖屏、设备类型、颜色模式限定词，则对应限定词的取值必须与当前的设备状态完全一致，该目录才能够参与设备的资源匹配。例如，限定词目录“zh_CN-car-ldpi”不能参与“en_US”设备的资源匹配。 资源组目录 base目录与限定词目录下面可以创建资源组目录（包括element、media、animation、layout、graphic、profile），用于存放特定类型的资源文件，详见表3。 资源组目录 目录说明 资源文件 element 表示元素资源，以下每一类数据都采用相应的JSON文件来表征。boolean，布尔型color，颜色float，浮点型intarray，整型数组integer，整型pattern，样式plural，复数形式strarray，字符串数组string，字符串 element目录中的文件名称建议与下面的文件名保持一致。每个文件中只能包含同一类型的数据。boolean.jsoncolor.jsonfloat.jsonintarray.jsoninteger.jsonpattern.jsonplural.jsonstrarray.jsonstring.json media 表示媒体资源，包括图片、音频、视频等非文本格式的文件。 文件名可自定义，例如：icon.png。 animation 表示动画资源，采用XML文件格式。 文件名可自定义，例如：zoom_in.xml。 layout 表示布局资源，采用XML文件格式。 文件名可自定义，例如：home_layout.xml。 graphic 表示可绘制资源，采用XML文件格式。 文件名可自定义，例如：notifications_dark.xml。 profile 表示其他类型文件，以原始文件形式保存。 文件名可自定义。 创建资源文件 在resources目录下，可按照限定词目录和资源组目录的说明创建子目录和目录内的文件。 同时，DevEco Studio也提供了创建资源目录和资源文件的界面。 创建资源目录及资源文件 在resources目录右键菜单选择“New > Harmony Resource File”，此时可同时创建目录和文件。 文件默认创建在base目录的对应资源组下。如果选择了限定词，则会按照命名规范自动生成限定词+资源组目录，并将文件创建在目录中。 目录名自动生成，格式固定为“限定词.资源组”，例如创建一个限定词为横竖屏类别下的竖屏，资源组为绘制资源的目录，自动生成的目录名称为“vertical.graphic”。 创建资源目录 在resources目录右键菜单选择“New > Harmony Resource Directory”，此时可创建资源目录。 选择资源组类型，设置限定词，创建后自动生成目录名称。目录名称格式固定为“限定词.资源组”，例如创建一个限定词为横竖屏类别下的竖屏，资源组为绘制资源的目录，自动生成的目录名称为“vertical.graphic”。 创建资源文件 在资源目录的右键菜单选择“New > XXX Resource File”，即可创建对应资源组目录的资源文件。 例如，在element目录下可新建Element Resource File。 "},"zi-yuan-wen-jian-de-shi-yong.html":{"url":"zi-yuan-wen-jian-de-shi-yong.html","title":"资源文件的使用","keywords":"","body":"资源文件的使用 更新时间: 2021-06-02 21:03 资源文件的引用方法 base目录与限定词目录中的资源文件：通过指定资源类型（type）和资源名称（name）来引用。 Java文件引用资源文件的格式： ResourceTable.type_ name 。特别地，如果引用的是系统资源，则采用： ohos.global.systemres.ResourceTable.type_name 。 示例一：在Java文件中，引用 string.json 文件中类型为“String”、名称为“app_name”的资源。 ohos.global.resource.ResourceManager resManager = this.getResourceManager();String result = resManager.getElement(ResourceTable.String_app_name).getString(); 示例二：在Java文件中，引用 color.json 文件中类型为“Color”、名称为“red”的资源。 ohos.global.resource.ResourceManager resManager = this.getResourceManager();int color = resManager.getElement(ResourceTable.Color_red).getColor(); XML文件引用资源文件的格式： $type:name 。特别地，如果引用的是系统资源，则采用： $ohos:type:name 。 在XML文件中，引用string.json文件中类型为“String”、名称为“app_name”的资源，示例如下： rawfile目录中的资源文件：通过指定文件路径和文件名称来引用。 在Java文件中，引用一个路径为“resources/rawfile/”、名称为“example.js”的资源文件，示例如下： ohos.global.resource.ResourceManager resManager = this.getResourceManager();ohos.global.resource.RawFileEntry rawFileEntry = resManager.getRawFileEntry(\"resources/rawfile/example.js\"); 系统资源文件 目前支持的部分系统资源文件详见表1。 系统资源名称 含义 类型 ic_app 表示HarmonyOS应用的默认图标。 媒体 request_location_reminder_title 表示“请求使用设备定位功能”的提示标题。 字符串 request_location_reminder_content 表示“请求使用设备定位功能”的提示内容，即：请在下拉快捷栏打开\"位置信息\"开关。 字符串 颜色模式的定义 应用可以在config.json的module字段下定义“colorMode”字段，“colorMode”字段用来定义应用自身的颜色模式，值可以是“dark”，“light”，“auto”（默认值）。示例： \"colorMode\": \"light\" 当应用的颜色模式值是“dark”时，无论系统当前颜色模式是什么，应用始终会按照深色模式选取资源；同理，当应用的颜色模式值是“light”时，无论系统当前颜色模式是什么，应用始终会按照浅色模式选取资源；当应用的颜色模式值是“auto”时，应用会跟随系统的颜色模式值选取资源。应用可以在代码中通过如下方式获取应用当前的颜色模式： int colorMode = Configuration.colorMode; 为Element资源文件添加注释或特殊标识 Element目录下的不同种类元素的资源均采用JSON文件表示，资源的名称“name”和取值“value”是每一条资源的必备字段。 如果需要为某一条资源备注信息，以便于资源的理解和使用，可以通过comment字段添加注释。 如果value字段中的部分文本不需要被翻译人员处理，也不会被显示在应用界面上，可以通过特殊结构来标识无需翻译的内容。 通过comment字段添加注释 通过comment字段，可以为JSON文件的资源添加注释。示例如下： { \"string\":[ { \"name\":\"message_arrive\", \"value\":\"We will arrive at %s\", \"comment\":\"Transfer Arrival Time. %s is time,like 5:00 am\" } ]} 通过特殊结构来标识无需翻译的内容 在string、strarray、plural这三类资源中，可以通过特殊标识来处理无需被翻译的内容。例如，一个字符串资源的Value取值为“We will arrive at %s”，其中的变量“%s”在翻译过程中希望保持不变。有以下两种方式处理： 方式一：在value字段中添加{}。示例如下： { \"string\":[ { \"name\":\"message_arrive\", \"value\":[\"We will arrive at\",{ \"id\":\"time\", \"example\":\"5:00 am\", \"value\":\"%s\" } ] } ]} 方式二：添加标记对。示例如下： { \"string\":[ { \"name\":\"message_arrive\", \"value\":\"We will arrive at %s\" } ]} boolean.json示例 { \"boolean\":[ { \"name\":\"boolean_1\", \"value\":true }, { \"name\":\"boolean_ref\", \"value\":\"$boolean:boolean_1\" } ]} color.json示例 { \"color\":[ { \"name\":\"red\", \"value\":\"#ff0000\" }, { \"name\":\"red_ref\", \"value\":\"$color:red\" } ]} float.json示例 { \"float\":[ { \"name\":\"float_1\", \"value\":\"30.6\" }, { \"name\":\"float_ref\", \"value\":\"$float:float_1\" }, { \"name\":\"float_px\", \"value\":\"100px\" } ]} intarray.json示例 { \"intarray\":[ { \"name\":\"intarray_1\", \"value\":[ 100, 200, \"$integer:integer_1\" ] } ]} integer.json示例 { \"integer\":[ { \"name\":\"integer_1\", \"value\":100 }, { \"name\":\"integer_ref\", \"value\":\"$integer:integer_1\" } ]} pattern.json示例 { \"pattern\":[ { \"name\":\"base\", \"value\":[ { \"name\":\"width\", \"value\":\"100vp\" }, { \"name\":\"height\", \"value\":\"100vp\" }, { \"name\":\"size\", \"value\":\"25px\" } ] }, { \"name\":\"child\", \"parent\":\"base\", \"value\":[ { \"name\":\"noTitile\", \"value\":\"Yes\" } ] } ]} plural.json示例 { \"plural\":[ { \"name\":\"eat_apple\", \"value\":[ { \"quantity\":\"one\", \"value\":\"%d apple\" }, { \"quantity\":\"other\", \"value\":\"%d apples\" } ] } ]} strarray.json示例 { \"strarray\":[ { \"name\":\"size\", \"value\":[ { \"value\":\"small\" }, { \"value\":\"$string:hello\" }, { \"value\":\"large\" }, { \"value\":\"extra large\" } ] } ]} string.json示例 { \"string\":[ { \"name\":\"hello\", \"value\":\"hello base\" }, { \"name\":\"app_name\", \"value\":\"my application\" }, { \"name\":\"app_name_ref\", \"value\":\"$string:app_name\" }, { \"name\":\"app_sys_ref\", \"value\":\"$ohos:string:request_location_reminder_title\" } ]} "},"guo-ji-hua.html":{"url":"guo-ji-hua.html","title":"国际化","keywords":"","body":"国际化能力的支持 时间日期国际化 不同的区域具有不同的时间日期显示习惯。例如，英语（美国）区域short时间格式为“9:31 AM”；简体中文（中国）区域short时间格式为“上午9:31”；芬兰语（芬兰）区域short时间格式为“9.31”。因此为开发者提供了获取不同区域的时间日期规格的能力。 界面时间日期字串和时间类控件显示，应当遵循当地习惯的规则，当需要展示时间或日期时，建议获取当前地区的时间日期规格，并对显示的字串根据获取到的规格进行格式化后再使用。 示例1： Locale locale = new Locale(\"de\", \"CH\");String skeleton = \"MMMMd\";String bestPattern = DateFormatUtil.getBestPattern(skeleton, locale); // 返回值为\"d. MMMM\" 示例2： String languageTag = \"zh\";String out = DateFormatUtil.format(\"EEEEdMMMMy\", languageTag, \"Asia/Shanghai\", 0, 3600 * 1000); // 返回值为\"1970年1月1日星期四\" 电话号码国际化 不同的区域的电话号码有不同的格式化效果，当需要展示本地电话号码时，应遵循当地电话号码的格式化原则。因此为开发者提供了对不同地区电话号码格式化的能力，以便于在显示电话号码时正确的格式化。并提供了获取电话号码归属地的能力，开发者可以使用相关接口获取电话号码的归属地信息。 示例1： InputFormatter formatter = InputFormatter.getInstance(\"CN\");formatter.inputNumberAndRememberPosition('1'); // 返回值为\"1\"formatter.inputNumber('5'); // 返回值为\"15\"formatter.inputNumber('6'); // 返回值为\"156\"formatter.inputNumberAndRememberPosition('1');// 返回值为\"156 1\" 示例2： Locale.Builder builder = new Locale.Builder();builder.setLanguage(\"zh\");builder.setRegion(\"CN\");builder.setScript(\"Hant\");Locale locale = builder.build();String displayName = PhoneNumberAttribution.getAttribute(\"+8615611xxxxxx\", \"CN\", locale); // x为任意数字，返回值为\"北京市\" 文本识别 提供了对地址、时间日期与电话号码的文本识别能力，可以调用相关接口识别一段文本中包含的地址、时间日期与电话号码。 示例： // 当Locale.getDefault().getLanguage()为\"en\"时String source = \"it is 123 test St\";int[] re = TextRecognitionUtils.getAddress(source);if (re[0] == 1) { result = source.substring(re[1], re[2] + 1);// 返回值为\"123 main St\"} 度量衡格式化 提供了对度量衡国际化能力的支持，可支持度量衡体系和维度之间的转换，与不同国家度量衡体系的自动转换。在开发包含度量衡的功能时，可以调用此能力满足多语言和不同国家用户的需求。 示例1： Locale zhCN = Locale.CHINA;MeasureFormatter mes = MeasureFormatter.getInstance(zhCN);mes.format(MeasureOptions.Unit.AREA_UK_ACRE, 10000, MeasureOptions.Usage.AREA_LAND_AGRICULT, MeasureOptions.FormatStyle.WIDE, MeasureOptions.Style.AUTO_STYLE_ON));// 返回值为\"4,046.856公顷\" 示例2： Locale enUS = Locale.US;MeasureFormatter mes = MeasureFormatter.getInstance(enUS);mes.format(MeasureOptions.Unit.VOLUME_US_CUP, 1000, MeasureOptions.Unit.VOLUME_SI_LITER, MeasureOptions.FormatStyle.WIDE));// 返回值为\"236.588 liters\" 敏感禁忌 提供对政治敏感地区、城市、及语言的获取能力，以及对地区名称更正的能力。 示例： Locale locale = Locale.getDefault();ArrayList result = LocaleHelperUtils.getBlockedRegions(context, locale);//返回值包含\"EH\"与\"XK\"(西撒哈拉与科索沃），这两个地区为有政治争议的地区需谨慎使用 "},"ying-yong-shu-ju-guan-li.html":{"url":"ying-yong-shu-ju-guan-li.html","title":"应用数据管理","keywords":"","body":"应用数据管理 HarmonyOS应用数据管理支持单设备的各种结构化数据的持久化，以及跨设备之间数据的同步、共享以及搜索功能。开发者通过应用数据管理，能够方便地完成应用程序数据在不同终端设备间的无缝衔接，满足用户跨设备使用数据的一致性体验。 本地应用数据管理 提供单设备上结构化数据的存储和访问能力。使用SQLite作为持久化存储引擎，提供了多种类型的本地数据库，分别是关系型数据库（Relational Database）和对象关系映射数据库（Object Relational Mapping Database），此外还提供一种轻量级偏好数据库（Light Weight Preference Database），用以满足开发人员使用不同数据模型对应用数据进行持久化和访问的需求。 有关于本地应用数据管理的详细信息，请参阅关系型数据库、对象关系映射数据库和轻量级偏好数据库。 分布式数据服务 分布式数据库支持用户数据跨设备相互同步，为用户提供在多种终端设备上一致的数据访问体验。通过调用分布式数据接口，应用可以将数据保存到分布式数据库中。通过结合帐号、应用唯一标识和数据库三元组，分布式数据库对属于不同应用的数据进行隔离。 有关于分布式数据库的详细信息，请参阅分布式数据服务。 分布式文件服务 在多个终端设备间为单个设备上应用程序创建的文件提供多终端的分布式共享能力。每台设备上都存储一份全量的文件元数据，应用程序通过文件元数据中的路径，可以实现同一应用文件的跨设备访问。 有关于分布式文件的详细信息，请参阅分布式文件服务。 数据搜索服务 在单个设备上，为应用程序提供搜索引擎级的全文索引管理、建立索引和搜索功能。 有关于数据搜索的详细信息，请参阅融合搜索。 数据存储管理 为应用开发者提供系统存储路径、存储设备列表，存储设备属性的查询和管理功能。 有关于数据存储的详细信息，请参阅数据存储管理。 "},"ying-yong-quan-xian-guan-li.html":{"url":"ying-yong-quan-xian-guan-li.html","title":"应用权限管理","keywords":"","body":"应用权限管理 HarmonyOS中所有的应用均在应用沙盒内运行。默认情况下，应用只能访问有限的系统资源，系统负责管理应用对资源的访问权限。 应用权限管理是由接口提供方（Ability）、接口使用方（应用）、系统（包括云侧和端侧）以及用户等多方共同参与的整个流程，保证受限接口是在约定好的规则下被正常使用，避免接口被滥用而导致用户、应用和设备受损。 本节重点介绍应用权限管理的基本思想。有关权限使用的详细信息，请参阅权限。 权限声明 应用需要在config.json中使用“reqPermissions”属性对需要的权限逐个进行声明。 若使用到的三方库也涉及权限使用，也需统一在应用的config.json中逐个声明。 没有在config.json中声明的权限，应用就无法获得此权限的授权。 动态申请敏感权限 动态申请敏感权限基于用户可知可控的原则，需要应用在运行时主动调用系统动态申请权限的接口，系统弹框由用户授权，用户结合应用运行场景的上下文，识别出应用申请相应敏感权限的合理性，从而做出正确的选择。 即使用户向应用授予了请求的权限，应用在调用受此权限管控的接口前，也应该先检查自己有无此权限，而不能把之前授予的状态持久化，因为用户在动态授予后还可以通过设置取消应用的权限。 有关于应用动态申请敏感权限的详细信息，请参阅动态申请权限。 自定义权限 HarmonyOS为了保证应用对外提供的接口不被恶意调用，需要对调用接口的调用者进行鉴权。 大多情况下，系统已定义的权限满足了应用的基本需要，若有特殊的访问控制需要，应用可在config.json中以\"defPermissions\": []属性来定义新的权限，并通过“availableScope”和“grantMode”两个属性分别确定权限的开放范围和授权方式，使得权限定义更加灵活且易于理解。有关HarmonyOS权限开放范围和授权方式详细的描述，请参阅权限授予方式字段说明和权限限制范围字段说明。 为了避免应用自定义新权限出现重名的情况，建议应用对新权限的命名以包名的前两个字段开头，这样可以防止不同开发者的应用间出现自定义权限重名的情况。 权限保护方法 保护Ability：通过在config.json里对应的Ability中配置\"permissions\": [\"权限名\"]属性，即可实现保护整个Ability的目的，无指定权限的应用不能访问此Ability。 保护API：若Ability对外提供的数据或能力有多种，且开放范围或保护级别也不同，可以针对不同的数据或能力在接口代码实现中通过verifyPermission(String permissionName, int pid, int uid)来对uid标识的调用者进行鉴权。 权限使用原则 权限申请最小化。跟用户提供的功能无关的权限，不要申请；尽量采用其他无需权限的操作来实现相应功能（如：通过intent拉起系统UI界面由用户交互、应用自己生成uuid代替设备ID等）。 权限申请完整。应用所需权限（包括应用调用到的三方库依赖的权限）都要逐个在应用的config.json中按格式声明。 满足用户可知。应用申请的敏感权限的目的需要真实准确告知用户。 权限就近申请。应用在用户触发相关业务功能时，就近提示用户授予实现此功能所需的权限。 权限不扩散。在用户未授权的情况下，不允许提供给其他应用使用。 应用自定义权限防止重名。建议以包名为前缀来命名权限，防止跟系统定义的权限重名。 "},"ying-yong-yin-si-bao-hu.html":{"url":"ying-yong-yin-si-bao-hu.html","title":"应用隐私保护","keywords":"","body":"应用隐私保护 更新时间: 2021-06-04 15:12 随着移动终端及其相关业务（如移动支付、终端云等）的普及，用户隐私保护的重要性愈发突出。应用开发者在产品设计阶段就需要考虑用户隐私的保护，提高应用的安全性。HarmonyOS应用开发需要遵从其隐私保护规则，在应用上架应用市场时，应用市场会根据规则进行校验，如不满足条件则无法上架。 个人数据是指与一个身份已被识别或者身份可被识别的自然人相关的任何信息，包括但不限于个人身份信息、身份验证信息、财务和付款信息、联系方式、用户搜索、浏览记录、使用习惯、位置信息、短信和通话相关数据、麦克风数据、摄像头数据以及其他设备或应用使用情况数据等，其中敏感个人数据是个人数据的一个重要子集，指的是涉及数据主体的最私密领域的信息或者一旦泄露可能会给数据主体造成重大不利影响的数据，如导致个人名誉、身心健康受到损害或歧视性待遇等；敏感个人数据在各国家/地区相关法律法规中的定义有所不同，建议根据当地的法律法规要求处理。 数据收集及使用公开透明 应用采集个人数据时，应清晰、明确地告知用户，并确保告知用户的个人信息将被如何使用。 应用申请操作系统 敏感权限 时，需要明确告知用户权限申请的目的和用途，并获取用户的同意；敏感权限弹框参考示例如下。权限API使用方案请参考 权限 章节。详细的设计原则请参考 隐私设计 。 图1 敏感权限获取弹框示例 开发者应制定并遵从适当的隐私政策，在收集、使用留存和第三方分享用户数据时需要符合所有适用法律、政策和规定。如在收集个人数据前，需充分告知用户处理个人数据的种类、目的、处理方式、保留期限等，满足数据主体权利等要求。 应用向第三方披露任何个人信息须在隐私政策中说明披露内容、目的和披露对象。 根据以上要求，我们设计了示例以供参考。隐私通知/声明的参考示例如下： 图2 应用隐私通知与隐私声明示例图 个人数据应当基于具体、明确、合法的目的收集，不应与此目的不相符的方式作进一步处理。对于收集目的变更和用户撤销同意后再次使用的场景都需要用户重新同意。隐私声明变更与隐私声明撤销同意如图所示。 图3 隐私声明变更示例图 图4 隐私声明撤销同意示例图 应用需要提供用户查看隐私声明的入口。例如在应用的“关于”界面提供查看隐私声明的入口，如示例图所示： 图5 隐私声明的查看界面示例图 应用的隐私声明应覆盖本应用所有收集的个人数据。 在后台持续读取位置信息场景时，请申请ohos.permission.LOCATION_IN_BACKGROUND权限，详见敏感权限； 应用存在调用第三方的元能力（Particle Ability）或元服务（Feature Ability）场景时，需要在应用的隐私声明中明确第三方责任，如涉及个人数据收集则需要告知用户第三方的名称及收集的个人数据类型、目的和方式，申请的敏感权限、申请目的等。 数据收集及使用最小化 应用个人数据收集应与数据处理目的相关，且是适当、必要的。开发者应尽可能对个人数据进行匿名化或假名化处理，降低数据主体的风险。仅可收集和处理与特定目的相关且必需的个人数据，不能对数据做出与特定目的不相关的处理。 敏感权限申请的时候要满足权限最小化的要求，在进行权限申请时，只申请获取必需的信息或资源所需要的权限。如应用不需要相机权限就能够实现其功能时，则不应该向用户申请相机权限。 应用针对数据的收集要满足最小化要求，不收集与应用提供服务无关联的数据。如通信社交类应用，不应收集用户的网页浏览记录。 数据使用的功能要求能够使用户受益，收集的数据不能用于与用户正常使用无关的功能。如应用不得将“生物特征”、“健康数据”等敏感个人数据用于服务改进、投放广告或营销等非业务核心功能。 系统禁止应用在后台访问相机和麦克风的数据； 应用使用第三方支付交易过程中，如非适用法律要求或为提供第三方支付服务所必需，不得记录用户交易类鉴权信息，或向第三方批露与用户特定交易无关的用户个人信息。 应用不得仅出于广告投放或数据分析的目的而请求位置权限。 禁止在日志中打印敏感个人数据，如需要打印个人数据时，应对个人数据进行匿名化或假名化处理； 避免使用IMEI和序列号等永久性的标识符，尽量使用可以重置的标识符，如系统提供了NetworkID和DVID作为分布式场景下的设备标识符，广告业务场景下则建议使用OAID，基于应用的分析则建议使用ODID和AAID，其他需要唯一标识符的场景可以使用UUID接口生成； 不再需要使用的数据需要及时清除，降低数据泄露的风险。如分布式业务场景下设备断开分布式网络，临时缓存的数据需要及时删除。 数据处理选择和控制 对个人数据处理必须要征得用户的同意或遵守适用的法律法规，用户对其个人数据要有充分的控制权。 系统对于用户的敏感数据和系统关键资源的获取设置了对应的权限，应用访问这些数据时需要申请对应的权限。相关权限列表请参考应用权限列表章节。 应用申请使用敏感权限：应用弹窗提醒，向用户呈现应用需要获取的权限和权限使用目的、应用需要收集的数据和使用目的等，通过用户点击“同意”或“始终允许”的方式完成用户授权，让用户对应用权限的授予和个人数据的使用做到透明、可知、可控。 用户可以修改、取消授予应用的权限：当用户不同意某一权限或者数据收集时，应当允许用户使用与这部分权限和数据收集不相关的功能。如通信社交类应用，用户可以拒绝授予相机权限，不应该影响与相机无关的功能操作，如语音通话。 在进入应用的主界面之前不建议直接弹窗申请敏感权限，仅在用户使用功能时才请求对应的权限。如通信社交类应用，在没有启用位置相关的功能时，不建议在启动应用时就申请位置权限。 应用若使用个人数据用于个性化广告和精准营销，需提供独立的关闭选项。 需要向用户提供对个人数据的控制能力；如在云服务上存储了个人数据，需要提供删除数据的方法。 应用同时支持单设备和跨设备场景时，用户能够单独关闭跨设备应用场景。 数据安全 从技术上保证数据处理活动的安全性，包括个人数据的加密存储、安全传输等安全机制，应默认开启或采取安全保护措施。 数据存储 应用产生的密钥以及用户的敏感个人数据需要存储在应用的私有目录下。 应用可以调用系统提供的本地数据库RdbStore的加密接口对敏感个人数据进行加密存储。接口详见关系型数据库章节。 应用产生的分布式数据可以调用系统的分布式数据库进行存储，对于敏感个人数据需要采用分布式数据库提供的加密接口进行加密，接口详见分布式数据服务章节。 安全传输 需要分别针对本地传输和远程传输采取不同的安全保护措施。 本地传输： 应用通过intent跨应用传输数据时避免包含敏感个人数据，防止隐式调用导致intent劫持，导致个人数据泄露。 应用内组件调用应采用安全方式，避免通过隐式方式进行调用组件，防止组件劫持。 避免使用socket方式进行本地通信，如需使用，localhost端口号随机生成，并对端口连接对象进行身份认证和鉴权。 本地IPC通信安全：作为服务提供方需要校验服务使用方的身份和访问权限，防止服务使用方进行身份仿冒或者权限绕过。 远程传输： 使用https代替http进行通信，并对https证书进行严格校验。 避免进行远程端口进行通信，如需使用，需要对端口连接对象进行身份认证和鉴权。 应用进行跨设备通信时，需要校验被访问设备和应用的身份信息，防止被访问方的设备和应用进行身份仿冒。 应用进行跨设备通信时，作为服务提供方需要校验服务使用方的身份和权限，防止服务使用方进行身份仿冒或者权限绕过。 本地化处理 应用开发的数据优先在本地进行处理，对于本地无法处理的数据上传云服务要满足最小化的原则，不能默认选择上传云服务。 未成年人数据保护要求 如果应用是给未成年人设计的，或者应用通过收集的用户年龄数据识别出用户是未成年人，开发者应该结合目标市场国家的相关法律，专门分析未成年人个人数据保护的问题。收集未成年人数据前需要征得监护人的同意。 专为未成年人设计的应用不建议请求获取位置权限。 元服务（Feature Ability） 对于Visible=true的元服务，需要满足如下要求： 元服务启动时，需要在明显位置展示元服务的功能名称及开发者名称/logo。 元服务如涉及个人数据的收集，应提供独立的隐私声明，并在收集个人数据前向用户告知隐私声明。 元服务应按照法律法规要求收集个人数据，基于用户同意收集的个人数据，用户有权撤销同意。 元服务需要提供隐私声明的查看入口。 元服务隐私声明发生变更时，需要用户重新同意。 禁止在元服务免安装过程中捆绑安装与本服务不相关的功能，如扫描二维码的元服务不应该支持录音功能。 "},"san-fang-ying-yong-diao-yong-guan-kong-ji-zhi.html":{"url":"san-fang-ying-yong-diao-yong-guan-kong-ji-zhi.html","title":"三方应用调用管控机制","keywords":"","body":"三方应用调用管控机制 为什么要进行调用管控 后台进程启动过多，会消耗系统的内存、CPU等资源，造成用户设备耗电快、卡顿等现象。因此，为了保证用户体验，系统会对三方用户应用程序之间的PA调用进行管控，减少不必要的关联拉起。 相关概念 前台：用户应用程序有可见的FA正在显示，则认为用户应用程序在前台。 用户应用程序内调用：同一用户应用程序内的FA、PA之间的访问。 调用管控总体思路 用户应用程序内调用不管控。 三方用户应用程序间调用严格管控：禁止三方用户应用程序在后台调用其他三方应用的PA；严格管控三方用户应用程序在前台调用其他用户应用程序的PA。 管控规则 用户应用程序内调用 不管控。 三方用户应用程序间调用 三方应用程序A调用三方应用程序B的PA，具体限制如下： 禁止A在后台调用B的PA。 当B有进程存活时，允许A在前台调用B的PA；当B无进程存活时，禁止A的调用。 "},"kaifazhunbei.html":{"url":"kaifazhunbei.html","title":"开发准备","keywords":"","body":"开发准备 任务说明 本文档适用于HarmonyOS应用开发的初学者。通过构建一个简单的具有页面跳转功能的应用（如下图预览器运行效果所示），熟悉HarmonyOS应用开发流程。 为确保运行效果，请使用最新版本的DevEco Studio完成本任务，点击此处获取下载链接。 开发准备 开始前请参考下载与安装软件、配置开发环境，完成DevEco Studio的安装和开发环境的配置。 开发环境配置完成后，请参考创建和运行Hello World创建一个新工程，设备类型以“Phone”为例，使用Java语言开发，模板选择“Empty Feature Ability(Java)”。 工程创建完成后，使用预览器或Phone模拟器运行该工程。 完成上述操作后，请继续下一步的学习。 "},"diyigeyemian.html":{"url":"diyigeyemian.html","title":"编写第一个页面","keywords":"","body":"编写第一个页面 更新时间: 2021-06-02 21:03 在Java UI框架中，提供了两种编写布局的方式：在XML中声明UI布局和在代码中创建布局。这两种方式创建出的布局没有本质差别，为了熟悉两种方式，我们将通过XML的方式编写第一个页面，通过代码的方式编写第二个页面。 在“Project”窗口，点击“entry > src > main > resources > base > layout”，打开“ability_main.xml”文件。 第一个页面内有一个文本和一个按钮，使用DependentLayout布局，通过Text和Button组件来实现，其中vp和fp分别表示虚拟像素和字体像素。“ability_main.xml”的示例代码如下： 按钮的背景是蓝色胶囊样式，可以通过graphic目录下的XML文件来设置。 右键点击“graphic”文件夹，选择“New > File”，命名为“background_button.xml”，单击回车键。 “background_button.xml”的示例代码如下： 在layout目录下的“ability_main.xml”文件中，使用background_element=\"$graphic:background_button\"的方式引用“background_button.xml”文件： 在XML文件中添加组件后，需要在Java代码中加载XML布局。 在“Project”窗口，选择“entry > src > main > java > com.example.myapplication > slice” ，打开“MainAbilitySlice.java”文件，使用setUIContent方法加载“ability_main.xml”布局。 说明 HarmonyOS提供了Ability和AbilitySlice两个基础类，一个有界面的Ability可以由一个或多个AbilitySlice构成，AbilitySlice主要用于承载单个页面的具体逻辑实现和界面UI，是应用显示、运行和跳转的最小单元。 本文档以同一个Ability内的两个AbilitySlice之间的跳转为例，如果开发者希望实现两个Ability之间的跳转，请参考不同Page间导航。 “MainAbilitySlice.java”的示例代码如下： package com.example.myapplication.slice; import com.example.myapplication.ResourceTable;import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent; public class MainAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); // 加载XML布局 }} 使用预览器或模拟器运行项目，效果如下图所示。 "},"lingyigeyemian.html":{"url":"lingyigeyemian.html","title":"创建另一个页面","keywords":"","body":"创建另一个页面 在上一节中，我们用XML的方式编写了一个包含文本和按钮的页面。为了帮助开发者熟悉在代码中创建布局的方式，接下来我们使用代码的方式编写第二个页面。 在“Project”窗口，打开“entry > src > main > java > com.example.myapplication”，右键点击“slice”文件夹，选择“New > Java Class”，命名为“SecondAbilitySlice”，单击回车键。 第二个页面上有一个文本。在上一步创建的“SecondAbilitySlice”文件中，添加一个Text，示例代码如下： package com.example.myapplication.slice; import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.colors.RgbColor;import ohos.agp.components.DependentLayout;import ohos.agp.components.Text;import ohos.agp.components.element.ShapeElement;import ohos.agp.utils.Color;import ohos.agp.components.DependentLayout.LayoutConfig; public class SecondAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 声明布局 DependentLayout myLayout = new DependentLayout(this); // 设置布局宽高 myLayout.setWidth(LayoutConfig.MATCH_PARENT); myLayout.setHeight(LayoutConfig.MATCH_PARENT); // 设置布局背景为白色 ShapeElement background = new ShapeElement(); background.setRgbColor(new RgbColor(255, 255, 255)); myLayout.setBackground(background); // 创建一个文本 Text text = new Text(this); text.setText(\"Hi there\"); text.setWidth(LayoutConfig.MATCH_PARENT); text.setTextSize(100); text.setTextColor(Color.BLACK); // 设置文本的布局 DependentLayout.LayoutConfig textConfig = new DependentLayout.LayoutConfig(LayoutConfig.MATCH_CONTENT, LayoutConfig.MATCH_CONTENT); textConfig.addRule(LayoutConfig.CENTER_IN_PARENT); text.setLayoutConfig(textConfig); myLayout.addComponent(text); super.setUIContent(myLayout); }} "},"shi-xian-ye-mian-tiao-zhuan.html":{"url":"shi-xian-ye-mian-tiao-zhuan.html","title":"实现页面跳转","keywords":"","body":"实现页面跳转 打开第一个页面的“MainAbilitySlice.java”文件，添加按钮的响应逻辑，实现点击按钮跳转到下一页，示例代码如下： package com.example.myapplication.slice; import com.example.myapplication.ResourceTable; import ohos.aafwk.ability.AbilitySlice; import ohos.aafwk.content.Intent; import ohos.agp.components.Button; public class MainAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); Button button = (Button) findComponentById(ResourceTable.Id_button); // 点击按钮跳转至第二个页面 button.setClickedListener(listener -> present(new SecondAbilitySlice(), new Intent())); } } 再次运行项目，效果如下图所示。 恭喜你，至此已成功完成HarmonyOS快速入门。 "},"develop-overview.html":{"url":"develop-overview.html","title":"开发概述","keywords":"","body":"开发概述 通用开发历程 各类设备（手机/平板、智能穿戴、智慧屏等）通用的用户应用程序开发历程如下表所示。 任务 简介 相关资源 开发Ability Ability是HarmonyOS应用程序的重要组成部分，分为FA（Feature Ability）和PA（Particle Ability）两种类型：FA支持Page Ability：Page模板是FA唯一支持的模板，用于提供与用户交互的能力。PA支持Service Ability和Data Ability：Service模板用于提供后台运行任务的能力；Data模板用于对外部提供统一的数据访问抽象。进行HarmonyOS应用开发，首先要了解Ability如何使用。 Page AbilityService AbilityData Ability 开发UI FA需要提供UI用于与用户进行交互，HarmonyOS提供了Java UI和JS UI两种UI框架：Java UI提供了细粒度的UI编程接口，使应用开发更加灵活；JS UI提供了相对高层的UI描述，使应用开发更加简单。说明针对轻量级智能穿戴（Lite Wearable），现阶段只使用JS语言进行应用开发，详见轻量级智能穿戴开发。 Java UI框架Java API参考JS UI框架JS API参考 开发业务功能 媒体：视频、音频、图像、相机等功能的开发。安全：权限、生物特征识别等功能的开发。AI：图像超分、语音识别、码生成等功能的开发。网络连接：NFC、蓝牙、WLAN等功能的开发。设备管理：传感器、控制类小器件、位置等功能的开发。数据管理：数据库、分布式数据/文件服务、数据搜索等功能的开发。线程：线程管理、线程间通信等功能的开发。IDL：声明系统服务和Ability对外提供的服务接口，并生成相关代码。 媒体开发指南安全开发指南AI开发指南网络与连接开发指南设备管理开发指南数据管理开发指南线程开发指南IDL接口使用指南 原子化服务开发历程 HarmonyOS除支持传统方式的需要安装的应用外，还支持提供特定功能的免安装的应用（即原子化服务），供用户在合适的场景、合适的设备上便捷使用。 原子化服务相对于传统方式的需要安装的应用更加轻量，同时提供更丰富的入口、更精准的分发。原子化服务的详细介绍请参见“原子化服务”。 其基本开发历程如下表所示。 任务 开发历程 相关内容 了解HarmonyOS 了解HarmonyOS的系统定位、技术特性、应用开发的基本概念和基础知识，熟悉HarmonyOS应用开发通用流程。 HarmonyOS概述开发基础知识快速入门 设计原子化服务 在设计阶段，需要满足原子化服务的设计规范，包括图标、卡片、分布式等规范。 原子化服务设计 掌握原子化服务约束 了解原子化服务之间的调用管控机制。 三方应用调用管控机制 开发原子化服务基础体验 了解原子化服务总体开发规则、如何开发服务卡片等基础体验。 原子化服务总体开发要求服务卡片开发指南 开发原子化服务分布式体验 了解如何开发流转、分享等分布式体验。 流转开发指南华为分享接入指南 "},"ability-overview.html":{"url":"ability-overview.html","title":"Ability概述","keywords":"","body":"Ability概述 Ability是应用所具备能力的抽象，也是应用程序的重要组成部分。一个应用可以具备多种能力（即可以包含多个Ability），HarmonyOS支持应用以Ability为单位进行部署。Ability可以分为FA（Feature Ability）和PA（Particle Ability）两种类型，每种类型为开发者提供了不同的模板，以便实现不同的业务功能。 FA支持 Page Ability ： Page模板是FA唯一支持的模板，用于提供与用户交互的能力。一个Page实例可以包含一组相关页面，每个页面用一个AbilitySlice实例表示。 PA支持 Service Ability 和 Data Ability ： Service模板：用于提供后台运行任务的能力。 Data模板：用于对外部提供统一的数据访问抽象。 在配置文件（config.json）中注册Ability时，可以通过配置Ability元素中的“type”属性来指定Ability模板类型，示例如下。 其中，“type”的取值可以为“page”、“service”或“data”，分别代表Page模板、Service模板、Data模板。为了便于表述，后文中我们将基于Page模板、Service模板、Data模板实现的Ability分别简称为Page、Service、Data。 { \"module\": { ... \"abilities\": [ { ... \"type\": \"page\" ... } ] ... } ...} 相关实例 针对Ability开发，有以下Codelabs可供参考： 分布式亲子早教系统 基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。 分布式新闻客户端 基于HarmonyOS应用中Service Ability和Page Ability的使用，实现跨设备FA拉起。 跨设备视频播放 基于分布式能力和IDL跨进程通信，实现视频跨设备播放、控制。 分布式输入法 基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放。 分布式游戏手柄 基于分布式能力，将手机作为智慧屏的虚拟手柄终端，组成全新的多人娱乐场景。 "},"page-concept.html":{"url":"page-concept.html","title":"Page Ability基本概念","keywords":"","body":"Page Ability基本概念 Page与AbilitySlice Page模板（以下简称“Page”）是FA唯一支持的模板，用于提供与用户交互的能力。一个Page可以由一个或多个AbilitySlice构成，AbilitySlice是指应用的单个页面及其控制逻辑的总和。 当一个Page由多个AbilitySlice共同构成时，这些AbilitySlice页面提供的业务能力应具有高度相关性。例如，新闻浏览功能可以通过一个Page来实现，其中包含了两个AbilitySlice：一个AbilitySlice用于展示新闻列表，另一个AbilitySlice用于展示新闻详情。Page和AbilitySlice的关系如图1所示。 图1 Page与AbilitySlice 相比于桌面场景，移动场景下应用之间的交互更为频繁。通常，单个应用专注于某个方面的能力开发，当它需要其他能力辅助时，会调用其他应用提供的能力。例如，外卖应用提供了联系商家的业务功能入口，当用户在使用该功能时，会跳转到通话应用的拨号页面。与此类似，HarmonyOS支持不同Page之间的跳转，并可以指定跳转到目标Page中某个具体的AbilitySlice。 AbilitySlice路由配置 虽然一个Page可以包含多个AbilitySlice，但是Page进入前台时界面默认只展示一个AbilitySlice。默认展示的AbilitySlice是通过setMainRoute()方法来指定的。如果需要更改默认展示的AbilitySlice，可以通过addActionRoute()方法为此AbilitySlice配置一条路由规则。此时，当其他Page实例期望导航到此AbilitySlice时，可以在Intent中指定Action，详见不同Page间导航。 setMainRoute()方法与addActionRoute()方法的使用示例如下： public class MyAbility extends Ability { @Override public void onStart(Intent intent) { super.onStart(intent); // set the main route setMainRoute(MainSlice.class.getName()); // set the action route addActionRoute(\"action.pay\", PaySlice.class.getName()); addActionRoute(\"action.scan\", ScanSlice.class.getName()); }} addActionRoute()方法中使用的动作命名，需要在应用配置文件（config.json）中注册： { \"module\": { \"abilities\": [ { \"skills\":[ { \"actions\":[ \"action.pay\", \"action.scan\" ] } ] ... } ] ... } ...} "},"page-lifecycle.html":{"url":"page-lifecycle.html","title":"Page Ablity生命周期","keywords":"","body":"Page Ablity生命周期 系统管理或用户操作等行为均会引起Page实例在其生命周期的不同状态之间进行转换。Ability类提供的回调机制能够让Page及时感知外界变化，从而正确地应对状态变化（比如释放资源），这有助于提升应用的性能和稳健性。 Page生命周期回调 Page生命周期的不同状态转换及其对应的回调，如图1所示。 图1 Page生命周期 onStart() 当系统首次创建Page实例时，触发该回调。对于一个Page实例，该回调在其生命周期过程中仅触发一次，Page在该逻辑后将进入INACTIVE状态。开发者必须重写该方法，并在此配置默认展示的AbilitySlice。 @Override public void onStart(Intent intent) { super.onStart(intent); super.setMainRoute(FooSlice.class.getName()); } onActive() Page会在进入INACTIVE状态后来到前台，然后系统调用此回调。Page在此之后进入ACTIVE状态，该状态是应用与用户交互的状态。Page将保持在此状态，除非某类事件发生导致Page失去焦点，比如用户点击返回键或导航到其他Page。当此类事件发生时，会触发Page回到INACTIVE状态，系统将调用onInactive()回调。此后，Page可能重新回到ACTIVE状态，系统将再次调用onActive()回调。因此，开发者通常需要成对实现onActive()和onInactive()，并在onActive()中获取在onInactive()中被释放的资源。 onInactive() 当Page失去焦点时，系统将调用此回调，此后Page进入INACTIVE状态。开发者可以在此回调中实现Page失去焦点时应表现的恰当行为。 onBackground() 如果Page不再对用户可见，系统将调用此回调通知开发者用户进行相应的资源释放，此后Page进入BACKGROUND状态。开发者应该在此回调中释放Page不可见时无用的资源，或在此回调中执行较为耗时的状态保存操作。 onForeground() 处于BACKGROUND状态的Page仍然驻留在内存中，当重新回到前台时（比如用户重新导航到此Page），系统将先调用onForeground()回调通知开发者，而后Page的生命周期状态回到INACTIVE状态。开发者应当在此回调中重新申请在onBackground()中释放的资源，最后Page的生命周期状态进一步回到ACTIVE状态，系统将通过onActive()回调通知开发者用户。 onStop() 系统将要销毁Page时，将会触发此回调函数，通知用户进行系统资源的释放。销毁Page的可能原因包括以下几个方面： 用户通过系统管理能力关闭指定Page，例如使用任务管理器关闭Page。 用户行为触发Page的terminateAbility()方法调用，例如使用应用的退出功能。 配置变更导致系统暂时销毁Page并重建。 系统出于资源管理目的，自动触发对处于BACKGROUND状态Page的销毁。 AbilitySlice生命周期 AbilitySlice作为Page的组成单元，其生命周期是依托于其所属Page生命周期的。AbilitySlice和Page具有相同的生命周期状态和同名的回调，当Page生命周期发生变化时，它的AbilitySlice也会发生相同的生命周期变化。此外，AbilitySlice还具有独立于Page的生命周期变化，这发生在同一Page中的AbilitySlice之间导航时，此时Page的生命周期状态不会改变。 AbilitySlice生命周期回调与Page的相应回调类似，因此不再赘述。由于AbilitySlice承载具体的页面，开发者必须重写AbilitySlice的onStart()回调，并在此方法中通过setUIContent()方法设置页面，如下所示： @Override protected void onStart(Intent intent) { super.onStart(intent); setUIContent(ResourceTable.Layout_main_layout); } AbilitySlice实例创建和管理通常由应用负责，系统仅在特定情况下会创建AbilitySlice实例。例如，通过导航启动某个AbilitySlice时，是由系统负责实例化；但是在同一个Page中不同的AbilitySlice间导航时则由应用负责实例化。 Page与AbilitySlice生命周期关联 当AbilitySlice处于前台且具有焦点时，其生命周期状态随着所属Page的生命周期状态的变化而变化。当一个Page拥有多个AbilitySlice时，例如：MyAbility下有FooAbilitySlice和BarAbilitySlice，当前FooAbilitySlice处于前台并获得焦点，并即将导航到BarAbilitySlice，在此期间的生命周期状态变化顺序为： FooAbilitySlice从ACTIVE状态变为INACTIVE状态。 BarAbilitySlice则从INITIAL状态首先变为INACTIVE状态，然后变为ACTIVE状态（假定此前BarAbilitySlice未曾启动）。 FooAbilitySlice从INACTIVE状态变为BACKGROUND状态。 对应两个slice的生命周期方法回调顺序为： FooAbilitySlice.onInactive() --> BarAbilitySlice.onStart() --> BarAbilitySlice.onActive() --> FooAbilitySlice.onBackground() 在整个流程中，MyAbility始终处于ACTIVE状态。但是，当Page被系统销毁时，其所有已实例化的AbilitySlice将联动销毁，而不仅是处于前台的AbilitySlice。 "},"page-switching.html":{"url":"page-switching.html","title":"AbilitySlice间导航","keywords":"","body":"AbilitySlice间导航 同一Page内导航 当发起导航的AbilitySlice和导航目标的AbilitySlice处于同一个Page时，您可以通过present()方法实现导航。如下代码片段展示通过点击按钮导航到其他AbilitySlice的方法： @Overrideprotected void onStart(Intent intent) { ... Button button = ...; button.setClickedListener(listener -> present(new TargetSlice(), new Intent())); ... } 如果开发者希望在用户从导航目标AbilitySlice返回时，能够获得其返回结果，则应当使用presentForResult()实现导航。用户从导航目标AbilitySlice返回时，系统将回调onResult()来接收和处理返回结果，开发者需要重写该方法。返回结果由导航目标AbilitySlice在其生命周期内通过setResult()进行设置。 @Overrideprotected void onStart(Intent intent) { ... Button button = ...; button.setClickedListener(listener -> presentForResult(new TargetSlice(), new Intent(), 0)); ... } @Overrideprotected void onResult(int requestCode, Intent resultIntent) { if (requestCode == 0) { // Process resultIntent here. }} 系统为每个Page维护了一个AbilitySlice实例的栈，每个进入前台的AbilitySlice实例均会入栈。当开发者在调用present()或presentForResult()时指定的AbilitySlice实例已经在栈中存在时，则栈中位于此实例之上的AbilitySlice均会出栈并终止其生命周期。前面的示例代码中，导航时指定的AbilitySlice实例均是新建的，即便重复执行此代码（此时作为导航目标的这些实例是同一个类），也不会导致任何AbilitySlice出栈。 不同Page间导航 AbilitySlice作为Page的内部单元，以Action的形式对外暴露，因此可以通过配置Intent的Action导航到目标AbilitySlice。Page间的导航可以使用startAbility()或startAbilityForResult()方法，获得返回结果的回调为onAbilityResult()。在Ability中调用setResult()可以设置返回结果。详细用法可参考根据Operation的其他属性启动应用中的示例。 "},"cross-device.html":{"url":"cross-device.html","title":"跨设备迁移","keywords":"","body":"跨设备迁移 跨设备迁移（下文简称“迁移”）支持将Page在同一用户的不同设备间迁移，以便支持用户无缝切换的诉求。以Page从设备A迁移到设备B为例，迁移动作主要步骤如下： 设备A上的Page请求迁移。 HarmonyOS处理迁移任务，并回调设备A上Page的保存数据方法，用于保存迁移必须的数据。 HarmonyOS在设备B上启动同一个Page，并回调其恢复数据方法。 开发者可以参考以下详细步骤开发具有迁移功能的Page。 实现IAbilityContinuation接口 说明 一个应用可能包含多个Page，仅需要在支持迁移的Page中通过以下方法实现IAbilityContinuation接口。同时，此Page所包含的所有AbilitySlice也需要实现此接口。 onStartContinuation() Page请求迁移后，系统首先回调此方法，开发者可以在此回调中决策当前是否可以执行迁移，比如，弹框让用户确认是否开始迁移。 onSaveData() 如果onStartContinuation()返回true，则系统回调此方法，开发者在此回调中保存必须传递到另外设备上以便恢复Page状态的数据。 onRestoreData() 源侧设备上Page完成保存数据后，系统在目标侧设备上回调此方法，开发者在此回调中接受用于恢复Page状态的数据。注意，在目标侧设备上的Page会重新启动其生命周期，无论其启动模式如何配置。且系统回调此方法的时机在onStart()之前。 onCompleteContinuation() 目标侧设备上恢复数据一旦完成，系统就会在源侧设备上回调Page的此方法，以便通知应用迁移流程已结束。开发者可以在此检查迁移结果是否成功，并在此处理迁移结束的动作，例如，应用可以在迁移完成后终止自身生命周期。 onRemoteTerminated() 如果开发者使用continueAbilityReversibly()而不是continueAbility()，则此后可以在源侧设备上使用reverseContinueAbility()进行回迁。这种场景下，相当于同一个Page（的两个实例）同时在两个设备上运行，迁移完成后，如果目标侧设备上Page因任何原因终止，则源侧Page通过此回调接收终止通知。 请求迁移 实现IAbilityContinuation的Page可以在其生命周期内，调用continueAbility()或continueAbilityReversibly()请求迁移。两者的区别是，通过后者发起的迁移此后可以进行回迁。 try { continueAbility();} catch (IllegalStateException e) { // Maybe another continuation in progress. ...} 以Page从设备A迁移到设备B为例，详细的流程如下： 设备A上的Page请求迁移。 系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onStartContinuation()方法，以确认当前是否可以立即迁移。 如果可以立即迁移，则系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onSaveData()方法，以便保存迁移后恢复状态必须的数据。 如果保存数据成功，则系统在设备B上启动同一个Page，并恢复AbilitySlice栈，然后回调IAbilityContinuation.onRestoreData()方法，传递此前保存的数据；此后设备B上此Page从onStart()开始其生命周期回调。 系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onCompleteContinuation()方法，通知数据恢复成功与否。 请求回迁 使用continueAbilityReversibly()请求迁移并完成后，源侧设备上已迁移的Page可以发起回迁，以便使用户活动重新回到此设备。 try { reverseContinueAbility();} catch (IllegalStateException e) { // Maybe another continuation in progress. ...} 以Page从设备A迁移到设备B后并请求回迁为例，详细的流程如下： 设备A上的Page请求回迁。 系统回调设备B上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onStartContinuation()方法，以确认当前是否可以立即迁移。 如果可以立即迁移，则系统回调设备B上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onSaveData()方法，以便保存回迁后恢复状态必须的数据。 如果保存数据成功，则系统在设备A上Page恢复AbilitySlice栈，然后回调IAbilityContinuation.onRestoreData()方法，传递此前保存的数据。 如果数据恢复成功，则系统终止设备B上Page的生命周期。 相关实例 针对Page Ability开发，有以下示例工程可供参考： PageAbility 本示例演示了同一Page Ability内和不同Page间的AbilitySlice导航，以及Page Ability的跨端迁移。 针对跨设备迁移开发，有以下Codelabs可供参考： 分布式邮件编辑 基于跨设备迁移和分布式文件能力，实现邮件的跨设备编辑和附件的调用。 "},"service-concept.html":{"url":"service-concept.html","title":"Service Ability基本概念","keywords":"","body":"Service Ability基本概念 基于Service模板的Ability（以下简称“Service”）主要用于后台运行任务（如执行音乐播放、文件下载等），但不提供用户交互界面。Service可由其他应用或Ability启动，即使用户切换到其他应用，Service仍将在后台继续运行。 Service是单实例的。在一个设备上，相同的Service只会存在一个实例。如果多个Ability共用这个实例，只有当与Service绑定的所有Ability都退出后，Service才能够退出。由于Service是在主线程里执行的，因此，如果在Service里面的操作时间过长，开发者必须在Service里创建新的线程来处理（详见线程间通信），防止造成主线程阻塞，应用程序无响应。 "},"service-creating.html":{"url":"service-creating.html","title":"创建Service","keywords":"","body":"创建Service 介绍如何创建一个Service。 创建Ability的子类，实现Service相关的生命周期方法。Service也是一种Ability，Ability为Service提供了以下生命周期方法，用户可以重写这些方法，来添加其他Ability请求与Service Ability交互时的处理方法。 onStart() 该方法在创建Service的时候调用，用于Service的初始化。在Service的整个生命周期只会调用一次，调用时传入的Intent应为空。 onCommand() 在Service创建完成之后调用，该方法在客户端每次启动该Service时都会调用，用户可以在该方法中做一些调用统计、初始化类的操作。 onConnect() 在Ability和Service连接时调用，该方法返回IRemoteObject对象，用户可以在该回调函数中生成对应Service的IPC通信通道，以便Ability与Service交互。Ability可以多次连接同一个Service，系统会缓存该Service的IPC通信对象，只有第一个客户端连接Service时，系统才会调用Service的onConnect方法来生成IRemoteObject对象，而后系统会将同一个RemoteObject对象传递至其他连接同一个Service的所有客户端，而无需再次调用onConnect方法。 onDisconnect() 在Ability与绑定的Service断开连接时调用。 onStop() 在Service销毁时调用。Service应通过实现此方法来清理任何资源，如关闭线程、注册的侦听器等。 创建Service的代码示例如下： public class ServiceAbility extends Ability { @Override public void onStart(Intent intent) { super.onStart(intent); } @Override public void onCommand(Intent intent, boolean restart, int startId) { super.onCommand(intent, restart, startId); } @Override public IRemoteObject onConnect(Intent intent) { return super.onConnect(intent); } @Override public void onDisconnect(Intent intent) { super.onDisconnect(intent); } @Override public void onStop() { super.onStop(); }} 注册Service。 Service也需要在应用配置文件中进行注册，注册类型type需要设置为service。 { \"module\": { \"abilities\": [ { \"name\": \".ServiceAbility\", \"type\": \"service\", \"visible\": true ... } ] ... } ...} "},"service-starting.html":{"url":"service-starting.html","title":"启动Service","keywords":"","body":"启动Service 介绍通过startAbility()启动Service以及对应的停止方法。 启动Service Ability为开发者提供了startAbility()方法来启动另外一个Ability。因为Service也是Ability的一种，开发者同样可以通过将Intent传递给该方法来启动Service。不仅支持启动本地Service，还支持启动远程Service。 开发者可以通过构造包含DeviceId、BundleName与AbilityName的Operation对象来设置目标Service信息。这三个参数的含义如下： DeviceId：表示设备ID。如果是本地设备，则可以直接留空；如果是远程设备，可以通过ohos.distributedschedule.interwork.DeviceManager提供的getDeviceList获取设备列表，详见《API参考》。 BundleName：表示包名称。 AbilityName：表示待启动的Ability名称。 启动本地设备Service的代码示例如下： Intent intent = new Intent();Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.domainname.hiworld.himusic\") .withAbilityName(\"com.domainname.hiworld.himusic.ServiceAbility\") .build();intent.setOperation(operation);startAbility(intent); 启动远程设备Service的代码示例如下： Intent intent = new Intent();Operation operation = new Intent.OperationBuilder() .withDeviceId(\"deviceId\") .withBundleName(\"com.domainname.hiworld.himusic\") .withAbilityName(\"com.domainname.hiworld.himusic.ServiceAbility\") .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) // 设置支持分布式调度系统多设备启动的标识 .build();intent.setOperation(operation);startAbility(intent); 执行上述代码后，Ability将通过startAbility() 方法来启动Service。 如果Service尚未运行，则系统会先调用onStart()来初始化Service，再回调Service的onCommand()方法来启动Service。 如果Service正在运行，则系统会直接回调Service的onCommand()方法来启动Service。 停止Service Service一旦创建就会一直保持在后台运行，除非必须回收内存资源，否则系统不会停止或销毁Service。开发者可以在Service中通过terminateAbility()停止本Service或在其他Ability调用stopAbility()来停止Service。 停止Service同样支持停止本地设备Service和停止远程设备Service，使用方法与启动Service一样。一旦调用停止Service的方法，系统便会尽快销毁Service。 "},"service-lifecycle.html":{"url":"service-lifecycle.html","title":"Service Ability生命周期","keywords":"","body":"Service Ability生命周期 与Page类似，Service也拥有生命周期，如图1所示。根据调用方法的不同，其生命周期有以下两种路径： 启动 Service 该Service在其他Ability调用startAbility()时创建，然后保持运行。其他Ability通过调用stopAbility()来停止Service，Service停止后，系统会将其销毁。 连接 Service 该Service在其他Ability调用connectAbility()时创建，客户端可通过调用disconnectAbility()断开连接。多个客户端可以绑定到相同Service，而且当所有绑定全部取消后，系统即会销毁该Service。 图1 Service生命周期 "},"service-foreground.html":{"url":"service-foreground.html","title":"前台Service","keywords":"","body":"前台Service 一般情况下，Service都是在后台运行的，后台Service的优先级都是比较低的，当资源不足时，系统有可能回收正在运行的后台Service。 在一些场景下（如播放音乐），用户希望应用能够一直保持运行，此时就需要使用前台Service。前台Service会始终保持正在运行的图标在系统状态栏显示。 使用前台Service并不复杂，开发者只需在Service创建的方法里，调用keepBackgroundRunning()将Service与通知绑定。调用keepBackgroundRunning()方法前需要在配置文件中声明ohos.permission.KEEP_BACKGROUND_RUNNING权限，同时还需要在配置文件中添加对应的backgroundModes参数。在onStop()方法中调用cancelBackgroundRunning()方法可停止前台Service。 使用前台Service的onStart()代码示例如下： // 创建通知，其中1005为notificationIdNotificationRequest request = new NotificationRequest(1005);NotificationRequest.NotificationNormalContent content = new NotificationRequest.NotificationNormalContent();content.setTitle(\"title\").setText(\"text\");NotificationRequest.NotificationContent notificationContent = new NotificationRequest.NotificationContent(content);request.setContent(notificationContent); // 绑定通知，1005为创建通知时传入的notificationIdkeepBackgroundRunning(1005, request); 在配置文件中，“module > abilities”字段下对当前Service做如下配置： { \"name\": \".ServiceAbility\", \"type\": \"service\", \"visible\": true, \"backgroundModes\": [\"dataTransfer\", \"location\"]} "},"data-concept.html":{"url":"data-concept.html","title":"Data Ability基本概念","keywords":"","body":"Data Ability基本概念 使用Data模板的Ability（以下简称“Data”）有助于应用管理其自身和其他应用存储数据的访问，并提供与其他应用共享数据的方法。Data既可用于同设备不同应用的数据共享，也支持跨设备不同应用的数据共享。 数据的存放形式多样，可以是数据库，也可以是磁盘上的文件。Data对外提供对数据的增、删、改、查，以及打开文件等接口，这些接口的具体实现由开发者提供。 URI介绍 Data的提供方和使用方都通过URI（Uniform Resource Identifier）来标识一个具体的数据，例如数据库中的某个表或磁盘上的某个文件。HarmonyOS的URI仍基于URI通用标准，格式如下： scheme：协议方案名，固定为“dataability”，代表Data Ability所使用的协议类型。 authority：设备ID。如果为跨设备场景，则为目标设备的ID；如果为本地设备场景，则不需要填写。 path：资源的路径信息，代表特定资源的位置信息。 query：查询参数。 fragment：可以用于指示要访问的子资源。 URI示例： 跨设备场景：dataability://device_id/com.domainname.dataability.persondata/person/10 本地设备：dataability:///com.domainname.dataability.persondata/person/10 "},"data-creating.html":{"url":"data-creating.html","title":"创建Data","keywords":"","body":"创建Data 使用Data模板的Ability形式仍然是Ability，因此，开发者需要为应用添加一个或多个Ability的子类，来提供程序与其他应用之间的接口。Data为结构化数据和文件提供了不同API接口供用户使用，因此，开发者需要首先确定好使用何种类型的数据。本章节主要讲述了创建Data的基本步骤和需要使用的接口。 Data提供方可以自定义数据的增、删、改、查，以及文件打开等功能，并对外提供这些接口。 确定数据存储方式 确定数据的存储方式，Data支持以下两种数据形式： 文件数据：如文本、图片、音乐等。 结构化数据：如数据库等。 实现UserDataAbility UserDataAbility用于接收其他应用发送的请求，提供外部程序访问的入口，从而实现应用间的数据访问。 实现UserDataAbility，需要在“Project”窗口当前工程的主目录（“entry > src > main > java > com.xxx.xxx”）选择“File > New > Ability > Empty Data Ability”，设置“Data Name”后完成UserDataAbility的创建。 Data提供了文件存储和数据库存储两组接口供用户使用。 文件存储 开发者需要在Data中重写FileDescriptor openFile(Uri uri, String mode)方法来操作文件：uri为客户端传入的请求目标路径；mode为开发者对文件的操作选项，可选方式包含“r”(读), “w”(写), “rw”(读写)等。 ohos.rpc.MessageParcel类提供了一个静态方法，用于获取MessageParcel实例。开发者可通过获取到的MessageParcel实例，使用dupFileDescriptor()函数复制待操作文件流的文件描述符，并将其返回，供远端应用访问文件。 示例：根据传入的uri打开对应的文件 private static final HiLogLabel LABEL_LOG = new HiLogLabel(HiLog.LOG_APP, 0xD00201, \"Data_Log\"); @Overridepublic FileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException { // 创建messageParcel MessageParcel messageParcel = MessageParcel.obtain(); File file = new File(uri.getDecodedPathList().get(0)); //get(0)是获取URI完整字段中查询参数字段。 if (mode == null || !\"rw\".equals(mode)) { file.setReadOnly(); } FileInputStream fileIs = new FileInputStream(file); FileDescriptor fd = null; try { fd = fileIs.getFD(); } catch (IOException e) { HiLog.info(LABEL_LOG, \"failed to getFD\"); } // 绑定文件描述符 return messageParcel.dupFileDescriptor(fd);} 数据库存储 初始化数据库连接。 系统会在应用启动时调用onStart()方法创建Data实例。在此方法中，开发者应该创建数据库连接，并获取连接对象，以便后续和数据库进行操作。为了避免影响应用启动速度，开发者应当尽可能将非必要的耗时任务推迟到使用时执行，而不是在此方法中执行所有初始化。 示例：初始化的时候连接数据库 private static final String DATABASE_NAME = \"UserDataAbility.db\";private static final String DATABASE_NAME_ALIAS = \"UserDataAbility\";private static final HiLogLabel LABEL_LOG = new HiLogLabel(HiLog.LOG_APP, 0xD00201, \"Data_Log\");private OrmContext ormContext = null; @Overridepublic void onStart(Intent intent) { super.onStart(intent); DatabaseHelper manager = new DatabaseHelper(this); ormContext = manager.getOrmContext(DATABASE_NAME_ALIAS, DATABASE_NAME, BookStore.class);} 编写数据库操作方法。 Ability定义了6个方法供用户处理对数据库表数据的增删改查。这6个方法在Ability中已默认实现，开发者可按需重写。 | 方法 | 描述 | | ------------------------------------------------------------ | ---------------------- | | ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates) | 查询数据库 | | int insert(Uri uri, ValuesBucket value) | 向数据库中插入单条数据 | | int batchInsert(Uri uri, ValuesBucket[] values) | 向数据库中插入多条数据 | | int delete(Uri uri, DataAbilityPredicates predicates) | 删除一条或多条数据 | | int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates) | 更新数据库 | | DataAbilityResult[] executeBatch(ArrayList operations) | 批量操作数据库 | 这些方法的使用说明如下： query() 该方法接收三个参数，分别是查询的目标路径，查询的列名，以及查询条件，查询条件由类DataAbilityPredicates构建。根据传入的列名和查询条件查询用户表的代码示例如下： public ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates) { if (ormContext == null) { HiLog.error(LABEL_LOG, \"failed to query, ormContext is null\"); return null; } // 查询数据库 OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class); ResultSet resultSet = ormContext.query(ormPredicates, columns); if (resultSet == null) { HiLog.info(LABEL_LOG, \"resultSet is null\"); } // 返回结果 return resultSet;} insert() 该方法接收两个参数，分别是插入的目标路径和插入的数据值。其中，插入的数据由ValuesBucket封装，服务端可以从该参数中解析出对应的属性，然后插入到数据库中。此方法返回一个int类型的值用于标识结果。接收到传过来的用户信息并把它保存到数据库中的代码示例如下： public int insert(Uri uri, ValuesBucket value) { // 参数校验 if (ormContext == null) { HiLog.error(LABEL_LOG, \"failed to insert, ormContext is null\"); return -1; } // 构造插入数据 User user = new User(); user.setUserId(value.getInteger(\"userId\")); user.setFirstName(value.getString(\"firstName\")); user.setLastName(value.getString(\"lastName\")); user.setAge(value.getInteger(\"age\")); user.setBalance(value.getDouble(\"balance\")); // 插入数据库 boolean isSuccessful = ormContext.insert(user); if (!isSuccessful) { HiLog.error(LABEL_LOG, \"failed to insert\"); return -1; } isSuccessful = ormContext.flush(); if (!isSuccessful) { HiLog.error(LABEL_LOG, \"failed to insert flush\"); return -1; } DataAbilityHelper.creator(this, uri).notifyChange(uri); int id = Math.toIntExact(user.getRowId()); return id;} batchInsert() 该方法为批量插入方法，接收一个ValuesBucket数组用于单次插入一组对象。它的作用是提高插入多条重复数据的效率。该方法系统已实现，开发者可以直接调用。 delete() 该方法用来执行删除操作。删除条件由类DataAbilityPredicates构建，服务端在接收到该参数之后可以从中解析出要删除的数据，然后到数据库中执行。根据传入的条件删除用户表数据的代码示例如下： public int delete(Uri uri, DataAbilityPredicates predicates) { if (ormContext == null) { HiLog.error(LABEL_LOG, \"failed to delete, ormContext is null\"); return -1; } OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class); int value = ormContext.delete(ormPredicates); DataAbilityHelper.creator(this, uri).notifyChange(uri); return value;} update() 此方法用来执行更新操作。用户可以在ValuesBucket参数中指定要更新的数据，在DataAbilityPredicates中构建更新的条件等。更新用户表的数据的代码示例如下： public int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates) { if (ormContext == null) { HiLog.error(LABEL_LOG, \"failed to update, ormContext is null\"); return -1; } OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class); int index = ormContext.update(ormPredicates, value); HiLog.info(LABEL_LOG, \"UserDataAbility update value:\" + index); DataAbilityHelper.creator(this, uri).notifyChange(uri); return index;} executeBatch() 此方法用来批量执行操作。DataAbilityOperation中提供了设置操作类型、数据和操作条件的方法，用户可自行设置自己要执行的数据库操作。该方法系统已实现，开发者可以直接调用。 说明 上述代码示例中，初始化了数据库类BookStore.class，并通过实体类User.class对该数据库的表User进行增删改查操作。 关于对象关系映射数据库的具体逻辑，以及示例中BookStore.class与User.class的逻辑关系，可参考“对象关系映射数据库开发指导”。 注册UserDataAbility 和Service类似，开发者必须在配置文件中注册Data。 配置文件中该字段在创建Data Ability时会自动创建，name与创建的Data Ability一致。 需要关注以下属性： type: 类型设置为data uri: 对外提供的访问路径，全局唯一 permissions: 访问该data ability时需要申请的访问权限 说明 如果权限非系统权限，需要在配置文件中进行自定义。请参考权限开发指导中关于“自定义权限”的相关说明。 { \"name\": \".UserDataAbility\", \"type\": \"data\", \"visible\": true, \"uri\": \"dataability://com.example.myapplication5.DataAbilityTest\", \"permissions\": [ \"com.example.myapplication5.DataAbility.DATA\" ]} "},"data-accessing.html":{"url":"data-accessing.html","title":"访问Data","keywords":"","body":"访问Data 开发者可以通过DataAbilityHelper类来访问当前应用或其他应用提供的共享数据。DataAbilityHelper作为客户端，与提供方的Data进行通信。Data接收到请求后，执行相应的处理，并返回结果。DataAbilityHelper提供了一系列与Data Ability对应的方法。 下面介绍DataAbilityHelper具体的使用步骤。 声明使用权限 如果待访问的Data声明了访问需要权限，则访问此Data需要在配置文件中声明需要此权限。声明请参考权限申请字段说明。 \"reqPermissions\": [ { \"name\": \"com.example.myapplication5.DataAbility.DATA\" }, // 访问文件还需要添加访问存储读写权限 { \"name\": \"ohos.permission.READ_USER_STORAGE\" }, { \"name\": \"ohos.permission.WRITE_USER_STORAGE\" }] 创建DataAbilityHelper DataAbilityHelper为开发者提供了creator()方法来创建DataAbilityHelper实例。该方法为静态方法，有多个重载。最常见的方法是通过传入一个context对象来创建DataAbilityHelper对象。 获取helper对象示例： DataAbilityHelper helper = DataAbilityHelper.creator(this); 访问Data Ability DataAbilityHelper为开发者提供了一系列的接口来访问不同类型的数据（文件、数据库等）。 访问文件 DataAbilityHelper为开发者提供了FileDescriptor openFile(Uri uri, String mode)方法来操作文件。此方法需要传入两个参数，其中uri用来确定目标资源路径，mode用来指定打开文件的方式，可选方式包含“r”(读), “w”(写), “rw”(读写)，“wt”(覆盖写)，“wa”(追加写)，“rwt”(覆盖写且可读)。 该方法返回一个目标文件的FD（文件描述符），把文件描述符封装成流，开发者就可以对文件流进行自定义处理。 访问文件示例： // 读取文件描述符FileDescriptor fd = helper.openFile(uri, \"r\");FileInputStream fis = new FileInputStream(fd); // 使用文件描述符封装成的文件流，进行文件操作 访问数据库 DataAbilityHelper为开发者提供了增、删、改、查以及批量处理等方法来操作数据库。 说明 对数据库的操作方法，详见数据管理中各数据库类型的开发指南。 | 方法 | 描述 | | ------------------------------------------------------------ | ---------------------- | | ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates) | 查询数据库 | | int insert(Uri uri, ValuesBucket value) | 向数据库中插入单条数据 | | int batchInsert(Uri uri, ValuesBucket[] values) | 向数据库中插入多条数据 | | int delete(Uri uri, DataAbilityPredicates predicates) | 删除一条或多条数据 | | int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates) | 更新数据库 | | DataAbilityResult[] executeBatch(ArrayList operations) | 批量操作数据库 | 这些方法的使用说明如下： query() 查询方法，其中uri为目标资源路径，columns为想要查询的字段。开发者的查询条件可以通过DataAbilityPredicates来构建。查询用户表中id在101-103之间的用户，并把结果打印出来，代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(this); // 构造查询条件DataAbilityPredicates predicates = new DataAbilityPredicates();predicates.between(\"userId\", 101, 103); // 进行查询ResultSet resultSet = helper.query(uri, columns, predicates); // 处理结果resultSet.goToFirstRow();do { // 在此处理ResultSet中的记录;} while(resultSet.goToNextRow()); insert() 新增方法，其中uri为目标资源路径，ValuesBucket为要新增的对象。插入一条用户信息的代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(this); // 构造插入数据ValuesBucket valuesBucket = new ValuesBucket();valuesBucket.putString(\"name\", \"Tom\");valuesBucket.putInteger(\"age\", 12);helper.insert(uri, valuesBucket); batchInsert(） 批量插入方法，和insert()类似。批量插入用户信息的代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(this); // 构造插入数据ValuesBucket[] values = new ValuesBucket[2];values[0] = new ValuesBucket();values[0].putString(\"name\", \"Tom\");values[0].putInteger(\"age\", 12);values[1] = new ValuesBucket();values[1].putString(\"name\", \"Tom1\");values[1].putInteger(\"age\", 16);helper.batchInsert(uri, values); delete() 删除方法，其中删除条件可以通过DataAbilityPredicates来构建。删除用户表中id在101-103之间的用户，代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(this); // 构造删除条件DataAbilityPredicates predicates = new DataAbilityPredicates();predicates.between(\"userId\", 101, 103);helper.delete(uri, predicates); update() 更新方法，更新数据由ValuesBucket传入，更新条件由DataAbilityPredicates来构建。更新id为102的用户，代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(this); // 构造更新条件DataAbilityPredicates predicates = new DataAbilityPredicates();predicates.equalTo(\"userId\", 102); // 构造更新数据ValuesBucket valuesBucket = new ValuesBucket();valuesBucket.putString(\"name\", \"Tom\");valuesBucket.putInteger(\"age\", 12);helper.update(uri, valuesBucket, predicates); executeBatch() 此方法用来执行批量操作。DataAbilityOperation中提供了设置操作类型、数据和操作条件的方法，开发者可自行设置自己要执行的数据库操作。插入多条数据的代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(abilityObj, insertUri); // 构造批量操作ValuesBucket value1 = initSingleValue();DataAbilityOperation opt1 = DataAbilityOperation.newInsertBuilder(insertUri).withValuesBucket(value1).build();ValuesBucket value2 = initSingleValue2();DataAbilityOperation opt2 = DataAbilityOperation.newInsertBuilder(insertUri).withValuesBucket(value2).build();ArrayList operations = new ArrayList();operations.add(opt1);operations.add(opt2);DataAbilityResult[] result = helper.executeBatch(insertUri, operations); 相关实例 针对Data Ability开发，有以下示例工程可供参考： DataAbility 本示例演示了如何使用Data Ability对数据库进行增、删、改、查，以及读取文本文件。 针对Data Ability开发，有以下Codelabs可供参考： 关系型数据库 基于Data Ability的关系型数据库和数据管理能力，实现数据库相关应用服务的快速开发。 "},"intent.html":{"url":"intent.html","title":"Intent","keywords":"","body":"Intent 基本概念 Intent是对象之间传递信息的载体。例如，当一个Ability需要启动另一个Ability时，或者一个AbilitySlice需要导航到另一个AbilitySlice时，可以通过Intent指定启动的目标同时携带相关数据。Intent的构成元素包括Operation与Parameters，具体描述参见表1。 属性 子属性 描述 Operation Action 表示动作，通常使用系统预置Action，应用也可以自定义Action。例如IntentConstants.ACTION_HOME表示返回桌面动作。 Entity 表示类别，通常使用系统预置Entity，应用也可以自定义Entity。例如Intent.ENTITY_HOME表示在桌面显示图标。 Uri 表示Uri描述。如果在Intent中指定了Uri，则Intent将匹配指定的Uri信息，包括scheme, schemeSpecificPart, authority和path信息。 Flags 表示处理Intent的方式。例如Intent.FLAG_ABILITY_CONTINUATION标记在本地的一个Ability是否可以迁移到远端设备继续运行。 BundleName 表示包描述。如果在Intent中同时指定了BundleName和AbilityName，则Intent可以直接匹配到指定的Ability。 AbilityName 表示待启动的Ability名称。如果在Intent中同时指定了BundleName和AbilityName，则Intent可以直接匹配到指定的Ability。 DeviceId 表示运行指定Ability的设备ID。 Parameters - Parameters是一种支持自定义的数据结构，开发者可以通过Parameters传递某些请求所需的额外信息。 当Intent用于发起请求时，根据指定元素的不同，分为两种类型： 如果同时指定了BundleName与AbilityName，则根据Ability的全称（例如“com.demoapp.FooAbility”）来直接启动应用。 如果未同时指定BundleName和AbilityName，则根据Operation中的其他属性来启动应用。 说明 Intent设置属性时，必须先使用Operation来设置属性。如果需要新增或修改属性，必须在设置Operation后再执行操作。 关于Intent最简单的使用方法，可参见快速入门的示例代码。其中“实现页面跳转”重点描述了使用Intent实现两个页面跳转关系的操作。 根据Ability的全称启动应用 通过构造包含BundleName与AbilityName的Operation对象，可以启动一个Ability、并导航到该Ability。示例代码如下： Intent intent = new Intent(); // 通过Intent中的OperationBuilder类构造operation对象，指定设备标识（空串表示当前设备）、应用包名、Ability名称Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.demoapp\") .withAbilityName(\"com.demoapp.FooAbility\") .build(); // 把operation设置到intent中intent.setOperation(operation);startAbility(intent); 作为处理请求的对象，会在相应的回调方法中接收请求方传递的Intent对象。以导航到另一个Ability为例，导航的目标Ability可以在其onStart()回调的参数中获得Intent对象。 根据Operation的其他属性启动应用 有些场景下，开发者需要在应用中使用其他应用提供的某种能力，而不感知提供该能力的具体是哪一个应用。例如开发者需要通过浏览器打开一个链接，而不关心用户最终选择哪一个浏览器应用，则可以通过Operation的其他属性（除BundleName与AbilityName之外的属性）描述需要的能力。如果设备上存在多个应用提供同种能力，系统则弹出候选列表，由用户选择由哪个应用处理请求。以下示例展示使用Intent跨Ability查询天气信息。 请求方 在Ability中构造Intent以及包含Action的Operation对象，并调用startAbilityForResult()方法发起请求。然后重写onAbilityResult()回调方法，对请求结果进行处理。 private void queryWeather() { Intent intent = new Intent(); Operation operation = new Intent.OperationBuilder() .withAction(Intent.ACTION_QUERY_WEATHER) .build(); intent.setOperation(operation); startAbilityForResult(intent, REQ_CODE_QUERY_WEATHER);} @Overrideprotected void onAbilityResult(int requestCode, int resultCode, Intent resultData) { switch (requestCode) { case REQ_CODE_QUERY_WEATHER: // Do something with result. ... return; default: ... }} 处理方 作为处理请求的对象，首先需要在配置文件中声明对外提供的能力，以便系统据此找到自身并作为候选的请求处理者。 { \"module\": { ... \"abilities\": [ { ... \"skills\":[ { \"actions\":[ \"ability.intent.QUERY_WEATHER\" ] } ] ... } ] ... } ...} 在Ability中配置路由以便支持以此action导航到对应的AbilitySlice。 @Overrideprotected void onStart(Intent intent) { ... addActionRoute(Intent.ACTION_QUERY_WEATHER, DemoSlice.class.getName()); ...} 在Ability中处理请求，并调用setResult()方法暂存返回结果。 @Overrideprotected void onActive() { ... Intent resultIntent = new Intent(); setResult(0, resultIntent); //0为当前Ability销毁后返回的resultCode。 ...} 相关实例 针对Intent开发，有以下示例工程可供参考： Intent 本示例演示了如何根据Ability的全称启动应用和根据Operation的其他属性启动应用。 AbilityIntent 本示例通过Ability的全称和Operation的其他属性两种方式实现界面跳转以及数据传递。 "},"distributed-overview.html":{"url":"distributed-overview.html","title":"分布式任务调度开发概述","keywords":"","body":"分布式任务调度开发概述 在HarmonyOS中，分布式任务调度平台对搭载HarmonyOS的多设备构筑的“超级虚拟终端”提供统一的组件管理能力，为应用定义统一的能力基线、接口形式、数据结构、服务描述语言，屏蔽硬件差异；支持远程启动、远程调用、业务无缝迁移等分布式任务。 分布式任务调度平台在底层实现Ability（分布式任务调度的基本组件）跨设备的启动/关闭、连接及断开连接以及迁移等能力，实现跨设备的组件管理： 启动和关闭：向开发者提供管理远程Ability的能力，即支持启动Page模板的Ability，以及启动、关闭Service和Data模板的Ability。 连接和断开连接：向开发者提供跨设备控制服务（Service和Data模板的Ability）的能力，开发者可以通过与远程服务连接及断开连接实现获取或注销跨设备管理服务的对象，达到和本地一致的服务调度。 迁移能力：向开发者提供跨设备业务的无缝迁移能力，开发者可以通过调用Page模板Ability的迁移接口，将本地业务无缝迁移到指定设备中，打通设备间壁垒。 约束与限制 开发者需要在Intent中设置支持分布式的标记（例如：Intent.FLAG_ABILITYSLICE_MULTI_DEVICE表示该应用支持分布式调度），否则将无法获得分布式能力。 开发者通过在config.json中的reqPermissions字段里添加多设备协同访问的权限申请：三方应用使用{\"name\": \"ohos.permission.DISTRIBUTED_DATASYNC\"}。 PA（Particle Ability，Service和Data模板的Ability）的调用支持连接及断开连接、启动及关闭这四类行为，在进行调度时： 开发者必须在Intent中指定PA对应的bundleName和abilityName。 当开发者需要跨设备启动、关闭或连接PA时，需要在Intent中指定对端设备的deviceId。开发者可通过如设备管理类DeviceManager提供的getDeviceList获取指定条件下匿名化处理的设备列表，实现对指定设备PA的启动/关闭以及连接管理。 FA（Feature Ability，Page模板的Ability）的调用支持启动和迁移行为，在进行调度时： 当启动FA时，需要开发者在Intent中指定对端设备的deviceId、bundleName和abilityName。 FA的迁移实现相同bundleName和abilityName的FA跨设备迁移，因此需要指定迁移设备的deviceId。 DevEco Studio远程模拟设备的功能无法调测分布式任务调度，需要在真机环境下进行测试。 "},"distributed-guidelines.html":{"url":"distributed-guidelines.html","title":"分布式任务调度开发指导","keywords":"","body":"分布式任务调度开发指导 场景介绍 开发者在应用中集成分布式调度能力，通过调用指定能力的分布式接口，实现跨设备能力调度。根据Ability模板及意图的不同，分布式任务调度向开发者提供以下六种能力：启动远程FA、启动远程PA、关闭远程PA、连接远程PA、断开连接远程PA和FA跨设备迁移。下面以设备A（本地设备）和设备B（远端设备）为例，进行场景介绍： 设备A启动设备B的FA：在设备A上通过本地应用提供的启动按钮，启动设备B上对应的FA。例如：设备A控制设备B打开相册，只需开发者在启动FA时指定打开相册的意图即可。 设备A启动设备B的PA：在设备A上通过本地应用提供的启动按钮，启动设备B上指定的PA。例如：开发者在启动远程服务时通过意图指定音乐播放服务，即可实现设备A启动设备B音乐播放的能力。 设备A关闭设备B的PA：在设备A上通过本地应用提供的关闭按钮，关闭设备B上指定的PA。类似启动的过程，开发者在关闭远程服务时通过意图指定音乐播放服务，即可实现关闭设备B上该服务的能力。 设备A连接设备B的PA：在设备A上通过本地应用提供的连接按钮，连接设备B上指定的PA。连接后，通过其他功能相关按钮实现控制对端PA的能力。通过连接关系，开发者可以实现跨设备的同步服务调度，实现如大型计算任务互助等价值场景。 设备A与设备B的PA断开连接：在设备A上通过本地应用提供断开连接的按钮，将之前已连接的PA断开连接。 设备A的FA迁移至设备B：设备A上通过本地应用提供的迁移按钮，将设备A的业务无缝迁移到设备B中。通过业务迁移能力，打通设备A和设备B间的壁垒，实现如文档跨设备编辑、视频从客厅到房间跨设备接续播放等场景。 接口说明 分布式调度平台提供的连接和断开连接PA、启动远程FA、启动和关闭PA以及迁移FA的能力，是实现更多价值性场景的基础。 连接远程PA connectAbility(Intent intent, IAbilityConnection conn)接口提供连接指定设备上PA的能力，Intent中指定待连接PA的设备deviceId、bundleName和abilityName。当连接成功后，通过在conn定义的onAbilityConnectDone回调中获取对端PA的服务代理，两者的连接关系则由conn维护。具体的参数定义如下表所示： 参数名 类型 说明 intent ohos.aafwk.content.Intent 开发者需在intent对应的Operation中指定待连接PA的设备deviceId、bundleName和abilityName。 conn ohos.aafwk.ability.IAbilityConnection 当连接成功或失败时，作为连接关系的回调接口。该接口提供连接完成和断开连接完成时的处理逻辑，开发者可根据具体的场景进行定义。 启动远程FA/PA startAbility(Intent intent)接口提供启动指定设备上FA和PA的能力，Intent中指定待启动FA/PA的设备deviceId、bundleName和abilityName。具体参数定义如下表所示： 参数名 类型 说明 intent ohos.aafwk.content.Intent 当开发者需要调用该接口启动远程PA时，需要指定待启动PA的设备deviceId、bundleName和abilityName。若不指定设备deviceId，则无法跨设备调用PA。类似地，在启动FA时，也需要开发者指定启动FA的设备deviceId、bundleName和abilityName。 分布式调度平台还会提供与上述功能相对应的断开远程PA的连接和关闭远程PA的接口，相关的参数与连接、启动的接口类似。 断开远程PA连接：disconnectAbility(IAbilityConnection conn)。 关闭远程PA：stopAbility(Intent intent)。 迁移FA continueAbility(String deviceId)接口提供将本地FA迁移到指定设备上的能力，需要开发者在调用时指定目标设备的deviceId。具体参数定义如下表所示： 说明 Ability和AbilitySlice类均需要实现IAbilityContinuation及其方法，才可以实现FA迁移。 参数名 类型 说明 deviceId String 当开发者需要调用该接口将本地FA迁移时，需要指定目标设备的deviceId。 开发步骤 导入功能依赖的包。 // 以下依赖包含分布式调度平台开放的接口// 用于：连接/断开连接远程PA、启动远程FA、通过连接关系实现对PA的控制import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.ability.IAbilityConnection;import ohos.aafwk.content.Intent;import ohos.aafwk.content.Operation;import ohos.bundle.ElementName;// 为了实现迁移能力，需要引入传递迁移所需数据的包以及实现迁移能力的接口import ohos.aafwk.ability.IAbilityContinuation;import ohos.aafwk.content.IntentParams;// 为了实现跨设备指令及数据通信，需要使用RPC接口import ohos.rpc.IRemoteObject;import ohos.rpc.IRemoteBroker;import ohos.rpc.MessageParcel;import ohos.rpc.MessageOption;import ohos.rpc.RemoteException;import ohos.rpc.RemoteObject;//（可选）多设备场景下涉及设备选择，为此需要引入组网设备发现的能力import ohos.distributedschedule.interwork.DeviceInfo;import ohos.distributedschedule.interwork.DeviceManager;// (可选）设计界面相关的包函数，对FA界面及按钮进行绘制import ohos.agp.components.Button;import ohos.agp.components.Component;import ohos.agp.components.Component.ClickedListener;import ohos.agp.components.ComponentContainer.LayoutConfig;import ohos.agp.components.element.ShapeElement;import ohos.agp.components.PositionLayout; （可选）编写一个基本的FA用于使用分布式能力。 // 调用AbilitySlice模板实现一个用于控制基础功能的FA，AbilitySlice的代码示例如下：public class SampleSlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 开发者可以自行进行界面设计 // 为按钮设置统一的背景色 // 例如通过PositionLayout可以实现简单界面 PositionLayout layout = new PositionLayout(this); LayoutConfig config = new LayoutConfig(LayoutConfig.MATCH_PARENT, LayoutConfig.MATCH_PARENT); layout.setLayoutConfig(config); ShapeElement buttonBg = new ShapeElement(); buttonBg.setRgbColor(new RgbColor(0, 125, 255)); addComponents(layout, buttonBg, config); super.setUIContent(layout); } @Override public void onInactive() { super.onInactive(); } @Override public void onActive() { super.onActive(); } @Override public void onBackground() { super.onBackground(); } @Override public void onForeground(Intent intent) { super.onForeground(intent); } @Override public void onStop() { super.onStop(); }} 说明 此步骤展示了一个简单FA的实现过程，实际开发中请开发者根据需要进行设计。 使用分布式能力要求开发者在Ability对应的config.json中声明多设备协同访问的权限：三方应用使用{\"name\": \"ohos.permission.DISTRIBUTED_DATASYNC\"}。 一个三方应用部署的示例如下： { \"reqPermissions\": [ { \"name\": \"ohos.permission.DISTRIBUTED_DATASYNC\" } ]} 此外，对于三方应用还要求在实现Ability的代码中显式声明需要使用的权限，如下所示： public class SampleSlice extends AbilitySlice { @Override public void onStart(Intent intent) { // 开发者显示声明需要使用的权限 requestPermissionsFromUser(new String[]{\"ohos.permission.DISTRIBUTED_DATASYNC\"}, 0); super.onStart(intent); }} （可选）为不同的能力设置相应的控制按钮。 // 建议开发者按照自己的界面进行按钮设计 // 开发者可以自行实现如下createButton的方法，新建一个显示文字text，背景色为buttonBg以及大小尺寸位置符合config设置的按钮，用来与用户交互// private Button createButton(String text, ShapeElement buttonBg, LayoutConfig config)// 按照顺序在PositionLayout中依次添加按钮的示例private void addComponents(PositionLayout linear, ShapeElement buttonBg, LayoutConfig config) { // 构建远程启动FA的按钮 btnStartRemoteFA = createButton(\"StartRemoteFA\", buttonBg, config); btnStartRemoteFA.setClickedListener(mStartRemoteFAListener); linear.addComponent(btnStartRemoteFA); // 构建远程启动PA的按钮 btnStartRemotePA = createButton(\"StartRemotePA\", buttonBg, config); btnStartRemotePA.setClickedListener(mStartRemotePAListener); linear.addComponent(btnStartRemotePA); // 构建远程关闭PA的按钮 btnStopRemotePA = createButton(\"StopRemotePA\", buttonBg, config); btnStopRemotePA.setClickedListener(mStopRemotePAListener); linear.addComponent(btnStopRemotePA); // 构建连接远程PA的按钮 btnConnectRemotePA = createButton(\"ConnectRemotePA\", buttonBg, config); btnConnectRemotePA.setClickedListener(mConnectRemotePAListener); linear.addComponent(btnConnectRemotePA); // 构建控制连接PA的按钮 btnControlRemotePA = createButton(\"ControlRemotePA\", buttonBg, config); btnControlRemotePA.setClickedListener(mControlPAListener); linear.addComponent(btnControlRemotePA); // 构建与远程PA断开连接的按钮 btnDisconnectRemotePA = createButton(\"DisconnectRemotePA\", buttonBg, config); btnDisconnectRemotePA.setClickedListener(mDisconnectRemotePAListener); linear.addComponent(btnDisconnectRemotePA); // 构建迁移FA的按钮 btnContinueRemoteFA = createButton(\"ContinueRemoteFA\", buttonBg, config); btnContinueRemoteFA.setClickedListener(mContinueAbilityListener); linear.addComponent(btnContinueRemoteFA);} 说明 此处只展示了基于按钮控制的能力调度方法，实际开发中请开发者根据需要选择能力调度方式。代码示例中未体现按钮如位置、样式等具体的设置方法，详请参考JAVA UI框架。 通过设备管理DeviceManager提供的getDeviceList接口获取设备列表，用于指定目标设备。 // ISelectResult是一个自定义接口，用来处理指定设备deviceId后执行的行为 interface ISelectResult { void onSelectResult(String deviceId); } // 获得设备列表，开发者可在得到的在线设备列表中选择目标设备执行操作private void scheduleRemoteAbility(ISelectResult listener) { // 调用DeviceManager的getDeviceList接口，通过FLAG_GET_ONLINE_DEVICE标记获得在线设备列表 List onlineDevices = DeviceManager.getDeviceList(DeviceInfo.FLAG_GET_ONLINE_DEVICE); // 判断组网设备是否为空 if (onlineDevices.isEmpty()) { listener.onSelectResult(null); return; } int numDevices = onlineDevices.size(); List deviceIds = new ArrayList<>(numDevices); onlineDevices.forEach((device) -> { deviceIds.add(device.getDeviceId()); }); // 以选择首个设备作为目标设备为例 // 开发者也可按照具体场景，通过别的方式进行设备选择 String selectDeviceId = deviceIds.get(0); listener.onSelectResult(selectDeviceId); } 上述实例中涉及对在线组网设备的查询，该项能力需要开发者在对应的config.json中声明获取设备列表及设备信息的权限，如下所示： { \"reqPermissions\": [ { \"name\": \"ohos.permission.DISTRIBUTED_DEVICE_STATE_CHANGE\" }, { \"name\": \"ohos.permission.GET_DISTRIBUTED_DEVICE_INFO\" }, { \"name\": \"ohos.permission.GET_BUNDLE_INFO\" } ]} 为启动远程FA的按钮设置点击回调，实现启动远程FA的能力。 // 启动一个指定bundleName和abilityName的FAprivate ClickedListener mStartRemoteFAListener = new ClickedListener() { @Override public void onClick(Component arg0) { // 启动远程PA scheduleRemoteAbility(new ISelectResult() { @Override void onSelectResult(String deviceId) { if (deviceId != null) { // 通过scheduleRemoteAbility指定目标设备deviceId // 指定待启动FA的bundleName和abilityName // 例如：bundleName = \"com.helloworld\" // abilityName = \"com.helloworld.SampleFeatureAbility\" // 设置分布式标记，表明当前涉及分布式能力 Operation operation = new Intent.OperationBuilder() .withDeviceId(deviceId) .withBundleName(bundleName) .withAbilityName(abilityName) .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) .build(); Intent intent = new Intent(); intent.setOperation(operation); // 通过AbilitySlice包含的startAbility接口实现跨设备启动FA startAbility(intent); } } }); }}; 为启动和关闭PA定义回调，实现启动和关闭PA的能力。 对于PA的启动、关闭、连接等操作都需要开发者提供目标设备的deviceId。开发者可以通过DeviceManager相关接口得到当前组网下的设备列表，并以弹窗的形式供用户选择，也可以按照实际需要实现其他个性化的处理方式。在点击事件回调函数中，需要开发者指定得到deviceId后的处理逻辑，即实现类似上例中listener.onSelectResult(String deviceId)的方法，代码示例如下： // 启动远程PAprivate ClickedListener mStartRemotePAListener = new ClickedListener() { @Override public void onClick(Component arg0) { // 启动远程PA scheduleRemoteAbility(new ISelectResult() { @Override void onSelectResult(String deviceId) { if (deviceId != null) { // bundleName和abilityName与待启动PA对应 // 例如：bundleName = \"com.helloworld\" // abilityName = \"com.helloworld.SampleParticleAbility\" Operation operation = new Intent.OperationBuilder() .withDeviceId(deviceId) .withBundleName(bundleName) .withAbilityName(abilityName) .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) .build(); Intent intentToStartPA = new Intent(); intentToStartPA.setOperation(operation); startAbility(intentToStartPA); } } }); }}; // 关闭远程PA，和启动类似开发者需要指定待关闭PA对应的bundleName和abilityNameprivate ClickedListener mStopRemotePAListener = new ClickedListener() { @Override public void onClick(Component arg0) { scheduleRemoteAbility(new ISelectResult() { @Override void onSelectResult(String deviceId) { if (deviceId != null) { // bundleName和abilityName与待关闭PA对应 // 例如：bundleName = \"com.helloworld\" // abilityName = \"com.helloworld.SampleParticleAbility\" Operation operation = new Intent.OperationBuilder() .withDeviceId(deviceId) .withBundleName(bundleName) .withAbilityName(abilityName) .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) .build(); Intent intentToStopPA = new Intent(); intentToStopPA.setOperation(operation); stopAbility(intentToStopPA); } } }); }}; 说明 启动和关闭的行为类似，开发者只需在Intent中指定待调度PA的deviceId、bundleName和abilityName，并以operation的形式封装到Intent内。通过AbilitySlice（Ability）包含的startAbility()和stopAbility()接口即可实现相应功能。 设备A连接设备B侧的PA，利用连接关系调用该PA执行特定任务，以及断开连接。 // 当连接完成时，用来提供管理已连接PA的能力private MyRemoteProxy mProxy = null;// 用于管理连接关系private IAbilityConnection mConn = new IAbilityConnection() { @Override public void onAbilityConnectDone(ElementName element, IRemoteObject remote, int resultCode) { // 跨设备PA连接完成后，会返回一个序列化的IRemoteObject对象 // 通过该对象得到控制远端服务的代理 mProxy = new MyRemoteProxy(remote); btnConnectRemotePA.setText(\"connectRemoteAbility done\"); } @Override public void onAbilityDisconnectDone(ElementName element, int resultCode) { // 当已连接的远端PA关闭时，会触发该回调 // 支持开发者按照返回的错误信息进行PA生命周期管理 disconnectAbility(mConn); }}; 仅通过启动/关闭两种方式对PA进行调度无法应对需长期交互的场景，因此，分布式任务调度平台向开发者提供了跨设备PA连接及断开连接的能力。为了对已连接PA进行管理，开发者需要实现一个满足IAbilityConnection接口的连接状态检测实例，通过该实例可以对连接及断开连接完成时设置具体的处理逻辑，例如：获取控制对端PA的代理等。进一步为了使用该代理跨设备调度PA，开发者需要在本地及对端分别实现对外接口一致的代理。一个具备加法能力的代理示例如下： // 以连接提供加法计算能力的PA为例。为了提供跨设备连接能力，需要在本地发起连接侧和对端被连接侧分别实现代理// 发起连接侧的代理示例如下：public class MyRemoteProxy implements IRemoteBroker { private static final int ERR_OK = 0; private static final int COMMAND_PLUS = IRemoteObject.MIN_TRANSACTION_ID; private final IRemoteObject remote; public MyRemoteProxy(IRemoteObject remote) { this.remote = remote; } @Override public IRemoteObject asObject() { return remote; } public int plus(int a, int b) throws RemoteException { MessageParcel data = MessageParcel.obtain(); MessageParcel reply = MessageParcel.obtain(); // option不同的取值，决定采用同步或异步方式跨设备控制PA // 本例需要同步获取对端PA执行加法的结果，因此采用同步的方式，即MessageOption.TF_SYNC // 具体MessageOption的设置，可参考相关API文档 MessageOption option = new MessageOption(MessageOption.TF_SYNC); data.writeInt(a); data.writeInt(b); try { remote.sendRequest(COMMAND_PLUS, data, reply, option); int errCode = reply.readInt(); if (errCode != ERR_OK) { throw new RemoteException(); } int result = reply.readInt(); return result; }finally { data.reclaim(); reply.reclaim(); } }} 此外，对端待连接的PA需要实现对应的客户端，代码示例如下所示： // 以计算加法为例，对端实现的客户端如下public class MyRemote extends RemoteObject implements IRemoteBroker{ private static final int ERR_OK = 0; private static final int ERROR = -1; private static final int COMMAND_PLUS = IRemoteObject.MIN_TRANSACTION_ID; public MyRemote() { super(\"MyService_Remote\"); } @Override public IRemoteObject asObject() { return this; } @Override public boolean onRemoteRequest(int code, MessageParcel data, MessageParcel reply, MessageOption option) { if (code != COMMAND_PLUS) { reply.writeInt(ERROR); return false; } int value1 = data.readInt(); int value2 = data.readInt(); int sum = value1 + value2; reply.writeInt(ERR_OK); reply.writeInt(sum); return true; }} 对端除了要实现如上所述的客户端外，待连接的PA还需要作如下修改： // 为了返回给连接方可调用的代理，需要在该PA中实例化客户端，例如作为该PA的成员变量private MyRemote remote = new MyRemote();// 当该PA接收到连接请求时，即将该客户端转化为代理返回给连接发起侧@Overrideprotected IRemoteObject onConnect(Intent intent) { super.onConnect(intent); return remote.asObject();} 完成上述步骤后，可以通过点击事件实现连接、利用连接关系控制PA以及断开连接等行为，代码示例如下： // 连接远程PAprivate ClickedListener mConnectRemotePAListener = new ClickedListener() { @Override public void onClick(Component arg0) { scheduleRemoteAbility(new ISelectResult() { @Override void onSelectResult(String deviceId) { if (deviceId != null) { Intent connectPAIntent = new Intent(); // bundleName和abilityName与待连接的PA一一对应 // 例如：bundleName = \"com.helloworld\" // abilityName = \"com.helloworld.SampleParticleAbility\" Operation operation = new Intent.OperationBuilder() .withDeviceId(deviceId) .withBundleName(bundleName) .withAbilityName(abilityName) .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) .build(); connectPAIntent.setOperation(operation); connectAbility(connectPAIntent, mConn); } } }); }};// 控制已连接PA执行加法private ClickedListener mControlPAListener = new ClickedListener() { @Override public void onClick(Component arg0) { if (mProxy != null) { int ret = -1; try { ret = mProxy.plus(10, 20); } catch (RemoteException e) { HiLog.error(LABEL, \"ControlRemotePA error\"); } btnControlRemotePA.setText(\"ControlRemotePA result = \" + ret); } }};// 与远程PA断开连接private ClickedListener mDisconnectRemotePAListener = new ClickedListener() { @Override public void onClick(Component arg0) { // 按钮复位 btnConnectRemotePA.setText(\"ConnectRemotePA\"); btnControlRemotePA.setText(\"ControlRemotePA\"); disconnectAbility(mConn); }}; 说明 通过连接/断开连接远程PA，与跨设备PA建立长期的管理关系。例如在本例中，通过连接关系得到远程PA的控制代理后，实现跨设备计算加法并将结果返回到本地显示。在实际开发中，开发者可以根据需要实现多种分布式场景，例如：跨设备位置/电量等信息的采集、跨设备计算资源互助等。 设备A将运行时的FA迁移到设备B，实现业务在设备间无缝迁移。 // 跨设备迁移FA// 本地FA设置当前运行任务private ClickedListener mContinueAbilityListener = new ClickedListener() { @Override public void onClick(Component arg0) { // 用户选择设备后实现业务迁移 scheduleRemoteAbility(new ISelectResult() { @Override public void onSelectResult(String deviceId) { continueAbility(deviceId); } }); }}; FA的迁移还涉及到状态数据的传递，需要继承IAbilityContinuation接口，供开发者实现迁移过程中特定事件的管理能力，代码示例如下： public class SampleSlice extends AbilitySlice implements IAbilityContinuation { @Override public boolean onSaveData(IntentParams saveData) { String exampleData = String.valueOf(System.currentTimeMillis()); saveData.setParam(\"continueParam\", exampleData); return true; } @Override public boolean onRestoreData(IntentParams restoreData) { // 远端FA迁移传来的状态数据，开发者可以按照特定的场景对这些数据进行处理 Object data = restoreData.getParam(\"continueParam\"); return true; } @Override public void onCompleteContinuation(int result) { btnContinueRemoteFA.setText(\"ContinueAbility Done\"); }} 通过自定义迁移事件相关的行为，最终实现对Ability的迁移。具体的定义可以参考相关的API文档，此处主要以较为常用的两个事件，包括迁移发起端完成迁移的回调onCompleteContinuation(int result)以及接收到远端迁移行为传递数据的回调onRestoreData(IntentParams restoreData)。其他还包括迁移到远端设备的FA关闭的回调onRemoteTerminated()、用于本地迁移发起时保存状态数据的回调onSaveData(IntentParams saveData)和本地发起迁移的回调onStartContinuation()。按照实际应用自定义特定场景对应的回调，可以完成多种场景下FA的迁移任务。 说明 FA迁移可以打通设备间的壁垒，有助于不同能力的设备进行互助。前文以一个简单的例子介绍如何通过分布式任务调度提供的能力，实现FA跨设备的迁移（包括FA启动及状态数据的同步）。 FA迁移过程中，远端FA首先接收到发起端FA传输的数据，再执行启动，即onRestoreData()发生在onStart()之前，详见API参考。 相关实例 针对分布式任务调度，有以下示例工程可供参考： DistributedScheduler 本示例演示了分布式任务调度的六种场景：启动远程FA，启动远程PA，关闭远程PA，连接远程PA，断开连接远程PA， 和FA跨端迁移。 针对分布式任务调度，有以下Codelabs可供参考： 分布式调度启动远程FA 基于分布式调度的能力，实现远程FA的启动。 分布式亲子早教系统 基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。 分布式输入法 基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放。 分布式地图导航 基于分布式能力，实现地图导航信息在手机-车机-智能穿戴设备之间流转。 "},"notification-fwk-overview.html":{"url":"notification-fwk-overview.html","title":"公共事件与通知概述","keywords":"","body":"公共事件与通知概述 HarmonyOS通过CES（Common Event Service，公共事件服务）为应用程序提供订阅、发布、退订公共事件的能力，通过ANS（Advanced Notification Service，即通知增强服务）系统服务来为应用程序提供发布通知的能力。 公共事件可分为系统公共事件和自定义公共事件。 系统公共事件：系统将收集到的事件信息，根据系统策略发送给订阅该事件的用户程序。 例如：用户可感知亮灭屏事件，系统关键服务发布的系统事件（例如：USB插拔，网络连接，系统升级等）。 自定义公共事件：应用自定义一些公共事件用来处理业务逻辑。 通知提供应用的即时消息或通信消息，用户可以直接删除或点击通知触发进一步的操作。 IntentAgent封装了一个指定行为的Intent，可以通过IntentAgent启动Ability和发布公共事件。 应用如果需要接收公共事件，需要订阅相应的事件。 约束与限制 公共事件的约束与限制 目前公共事件仅支持动态订阅。部分系统事件需要具有指定的权限，具体的权限见API参考。 目前公共事件订阅不支持多用户。 ThreadMode表示线程模型，目前仅支持HANDLER模式，即在当前UI线程上执行回调函数。 deviceId用来指定订阅本地公共事件还是远端公共事件。deviceId为null、空字符串或本地设备deviceId时，表示订阅本地公共事件，否则表示订阅远端公共事件。 通知的约束与限制 通知目前支持六种样式：普通文本、长文本、图片、社交、多行文本和媒体样式。创建通知时必须包含一种样式。 通知支持快捷回复。 IntentAgent的限制 使用IntentAgent启动Ability时，Intent必须指定Ability的包名和类名。 "},"notification-fwk-common-event.html":{"url":"notification-fwk-common-event.html","title":"公共事件开发指导","keywords":"","body":"公共事件开发指导 场景介绍 每个应用都可以订阅自己感兴趣的公共事件，订阅成功后且公共事件发布后，系统会把其发送给应用。这些公共事件可能来自系统、其他应用和应用自身。HarmonyOS提供了一套完整的API，支持用户订阅、发布和接收公共事件。发布公共事件需要借助CommonEventData对象，接收公共事件需要继承CommonEventSubscriber类并实现onReceiveEvent回调函数。 接口说明 公共事件相关基础类包含CommonEventData、CommonEventPublishInfo、CommonEventSubscribeInfo、CommonEventSubscriber和CommonEventManager。基础类之间的关系如下图所示： 图1 公共事件基础类关系图 CommonEventData CommonEventData封装公共事件相关信息。用于在发布、分发和接收时处理数据。在构造CommonEventData对象时，相关参数需要注意以下事项： code为有序公共事件的结果码，data为有序公共事件的结果数据，仅用于有序公共事件场景。 intent不允许为空，否则发布公共事件失败。 | 接口名 | 描述 | | ----------------------------------------------------- | ------------------------------------------ | | CommonEventData() | 创建公共事件数据。 | | CommonEventData(Intent intent) | 创建公共事件数据指定Intent。 | | CommonEventData(Intent intent, int code, String data) | 创建公共事件数据，指定Intent、code和data。 | | getIntent() | 获取公共事件Intent。 | | setCode(int code) | 设置有序公共事件的结果码。 | | getCode() | 获取有序公共事件的结果码。 | | setData(String data) | 设置有序公共事件的详细结果数据。 | | getData() | 获取有序公共事件的详细结果数据。 | CommonEventPublishInfo CommonEventPublishInfo封装公共事件发布相关属性、限制等信息，包括公共事件类型（有序或粘性）、接收者权限等。 有序公共事件：主要场景是多个订阅者有依赖关系或者对处理顺序有要求，例如：高优先级订阅者可修改公共事件内容或处理结果，包括终止公共事件处理；或者低优先级订阅者依赖高优先级的处理结果等。 有序公共事件的订阅者可以通过[CommonEventSubscribeInfo](https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li1490625910238).setPriority()方法指定优先级，缺省为0，优先级范围[-1000, 1000]，值越大优先级越高。 粘性公共事件：指公共事件的订阅动作是在公共事件发布之后进行，订阅者也能收到的公共事件类型。主要场景是由公共事件服务记录某些系统状态，如蓝牙、WLAN、充电等事件和状态。不使用粘性公共事件机制时，应用可以通过直接访问系统服务获取该状态；在状态变化时，系统服务、硬件需要提供类似observer等方式通知应用。 发布粘性公共事件可以通过setSticky()方法设置， 发布粘性公共事件需要申请如下权限。声明请参考权限开发指导表1 reqPermissions权限申请字段说明。 \"reqPermissions\": [ { \"name\": \"ohos.permission.COMMONEVENT_STICKY\", \"reason\": \"Obtain the required permission\", \"usedScene\": { \"ability\": [ \".MainAbility\" ], \"when\": \"inuse\" } }, { ... }] | 接口名 | 描述 | | ---------------------------------------------------------- | ---------------------------------------------- | | CommonEventPublishInfo() | 创建公共事件信息。 | | CommonEventPublishInfo(CommonEventPublishInfo publishInfo) | 拷贝一个公共事件信息。 | | setSticky(boolean sticky） | 设置公共事件的粘性属性。 | | setOrdered(boolean ordered) | 设置公共事件的有序属性。 | | setSubscriberPermissions(String[] subscriberPermissions) | 设置公共事件订阅者的权限，多参数仅第一个生效。 | CommonEventSubscribeInfo CommonEventSubscribeInfo封装公共事件订阅相关信息，比如优先级、线程模式、事件范围等。 线程模式（ThreadMode）：设置订阅者的回调方法执行的线程模式。ThreadMode有HANDLER，POST，ASYNC，BACKGROUND四种模式，目前只支持HANDLER模式。 HANDLER：在Ability的主线程上执行。 POST：在事件分发线程执行。 ASYNC：在一个新创建的异步线程执行。 BACKGROUND：在后台线程执行。 | 接口名 | 描述 | | ------------------------------------------------------- | -------------------------------------- | | CommonEventSubscribeInfo(MatchingSkills matchingSkills) | 创建公共事件订阅器指定matchingSkills。 | | CommonEventSubscribeInfo(CommonEventSubscribeInfo) | 拷贝公共事件订阅器对象。 | | setPriority(int priority) | 设置优先级，用于有序公共事件。 | | setThreadMode(ThreadMode threadMode) | 指定订阅者的回调函数运行在哪个线程上。 | | setPermission(String permission) | 设置发布者必须具备的权限。 | | setDeviceId(String deviceId) | 指定订阅哪台设备的公共事件。 | CommonEventSubscriber CommonEventSubscriber封装公共事件订阅者及相关参数。 CommonEventSubscriber.AsyncCommonEventResult类处理有序公共事件异步执行，详见API参考。 目前只能通过调用CommonEventManager的subscribeCommonEvent()进行订阅。 | 接口名 | 描述 | | ------------------------------------------------------------ | ------------------------------------------------------------ | | CommonEventSubscriber(CommonEventSubscribeInfo subscribeInfo) | 构造公共事件订阅者实例。 | | onReceiveEvent(CommonEventData data) | 由开发者实现, 在接收到公共事件时被调用。 | | AsyncCommonEventResult goAsyncCommonEvent() | 设置有序公共事件异步执行。 | | setCodeAndData(int code, String data) | 设置有序公共事件的异步结果。 | | setData(String data) | 设置有序公共事件的异步结果数据。 | | setCode(int code) | 设置有序公共事件的异步结果码。 | | getData() | 获取有序公共事件的异步结果数据。 | | getCode() | 获取有序公共事件的异步结果码。 | | abortCommonEvent() | 取消当前的公共事件，仅对有序公共事件有效，取消后，公共事件不再向下一个订阅者传递。 | | getAbortCommonEvent() | 获取当前有序公共事件是否取消的状态。 | | clearAbortCommonEvent() | 清除当前有序公共事件abort状态。 | | isOrderedCommonEvent() | 查询当前公共事件的是否为有序公共事件。 | | isStickyCommonEvent() | 查询当前公共事件是否为粘性公共事件。 | CommonEventManager CommonEventManager是为应用提供订阅、退订和发布公共事件的静态接口类。 方法 描述 publishCommonEvent(CommonEventData eventData) 发布公共事件。 publishCommonEvent(CommonEventData event, CommonEventPublishInfo publishInfo) 发布公共事件指定发布信息。 publishCommonEvent(CommonEventData event, CommonEventPublishInfo publishInfo, CommonEventSubscriber resultSubscriber) 发布有序公共事件，指定发布信息和最后一个接收者。 subscribeCommonEvent(CommonEventSubscriber subscriber) 订阅公共事件。 unsubscribeCommonEvent(CommonEventSubscriber subscriber) 退订公共事件。 发布公共事件 开发者可以发布四种公共事件：无序的公共事件、带权限的公共事件、有序的公共事件、粘性的公共事件。 发布无序的公共事件：构造CommonEventData对象，设置Intent，通过构造operation对象把需要发布的公共事件信息传入intent对象。然后调用 CommonEventManager.publishCommonEvent(CommonEventData) 接口发布公共事件。 try { Intent intent = new Intent(); Operation operation = new Intent.OperationBuilder() .withAction(\"com.my.test\") .build(); intent.setOperation(operation); CommonEventData eventData = new CommonEventData(intent); CommonEventManager.publishCommonEvent(eventData); HiLog.info(LABEL_LOG, \"Publish succeeded\"); } catch (RemoteException e) { HiLog.error(LABEL_LOG, \"Exception occurred during publishCommonEvent invocation.\"); } 发布携带权限的公共事件：构造CommonEventPublishInfo对象，设置订阅者的权限。 订阅者在config.json中申请所需的权限，各字段含义详见 权限申请字段说明 。 说明 非系统已定义的权限，需要先在config.json中自定义，才可以申请使用。详见权限定义字段说明 \"reqPermissions\": [ { \"name\": \"com.example.MyApplication.permission\", \"reason\": \"Obtain the required permission\", \"usedScene\": { \"ability\": [ \".MainAbility\" ], \"when\": \"inuse\" } }, { ... }] 发布带权限的公共事件示例代码如下： Intent intent = new Intent();Operation operation = new Intent.OperationBuilder() .withAction(\"com.my.test\") .build();intent.setOperation(operation);CommonEventData eventData = new CommonEventData(intent);CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();String[] permissions = {\"com.example.MyApplication.permission\"};publishInfo.setSubscriberPermissions(permissions); // 设置权限try { CommonEventManager.publishCommonEvent(eventData, publishInfo); HiLog.info(LABEL_LOG, \"Publish succeeded\"); } catch (RemoteException e) { HiLog.error(LABEL_LOG, \"Exception occurred during publishCommonEvent invocation.\"); } 发布有序的公共事件：构造CommonEventPublishInfo对象，通过setOrdered(true)指定公共事件属性为有序公共事件，也可以指定一个最后的公共事件接收者。 CommonEventSubscriber resultSubscriber = new MyCommonEventSubscriber();CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();publishInfo.setOrdered(true); // 设置属性为有序公共事件try { CommonEventManager.publishCommonEvent(eventData, publishInfo, resultSubscriber); // 指定resultSubscriber为有序公共事件最后一个接收者。} catch (RemoteException e) { HiLog.error(LABEL_LOG, \"Exception occurred during publishCommonEvent invocation.\"); } 发布粘性公共事件：构造CommonEventPublishInfo对象，通过setSticky(true)指定公共事件属性为粘性公共事件。 发布者首先在config.json中申请发布粘性公共事件所需的权限，各字段含义详见权限申请字段说明。 { \"reqPermissions\": [{ \"name\": \"ohos.permission.COMMONEVENT_STICKY\", \"reason\": \"Obtain the required permission\", \"usedScene\": { \"ability\": [ \".MainAbility\" ], \"when\": \"inuse\" } }, { ... }]} 发布粘性公共事件。 CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();publishInfo.setSticky(true); // 设置属性为粘性公共事件try { CommonEventManager.publishCommonEvent(eventData, publishInfo); } catch (RemoteException e) { HiLog.error(LABEL, \"Exception occurred during publishCommonEvent invocation.\"); } 订阅公共事件 创建CommonEventSubscriber派生类，在onReceiveEvent()回调函数中处理公共事件。 说明 此处不能执行耗时操作，否则会阻塞UI线程，产生用户点击没有反应等异常。 class MyCommonEventSubscriber extends CommonEventSubscriber { MyCommonEventSubscriber(CommonEventSubscribeInfo info) { super(info); } @Override public void onReceiveEvent(CommonEventData commonEventData) { } } 构造MyCommonEventSubscriber对象，调用CommonEventManager.subscribeCommonEvent()接口进行订阅。 String event = \"com.my.test\";MatchingSkills matchingSkills = new MatchingSkills();matchingSkills.addEvent(event); // 自定义事件matchingSkills.addEvent(CommonEventSupport.COMMON_EVENT_SCREEN_ON); // 亮屏事件CommonEventSubscribeInfo subscribeInfo = new CommonEventSubscribeInfo(matchingSkills);MyCommonEventSubscriber subscriber = new MyCommonEventSubscriber(subscribeInfo);try { CommonEventManager.subscribeCommonEvent(subscriber); } catch (RemoteException e) { HiLog.error(LABEL, \"Exception occurred during subscribeCommonEvent invocation.\"); } 如果订阅拥有指定权限应用发布的公共事件，发布者需要在config.json中申请权限，各字段含义详见权限申请字段说明。 \"reqPermissions\": [ { \"name\": \"ohos.abilitydemo.permission.PROVIDER\", \"reason\": \"Obtain the required permission\", \"usedScene\": { \"ability\": [\"com.hmi.ivi.systemsetting.MainAbility\"], \"when\": \"inuse\" } }] 如果订阅的公共事件是有序的，可以调用setPriority(）指定优先级。 String event = \"com.my.test\";MatchingSkills matchingSkills = new MatchingSkills();matchingSkills.addEvent(event); // 自定义事件 CommonEventSubscribeInfo subscribeInfo = new CommonEventSubscribeInfo(matchingSkills);subscribeInfo.setPriority(100); // 设置优先级，优先级取值范围[-1000，1000]，值默认为0。MyCommonEventSubscriber subscriber = new MyCommonEventSubscriber(subscribeInfo);try { CommonEventManager.subscribeCommonEvent(subscriber); } catch (RemoteException e) { HiLog.error(LABEL, \"Exception occurred during subscribeCommonEvent invocation.\"); } 针对在onReceiveEvent中不能执行耗时操作的限制，可以使用CommonEventSubscriber的goAsyncCommonEvent()来实现异步操作，函数返回后仍保持该公共事件活跃，且执行完成后必须调用AsyncCommonEventResult .finishCommonEvent()来结束。 EventRunner runner = EventRunner.create(); // EventRunner创建新线程，将耗时的操作放到新的线程上执行MyEventHandler myHandler = new MyEventHandler(runner); // MyEventHandler为EventHandler的派生类，在不同线程间分发和处理事件和Runnable任务@Overridepublic void onReceiveEvent(CommonEventData commonEventData){ final AsyncCommonEventResult result = goAsyncCommonEvent(); Runnable task = new Runnable() { @Override public void run() { ........ // 待执行的操作，由开发者定义 result.finishCommonEvent(); // 调用finish结束异步操作 } }; myHandler.postTask(task);} 退订公共事件 在Ability的onStop()中调用CommonEventManager.unsubscribeCommonEvent()方法来退订公共事件。调用后，之前订阅的所有公共事件均被退订。 try { CommonEventManager.unsubscribeCommonEvent(subscriber); } catch (RemoteException e) { HiLog.error(LABEL, \"Exception occurred during unsubscribeCommonEvent invocation.\"); } 相关实例 针对公共事件开发，有以下示例工程可供参考： CommonEvent 本示例演示了公共事件的订阅、发布和退订。 针对公共事件，有以下Codelabs可供参考： 分布式亲子早教系统 基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。 分布式输入法 基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放。 "},"notification-fwk-notification.html":{"url":"notification-fwk-notification.html","title":"通知开发指导","keywords":"","body":"通知开发指导 场景介绍 HarmonyOS提供了通知功能，即在一个应用的UI界面之外显示的消息，主要用来提醒用户有来自该应用中的信息。当应用向系统发出通知时，它将先以图标的形式显示在通知栏中，用户可以下拉通知栏查看通知的详细信息。常见的使用场景： 显示接收到短消息、即时消息等。 显示应用的推送消息，如广告、版本更新等。 显示当前正在进行的事件，如播放音乐、导航、下载等。 接口说明 通知相关基础类包含NotificationSlot、NotificationRequest和NotificationHelper。基础类之间的关系如下所示： 图1 通知基础类关系图 NotificationSlot NotificationSlot可以对提示音、振动、锁屏显示和重要级别等进行设置。一个应用可以创建一个或多个NotificationSlot，在发布通知时，通过绑定不同的NotificationSlot，实现不同用途。 说明 NotificationSlot需要先通过NotificationHelper的addNotificationSlot(NotificationSlot)方法发布后，通知才能绑定使用；所有绑定该NotificationSlot的通知在发布后都具备相应的特性，对象在创建后，将无法更改这些设置，对于是否启动相应设置，用户有最终控制权。 不指定NotificationSlot时，当前通知会使用默认的NotificationSlot，默认的NotificationSlot优先级为LEVEL_DEFAULT。 接口名 描述 NotificationSlot(String id, String name, int level) 构造NotificationSlot。 setLevel(int level) 设置NotificationSlot的级别。 setName(String name) 设置NotificationSlot的命名。 setDescription(String description) 设置NotificationSlot的描述信息。 enableBypassDnd(boolean bypassDnd) 设置是否绕过系统的免打扰模式。 setEnableVibration(boolean vibration) 设置收到通知时是否使能振动。 setLockscreenVisibleness(int visibleness) 设置在锁屏场景下，收到通知后是否显示，以及显示的效果。 setEnableLight(boolean isLightEnabled) 设置收到通知时是否开启呼吸灯，前提是当前硬件支持呼吸灯。 setLedLightColor(int color) 设置收到通知时的呼吸灯颜色。 setSlotGroup(String groupId) 绑定当前NotificationSlot到一个NotificationSlot组。 NotificationSlot的级别目前支持如下几种， 由低到高： LEVEL_NONE： 表示通知不发布。 LEVEL_MIN：表示通知可以发布，但是不显示在通知栏，不自动弹出，无提示音；该级别不适用于前台服务的场景。 LEVEL_LOW：表示通知可以发布且显示在通知栏，不自动弹出，无提示音。 LEVEL_DEFAULT：表示通知发布后可在通知栏显示，不自动弹出，触发提示音。 LEVEL_HIGH：表示通知发布后可在通知栏显示，自动弹出，触发提示音。 NotificationRequest NotificationRequest用于设置具体的通知对象，包括设置通知的属性，如：通知的分发时间、小图标、大图标、自动删除等参数，以及设置具体的通知类型，如普通文本、长文本等。 接口名 描述 NotificationRequest() 构建一个通知。 NotificationRequest(int notificationId) 构建一个通知，指定通知的id。通知的Id在应用内容具有唯一性，如果不指定，默认为0。 setNotificationId(int notificationId) 设置当前通知id。 setAutoDeletedTime(long time) 设置通知自动取消的时间戳。 setContent(NotificationRequest.NotificationContent content) 设置通知的具体类型。 setDeliveryTime(long deliveryTime) 设置通知分发的时间戳。 setSlotId(String slotId) 设置通知的NotificationSlot id。 setTapDismissed(boolean tapDismissed) 设置通知在用户点击后是否自动取消。 setLittleIcon(PixelMap smallIcon) 设置通知的小图标，在通知左上角显示。 setBigIcon(PixelMap bigIcon) 设置通知的大图标，在通知的右边显示。 setGroupValue(String groupValue) 设置分组通知，相同分组的通知在通知栏显示时，将会折叠在一组应用中显示。 addActionButton(NotificationActionButton actionButton) 设置通知添加通知ActionButton。 setIntentAgent(IntentAgent agent) 设置通知承载指定的IntentAgent，在通知中实现即将触发的事件。 具体的通知类型：目前支持六种类型，包括普通文本NotificationNormalContent、长文本NotificationLongTextContent、图片NotificationPictureContent、多行NotificationMultiLineContent、社交NotificationConversationalContent、媒体NotificationMediaContent。 类名 接口名 描述 NotificationNormalContent setTitle(String title) 设置通知标题。 NotificationNormalContent setText(String text) 设置通知内容。 NotificationNormalContent setAdditionalText(String additionalText) 设置通知次要内容，是对通知内容的补充。 NotificationPictureContent setBriefText(String briefText) 设置通知概要内容，是对通知内容的总结。 NotificationPictureContent setExpandedTitle(String expandedTitle) 设置附加图片的通知展开时的标题。 NotificationPictureContent setBigPicture(PixelMap bigPicture) 设置通知的图片内容，附加在setText(String text)下方。 NotificationLongTextContent setLongText(String longText) 设置通知的长文本。 NotificationConversationalContent setConversationTitle(String conversationTitle) 设置社交通知的标题。 NotificationConversationalContent addConversationalMessage(ConversationalMessage message) 通知添加一条消息。 NotificationMultiLineContent addSingleLine(String line) 在当前通知中添加一行文本。 NotificationMediaContent setAVToken(AVToken avToken) 将媒体通知绑定指定的AVToken。 NotificationMediaContent setShownActions(int[] actions) 设置媒体通知待展示的按钮。 说明 通知发布后，通知的设置不可修改。如果下次发布通知使用相同的id，就会更新之前发布的通知。 NotificationHelper NotificationHelper封装了发布、更新、删除通知等静态方法。 接口名 描述 publishNotification(NotificationRequest request) 发布一条通知。 publishNotification(String tag, NotificationRequest request) 发布一条带TAG的通知。 cancelNotification(int notificationId) 取消指定的通知。 cancelNotification(String tag, int notificationId) 取消指定的带TAG的通知。 cancelAllNotifications() 取消之前发布的所有通知。 addNotificationSlot(NotificationSlot slot) 创建一个NotificationSlot。 getNotificationSlot(String slotId) 获取NotificationSlot。 removeNotificationSlot(String slotId) 删除一个NotificationSlot。 getActiveNotifications() 获取当前应用发的活跃通知。 getActiveNotificationNums() 获取系统中当前应用发的活跃通知的数量。 setNotificationBadgeNum(int num) 设置通知的角标。 setNotificationBadgeNum() 设置当前应用中活跃状态通知的数量在角标显示。 开发步骤 通知的开发指导分为创建NotificationSlot、发布通知和取消通知等开发场景。 创建NotificationSlot NotificationSlot可以设置公共通知的震动，锁屏模式，重要级别等，并通过调用NotificationHelper.addNotificationSlot()发布NotificationSlot对象。 NotificationSlot slot = new NotificationSlot(\"slot_001\", \"slot_default\", NotificationSlot.LEVEL_MIN); // 创建notificationSlot对象slot.setDescription(\"NotificationSlotDescription\");slot.setEnableVibration(true); // 设置振动提醒slot.setLockscreenVisibleness(NotificationRequest.VISIBLENESS_TYPE_PUBLIC);// 设置锁屏模式slot.setEnableLight(true); // 设置开启呼吸灯提醒slot.setLedLightColor(Color.RED.getValue());// 设置呼吸灯的提醒颜色try { NotificationHelper.addNotificationSlot(slot);} catch (RemoteException ex) { HiLog.error(LABEL, \"Exception occurred during addNotificationSlot invocation.\");} 发布通知 构建NotificationRequest对象，应用发布通知前，通过NotificationRequest的setSlotId()方法与NotificationSlot绑定，使该通知在发布后都具备该对象的特征。 int notificationId = 1;NotificationRequest request = new NotificationRequest(notificationId);request.setSlotId(slot.getId()); 调用setContent()设置通知的内容。 String title = \"title\";String text = \"There is a normal notification content.\";NotificationNormalContent content = new NotificationNormalContent();content.setTitle(title) .setText(text);NotificationRequest.NotificationContent notificationContent = new NotificationRequest.NotificationContent(content);request.setContent(notificationContent); // 设置通知的内容 调用publishNotification()发布通知。 try { NotificationHelper.publishNotification(request);} catch (RemoteException ex) { HiLog.error(LABEL, \"Exception occurred during publishNotification invocation.\");} 取消通知 取消通知分为取消指定单条通知和取消所有通知，应用只能取消自己发布的通知。 调用cancelNotification()取消指定的单条通知。 int notificationId = 1;try { NotificationHelper.cancelNotification(notificationId);} catch (RemoteException ex) { HiLog.error(LABEL, \"Exception occurred during cancelNotification invocation.\");} 调用cancelAllNotifications()取消所有通知。 try { NotificationHelper.cancelAllNotifications();} catch (RemoteException ex) { HiLog.error(LABEL, \"Exception occurred during cancelAllNotifications invocation.\");} 相关实例 针对通知开发，有以下示例工程可供参考： Notification 通知功能，即在一个应用的UI界面之外显示的消息，主要用来提醒用户有来自该应用中的信息。本示例演示了如何发布通知和取消通知。 "},"notification-fwk-intentagent.html":{"url":"notification-fwk-intentagent.html","title":"IntentAgent开发指导","keywords":"","body":"IntentAgent开发指导 场景介绍 IntentAgent封装了一个指定行为的Intent，可以通过triggerIntentAgent接口主动触发，也可以与通知绑定被动触发。具体的行为包括：启动Ability和发布公共事件。例如：收到通知后，在点击通知后跳转到一个新的Ability，不点击则不会触发。 接口说明 IntentAgent相关基础类包括IntentAgentHelper、IntentAgentInfo、IntentAgentConstant和TriggerInfo，基础类之间的关系如下图所示： 图1 IntentAgent基础类关系图 IntentAgentHelper IntentAgentHelper封装了获取、激发、取消IntentAgent等静态方法。 接口名 描述 getIntentAgent(Context context, IntentAgentInfo paramsInfo) 获取一个IntentAgent实例。 triggerIntentAgent(Context context, IntentAgent agent, IntentAgent.Oncompleted onCompleted, EventHandler handler, TriggerInfo paramsInfo) 主动激发一个IntentAgent实例。 cancel(IntentAgent agent) 取消一个IntentAgent实例。 judgeEquality(IntentAgent agent, IntentAgent otherAgent) 判断两个IntentAgent实例是否相等。 getHashCode(IntentAgent agent) 获取一个IntentAgent实例的哈希码。 getBundleName(IntentAgent agent) 获取一个IntentAgent实例的包名。 getUid(IntentAgent agent) 获取一个IntentAgent实例的用户ID。 IntentAgentInfo IntentAgentInfo类封装了获取一个IntentAgent实例所需的数据。使用构造函数IntentAgentInfo(int requestCode, OperationType operationType, List flags, List intents, IntentParams extraInfo)获取IntentAgentInfo对象。 requestCode：使用者定义的一个私有值。 operationType：为IntentAgentConstant.OperationType枚举中的值。 flags：为IntentAgentConstant.Flags枚举中的值。 intents：将被执行的意图列表。operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时，intents列表只允许包含一个Intent；operationType的值为START_ABILITIES时，intents列表允许包含多个Intent extraInfo：表明如何启动一个有页面的ability，可以为null，只在operationType的值为START_ABILITY和START_ABILITIES时有意义。 IntentAgentConstant IntentAgentConstant类中包含OperationType和Flags两个枚举类： 类名 枚举值 IntentAgentConstant.OperationType UNKNOWN_TYPE：不识别的类型。START_ABILITY：开启一个有页面的Ability。START_ABILITIES：开启多个有页面的Ability。START_SERVICE：开启一个无页面的ability。SEND_COMMON_EVENT：发送一个公共事件。 IntentAgentConstant.Flags ONE_TIME_FLAG：IntentAgent仅能使用一次。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。NO_BUILD_FLAG：如果描述IntentAgent对象不存在，则不创建它，直接返回null。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。CANCEL_PRESENT_FLAG：在生成一个新的IntentAgent对象前取消已存在的一个IntentAgent对象。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。UPDATE_PRESENT_FLAG：使用新的IntentAgent的额外数据替换已存在的IntentAgent中的额外数据。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。CONSTANT_FLAG：IntentAgent是不可变的。REPLACE_ELEMENT：当前Intent中的element属性可被IntentAgentHelper.triggerIntentAgent()中Intent的element属性取代。REPLACE_ACTION: 当前Intent中的action属性可被IntentAgentHelper.triggerIntentAgent()中Intent的action属性取代。REPLACE_URI：当前Intent中的uri属性可被IntentAgentHelper.triggerIntentAgent()中Intent的uri属性取代。REPLACE_ENTITIES：当前Intent中的entities属性可被IntentAgentHelper.triggerIntentAgent()中Intent的entities属性取代。REPLACE_BUNDLE：当前Intent中的bundleName属性可被IntentAgentHelper.triggerIntentAgent()中Intent的bundleName属性取代。 TriggerInfo TriggerInfo类封装了主动激发一个IntentAgent实例所需的数据，使用构造函数TriggerInfo(String permission, IntentParams extraInfo, Intent intent, int code)获取TriggerInfo对象。 permission：IntentAgent的接收者的权限名称，只在operationType的值为SEND_COMMON_EVENT时，该参数才有意义。 extraInfo：激发IntentAgent时用户自定义的额外数据。 intent：额外的Intent。如果IntentAgentInfo成员变量flags包含CONSTANT_FLAG，则忽略该参数；如果flags包含REPLACE_ELEMENT，REPLACE_ACTION，REPLACE_URI，REPLACE_ENTITIES或REPLACE_BUNDLE，则使用额外Intent的element，action，uri，entities或bundleName属性替换原始Intent中对应的属性。如果intent是空，则不替换原始Intent的属性。 code：提供给IntentAgent目标的结果码。 开发步骤 获取IntentAgent的代码示例如下： // 指定要启动的Ability的BundleName和AbilityName字段// 将Operation对象设置到Intent中Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.testintentagent\") .withAbilityName(\"com.testintentagent.entry.IntentAgentAbility\") .build();intent.setOperation(operation);List intentList = new ArrayList<>();intentList.add(intent);// 定义请求码int requestCode = 200;// 设置flagsList flags = new ArrayList<>();flags.add(IntentAgentConstant.Flags.UPDATE_PRESENT_FLAG);// 指定启动一个有页面的AbilityIntentAgentInfo paramsInfo = new IntentAgentInfo(requestCode, IntentAgentConstant.OperationType.START_ABILITY, flags, intentList, null);// 获取IntentAgent实例IntentAgent agent = IntentAgentHelper.getIntentAgent(this, paramsInfo); 通知中添加IntentAgent的代码示例如下: int notificationId = 1;NotificationRequest request = new NotificationRequest(notificationId);String title = \"title\";String text = \"There is a normal notification content.\";NotificationRequest.NotificationNormalContent content = new NotificationRequest.NotificationNormalContent();content.setTitle(title) .setText(text);NotificationContent notificationContent = new NotificationContent(content);request.setContent(notificationContent); // 设置通知的内容request.setIntentAgent(agent); // 设置通知的IntentAgent 主动激发IntentAgent的代码示例如下： int code = 100;IntentAgentHelper.triggerIntentAgent(this, agent, null, null, new TriggerInfo(null, null, null, code)); 相关实例 针对IntentAgent开发指导，有以下示例工程可供参考： IntentAgent 本示例演示了如何通过IntentAgent启动Ability和发布公共事件。 "},"service-widget-overview.html":{"url":"service-widget-overview.html","title":"概述","keywords":"","body":"概述 服务卡片（以下简称“卡片”）是FA的一种界面展示形式，将FA的重要信息或操作前置到卡片，以达到服务直达，减少体验层级目的。 卡片常用于嵌入到其他应用（当前只支持系统应用）中作为其界面的一部分显示，并支持拉起页面，发送消息等基础的交互功能。卡片使用方负责显示卡片。 示例如下图所示。 基本概念 卡片使用方 显示卡片内容的宿主应用，控制卡片在宿主中展示的位置。 卡片管理服务 用于管理系统中所添加卡片的常驻代理服务，包括卡片对象的管理与使用，以及卡片周期性刷新等。 卡片提供方 提供卡片显示内容的HarmonyOS应用或原子化服务，控制卡片的显示内容、控件布局以及控件点击事件。 说明 卡片使用方和提供方不要求常驻运行，在需要添加/删除/请求更新卡片时，卡片管理服务会拉起卡片提供方获取卡片信息。 运作机制 卡片管理服务包含以下模块： 周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。 卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。 卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。 卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。 通信适配层：负责与卡片使用方和提供方进行RPC通信。 卡片提供方包含以下模块： 卡片服务：由卡片提供方开发者实现，开发者实现onCreateForm、onUpdateForm和onDeleteForm处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。 卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务。 "},"widget-provider-intro.html":{"url":"widget-provider-intro.html","title":"卡片开发说明","keywords":"","body":"卡片开发说明 场景介绍 卡片提供方控制卡片实际显示的内容、控件布局以及控件点击事件。开发者可以通过集成以下接口来提供卡片服务。 接口说明 HarmonyOS中的服务卡片为卡片提供方开发者提供以下接口能力。 类名 接口名 描述 Ability ProviderFormInfo onCreateForm(Intent intent) 卡片提供方接收创建卡片通知接口。 void onUpdateForm(long formId) 卡片提供方接收更新卡片通知接口。 void onDeleteForm(long formId) 卡片提供方接收删除卡片通知接口。 void onTriggerFormEvent(long formId, String message) 卡片提供方处理卡片事件接口（JS卡片使用）。 boolean updateForm(long formId, ComponentProvider component) 卡片提供方主动更新卡片（Java卡片使用）。 boolean updateForm(long formId, FormBindingData formBindingData) 卡片提供方主动更新卡片（JS卡片使用），仅更新formBindingData中携带的信息，卡片中其余信息保持不变。 void onCastTempForm(long formId) 卡片提供方接收临时卡片转常态卡片通知。 void onEventNotify(Map formEvents) 卡片提供方接收到事件通知，其中Ability.FORM_VISIBLE表示卡片可见通知，Ability.FORM_INVISIBLE表示卡片不可见通知。 ProviderFormInfo ProviderFormInfo(int resId, Context context) Java卡片返回对象构造函数。 ProviderFormInfo() JS卡片返回对象构造函数。 void mergeActions(ComponentProvider componentProviderActions) 在提供方侧调用该接口，将开发者在ComponentProvider中设置的actions配置数据合并到当前对象中。 void setJsBindingData(FormBindingData data) 设置JS卡片的内容信息(JS卡片使用)。 其中，onEventNotify仅系统应用才会回调，其他接口回调时机如下图： 说明 卡片管理服务不负责保持卡片的活跃状态（设置了定时更新的除外），当使用方作出相应的请求时，管理服务会拉起提供方并回调相应接口。 Java卡片与JS卡片选型指导 Java/JS卡片场景能力差异如下表所示： 场景 Java卡片 JS卡片 支持的版本 实时刷新（类似时钟） Java使用ComponentProvider做实时刷新代价比较大 JS可以做到端侧刷新，但是需要定制化组件 HarmonyOS 2.0及以上 开发方式 Java UI在卡片提供方需要同时对数据和组件进行处理，生成ComponentProvider远端渲染 JS卡片在使用方加载渲染，提供方只要处理数据、组件和逻辑分离 HarmonyOS 2.0及以上 组件支持 Text、Image、DirectionalLayout、PositionLayout、DependentLayout div、list、list-item、swiper、stack、image、text、span、progress、button（定制：chart 、clock、calendar） HarmonyOS 2.0及以上 卡片内动效 不支持 暂不开放 HarmonyOS 2.0及以上 阴影模糊 不支持 支持 HarmonyOS 2.0及以上 动态适应布局 不支持 支持 HarmonyOS 2.0及以上 自定义卡片跳转页面 不支持 支持 HarmonyOS 2.0及以上 综上所述，JS卡片比JAVA卡片支持的控件和能力都更丰富： Java卡片：适合作为一个直达入口，没有复杂的页面和事件。 JS卡片：适合有复杂界面的卡片。 约束与限制 对于同一个Page ability，在config.json中最多支持配置16张卡片。 "},"widget-provider-js.html":{"url":"widget-provider-js.html","title":"JS卡片开发步骤","keywords":"","body":"JS卡片开发步骤 使用hml+css+js开发JS卡片页面，支持的语法详见JS API参考中“服务卡片开发”部分。 使用DevEco Studio创建卡片工程。 创建成功后，在config.json的module中会生成js模块，用于对应卡片的js相关资源，配置示例如下： \"js\": [ { \"name\": \"card\", \"pages\": [ \"pages/index/index\" ], \"window\": { \"designWidth\": 720, \"autoDesignWidth\": true }, \"type\": \"form\" }] config.json文件“abilities”配置forms模块细节如下，各属性详情可见表1。 \"forms\": [ { \"name\": \"Form_Js\", \"description\": \"form_description\", \"type\": \"JS\", \"jsComponentName\": \"card\", \"formConfigAbility\": \"ability://com.huawei.demo.SecondFormAbility\", \"colorMode\": \"auto\", \"isDefault\": true, \"updateEnabled\": true, \"scheduledUpateTime\": \"10:30\", \"updateDuration\": 1, \"defaultDimension\": \"2*2\", \"supportDimensions\": [ \"2*2\", \"2*4\", \"4*4\" ], \"metaData\": { \"customizeData\": [ { \"name\": \"originWidgetName\", \"value\": \"com.huawei.weather.testWidget\" } ] } }] 说明 配置文件中，应注意如下配置： “js”模块中的name字段要与“forms”模块中的jsComponentName字段的值一致，为js资源的实例名。 “forms”模块中的name为卡片名，即在onCreateForm中根据AbilitySlice.PARAM_FORM_NAME_KEY可取到的值。 除此之外，卡片的Ability中还需要配置\"visible\": true和\"formsEnabled\": true。 定时刷新和定点刷新都配置的情况下，定时刷新优先。 defaultDimension是默认规格，必须设置。 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示卡片的类名。字符串最大长度为127字节。 字符串 否 description - 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。 isDefault - 表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。true：默认卡片。false：非默认卡片。 布尔值 否 type - 表示卡片的类型。取值范围如下：Java：Java卡片。JS：JS卡片。 字符串 否 colorMode - 表示卡片的主题样式，取值范围如下：auto：自适应。dark：深色主题。light：浅色主题。 字符串 可缺省，缺省值为“auto”。 supportDimensions - 表示卡片支持的外观规格，取值范围：12：表示1行2列的二宫格。22：表示2行2列的四宫格。24：表示2行4列的八宫格。44：表示4行4列的十六宫格。 字符串数组 否 defaultDimension - 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否 landscapeLayouts - 表示卡片外观规格对应的横向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 portraitLayouts - 表示卡片外观规格对应的竖向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 updateEnabled - 表示卡片是否支持周期性刷新，取值范围：true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。false：表示不支持周期性刷新。 布尔类型 否 scheduledUpdateTime - 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 字符串 可缺省，缺省值为“0:0”。 updateDuration - 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。 数值 可缺省，缺省值为“0”。 formConfigAbility - 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。 jsComponentName - 表示JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。 字符串 否 metaData - 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。 customizeData - 表示自定义的卡片信息。 对象数组 可缺省，缺省值为空。 name 表示数据项的键名称。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 value 表示数据项的值。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 创建一个FormAbility，覆写卡片相关回调函数。 onCreateForm(Intent intent) onUpdateForm(long formId) onDeleteForm(long formId) onCastTempForm(long formId) onEventNotify(Map formEvents) onTriggerFormEvent(long formId, String message) 当卡片使用方请求获取卡片时，卡片提供方会被拉起并调用onCreateForm(Intent intent)回调，intent中会带有卡片ID，卡片名称和卡片外观规格信息，可按需获取使用。 开发Js卡片时，FormAbility可以继承AceAbility或Ability，继承Ability时，需在onStart()方法中额外设置路由信息。示例分别如下： FormAbility继承AceAbility的代码示例 public class FormAbility extends AceAbility { ...... public static long formId = -1; @Override public void onStart(Intent intent) { super.onStart(intent); } @Override protected ProviderFormInfo onCreateForm(Intent intent) { IntentParams params = intent.getParams(); if (params == null) { return null; } // 卡片ID formId = (long) params.getParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY); // 卡片名称 String formName = (String) params.getParam(AbilitySlice.PARAM_FORM_NAME_KEY); // 卡片规格信息 int specificationId = (int) params.getParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); FormBindingData formBindingData = new FormBindingData(\"{\\\"temperature\\\": \\\"60°\\\"}\"); ProviderFormInfo formInfo = new ProviderFormInfo(); formInfo.setJsBindingData(formBindingData); return formInfo; } @Override protected void onDeleteForm(long formId) { // 删除卡片实例数据 super.onDeleteForm(formId); ...... } @Override protected void onUpdateForm(long formId) { // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要覆写该方法以支持数据更新 super.onUpdateForm(formId); ...... } @Override protected void onTriggerFormEvent(long formId, String message) { // 若卡片支持触发事件，则需要覆写该方法并实现对事件的触发 super.onTriggerFormEvent(formId, message); ...... } @Override protected void onCastTempForm(long formId) { //使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理 super.onCastTempForm (formId); ...... } @Override protected void onEventNotify(Map formEvents) { //使用方发起可见或者不可见通知触发，提供方需要做相应的处理 super.onEventNotify(formEvents); ...... }} FormAbility继承Ability的代码示例 public class FormAbility extends Ability { ...... public static long formId = -1; @Override public void onStart(Intent intent) { super.onStart(intent); super.setMainRoute(FormAbilitySlice.class.getName()); //设置路由 } @Override protected ProviderFormInfo onCreateForm(Intent intent) { IntentParams params = intent.getParams(); if (params == null) { return null; } // 卡片ID formId = (long) params.getParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY); // 卡片名称 String formName = (String) params.getParam(AbilitySlice.PARAM_FORM_NAME_KEY); // 卡片规格信息 int specificationId = (int) params.getParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); FormBindingData formBindingData = new FormBindingData(\"{\\\"temperature\\\": \\\"60°\\\"}\"); ProviderFormInfo formInfo = new ProviderFormInfo(); formInfo.setJsBindingData(formBindingData); return formInfo; } @Override protected void onDeleteForm(long formId) { // 删除卡片实例数据 super.onDeleteForm(formId); ...... } @Override protected void onUpdateForm(long formId) { // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要覆写该方法以支持数据更新 super.onUpdateForm(formId); ...... } @Override protected void onTriggerFormEvent(long formId, String message) { // 若卡片支持触发事件，则需要覆写该方法并实现对事件的触发 super.onTriggerFormEvent(formId, message); ...... } @Override protected void onCastTempForm(long formId) { //使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理 super.onCastTempForm (formId); ...... } @Override protected void onEventNotify(Map formEvents) { //使用方发起可见或者不可见通知触发，提供方需要做相应的处理 super.onEventNotify(formEvents); ...... }} 卡片信息持久化。 因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息，且卡片框架支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。且需要适配onDeleteForm(long formId)卡片删除通知接口，在其中实现卡片实例数据的删除。 常态卡片：卡片使用方会持久化的卡片； 暂态卡片：卡片使用方不会持久化的卡片； 需要注意的是，卡片使用方在请求卡片时传递给提供方应用的Intent数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片，由于临时卡片的数据不会持久化的特殊性，某些场景比如卡片服务框架死亡重启，此时临时卡片数据在卡片服务框架中已经删除，且对应的卡片id不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片id进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。 @Overrideprotected ProviderFormInfo onCreateForm(Intent intent) {long formId = intent.getIntParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY, -1L); String formName = params.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY); int specificationId = params.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0); boolean tempFlag = params.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); ....... // 由开发人员自行实现，将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用 storeFormInfo(formId, formName, specificationId, formData); ...... HiLog.info(LABEL_LOG, \"onCreateForm finish.......\"); return formInfo;}@Overrideprotected void onDeleteForm(long formId) { super.onDeleteForm(formId); // 由开发人员自行实现，删除卡片实例数据 deleteFormInfo(formId); ......}@Overrideprotected void onCastTempForm(long formId) { // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理 super.onCastTempForm (formId); ......} 卡片数据交互。 当卡片应用需要更新数据时（如触发了定时更新或定点更新），卡片应用获取最新数据，并调用updateForm接口更新卡片。示例如下： @Overrideprotected void onUpdateForm(long formId) { super.onUpdateForm(formId); ZSONObject zsonObject = new ZSONObject(); zsonObject.put(\"temperature\", \"90°\"); FormBindingData formBindingData = new FormBindingData(zsonObject); // 调用updateForm接口去更新对应的卡片，仅更新入参中携带的数据信息，其他信息保持不变 if (!updateForm(formId, formBindingData)) { // err process }} 开发JS卡片页面。 JS卡片页面与普通FA类似通过hml+css+js开发，但不支持复杂js语法。详情请参考JS API参考。 示例如下： hml： css：.container { flex-direction: column; justify-content: center; align-items: center;} .stack_container { width: 100%; height: 100%; background-image: url(\"/common/weather-background-day.png\"); background-size: cover;}... js：export default { data: { temperature: \"35°\", city: \"hangzhou\" }, actions: { routerEvent: { action: \"router\", bundleName: \"com.example.myapplication\", abilityName: \"com.example.myapplication.FormAbility\", params: { message: \"weather\" } }, messageEvent: { action: \"message\", params: { message: \"weather update\" } } }} 开发JS卡片事件和Action。 JS卡片支持为组件设置action，包括router事件和message事件，其中router事件用于应用跳转，message事件用于卡片开发人员自定义点击事件。关键步骤说明如下： 在hml中为组件设置onclick属性，其值对应到js文件的actions属性中。 若设置router事件，则 action属性值为\"router\"； abilityName为卡片提供方应用的跳转目标Ability名； params中的值按需填写，其值在使用时通过intent.getStringParam(\"params\")获取即可； 若设置message事件，则action属性值为\"message\"，params为json格式的值。 示例如下： hml： js：export default { actions: { routerEvent: { action: \"router\", abilityName: \"com.example.myapplication.FormAbility\", params: { message: \"weather\" } }, messageEvent: { action: \"message\", params: { message: \"test date\", } } }} 当点击组件触发message事件时，卡片应用的onTriggerFormEvent方法被触发，params属性的值将作为参数被传入，解析使用即可。 说明 message事件由于是自定义，也可以在message事件中实现跳转到其他Ability的能力。但是，在这种情况下，宿主侧定义的动效是不生效的。宿主侧定义的动效仅在router事件的跳转中生效。 如果想要保证动效，使用routerEvent。 routerEvent配置跳转链接时，只能配置到卡片提供方自己的ability中。 "},"widget-provider-java.html":{"url":"widget-provider-java.html","title":"Java卡片开发指导","keywords":"","body":"Java卡片开发指导 使用DevEco Studio创建卡片工程。 卡片应用是一款特殊的元能力服务，其配置文件config.json中声明以下几项，系统能够识别该应用为一款卡片应用，并与系统进行绑定。 config.json文件\"abilities\"配置forms模块细节如下，各属性详情可见表1。 \"forms\": [ { \"name\": \"Form_Java\", \"description\": \"form_description\", \"type\": \"Java\", \"colorMode\": \"auto\", \"isDefault\": true, \"updateEnabled\": true, \"scheduledUpateTime\": \"10:30\", \"updateDuration\": 1, \"defaultDimension\": \"2*2\", \"formVisibleNotify\": true, \"supportDimensions\": [ \"1*2\", \"2*2\", \"2*4\", \"4*4\" ], \"landscapeLayouts\": [ \"$layout:form_ability_layout_1_2\", \"$layout:form_ability_layout_2_2\", \"$layout:form_ability_layout_2_4\", \"$layout:form_ability_layout_4_4\" ], \"portraitLayouts\": [ \"$layout:form_ability_layout_1_2\", \"$layout:form_ability_layout_2_2\", \"$layout:form_ability_layout_2_4\", \"$layout:form_ability_layout_4_4\" ], \"formConfigAbility\": \"ability://SecondFormAbility\", \"metaData\": { \"customizeData\": [ { \"name\": \"originWidgetName\", \"value\": \"com.huawei.weather.testWidget\" } ] } }] 说明 \"forms\"模块中的name为卡片名，即在onCreateForm中根据AbilitySlice.PARAM_FORM_NAME_KEY可取到的值。 除此之外，在卡片所在的\"abilities\"中还需要配置\"visible\": true和\"formsEnabled\": true。 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示卡片的类名。字符串最大长度为127字节。 字符串 否 description - 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。 isDefault - 表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。true：默认卡片。false：非默认卡片。 布尔值 否 type - 表示卡片的类型。取值范围如下：Java：Java卡片。JS：JS卡片。 字符串 否 colorMode - 表示卡片的主题样式，取值范围如下：auto：自适应。dark：深色主题。light：浅色主题。 字符串 可缺省，缺省值为“auto”。 supportDimensions - 表示卡片支持的外观规格，取值范围：12：表示1行2列的二宫格。22：表示2行2列的四宫格。24：表示2行4列的八宫格。44：表示4行4列的十六宫格。 字符串数组 否 defaultDimension - 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否 landscapeLayouts - 表示卡片外观规格对应的横向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 portraitLayouts - 表示卡片外观规格对应的竖向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 updateEnabled - 表示卡片是否支持周期性刷新，取值范围：true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。false：表示不支持周期性刷新。 布尔类型 否 scheduledUpdateTime - 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 字符串 可缺省，缺省值为“0:0”。 updateDuration - 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。 数值 可缺省，缺省值为“0”。 formConfigAbility - 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。 jsComponentName - 表示JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。 字符串 否 metaData - 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。 customizeData - 表示自定义的卡片信息。 对象数组 可缺省，缺省值为空。 name 表示数据项的键名称。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 value 表示数据项的值。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 创建一个FormAbility，覆写卡片相关回调函数。 onCreateForm(Intent intent) onUpdateForm(long formId) onDeleteForm(long formId) onCastTempForm(long formId) onEventNotify(Map formEvents) 在onCreateForm(Intent intent)中，当卡片使用方请求获取卡片时，卡片提供方会被拉起并调用onCreateForm(Intent intent)回调，intent中会带有卡片ID，卡片名称，临时卡片标记和卡片外观规格信息，分别通过AbilitySlice.PARAM_FORM_IDENTITY_KEY、AbilitySlice.PARAM_FORM_NAME_KEY、AbilitySlice.PARAM_FORM_TEMORARY_KEY和AbilitySlice.PARAM_FORM_DIMENSION_KEY按需获取。 提供方可以通过AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY获取卡片使用方设置的自定义数据。 public class FormAbility extends Ability { ...... @Override public void onStart(Intent intent) { super.onStart(intent); ...... } @Override protected ProviderFormInfo onCreateForm(Intent intent) { long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY, 0); String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY); int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0); boolean tempFlag = intent.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false); // 获取自定义数据 IntentParams intentParams = intent.getParam(AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); // 开发者需要根据卡片的名称以及外观规格获取对应的xml布局并构造卡片对象，此处ResourceTable.Layout_form_ability_layout_2_2仅为示例 ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this); // 获取卡片信息 String formData = getInitFormData(formName, specificationId); ComponentProvider componentProvider = new ComponentProvider(); componentProvider.setText(ResourceTable.Id_title, \"formData-\" + formData); formInfo.mergeActions(componentProvider); ...... HiLog.info(LABEL_LOG, \"onCreateForm finish.......\"); return formInfo; } @Override protected void onDeleteForm(long formId) { super.onDeleteForm(formId); // 删除卡片实例数据，需要由开发者实现 deleteFormInfo(formId); ...... } @Override // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要覆写该方法以支持数据更新 protected void onUpdateForm(long formId) { super.onUpdateForm(formId); // 更新卡片信息，由开发者实现 ...... } @Override protected void onCastTempForm(long formId) { // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理，将数据持久化。 super.onCastTempForm (formId); ...... } @Override protected void onEventNotify(Map formEvents) { // 使用方发起可见或者不可见通知触发，提供方需要做相应的处理，比如卡片可见时刷新卡片，仅系统应用能收到该回调。 super.onEventNotify(formEvents); ...... }} 卡片信息持久化。 因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息。且卡片框架支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要提供方对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。 同时，需要适配onDeleteForm(int formId)卡片删除通知接口，在其中实现卡片实例数据的删除。和JS卡片相同，需要注意卡片使用方在请求卡片时传递给提供方应用的Intent数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片，由于临时卡片的数据不会持久化的特殊性，某些场景比如卡片服务框架死亡重启，此时临时卡片数据在卡片服务框架中已经删除，且对应的卡片ID不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片ID进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。 @Overrideprotected ProviderFormInfo onCreateForm(Intent intent) { long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_ID_KEY, -1L); String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY); int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0); boolean tempFlag = params.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); ....... // 将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用，该方法需要由开发者实现。 storeFormInfo(formId, formName, specificationId, formData); ...... HiLog.info(LABEL_LOG, \"onCreateForm finish.......\"); return formInfo;}@Overrideprotected void onDeleteForm(long formId) { super.onDeleteForm(formId); // 由开发人员自行实现，删除卡片实例数据 deleteFormInfo(formId); ......}@Overrideprotected void onCastTempForm(long formId) { // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理 super.onCastTempForm (formId); ......} 卡片数据更新。 当需要卡片提供方更新数据时（如触发了定时更新，定点更新，或者卡片使用方主动请求更新），卡片提供方获取最新数据，并调用updateForm接口更新卡片。示例如下： @Overrideprotected void onUpdateForm(long formId) { super.onUpdateForm(formId); ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, this); // 获取卡片实例需要更新的卡片数据，需要由开发者实现 String formData = getUpdateFormData(formId); componentProvider.setText(ResourceTable.Id_title, \"update formData-\" + formData); updateForm(formId, componentProvider); ......} 卡片使用方点击拉起卡片页面，会在onStart(Intent intent)中携带formId（通过AbilitySlice.PARAM_FORM_IDENTITY_KEY获取），若需要在AbilitySlice中更新，也可以使用updateForm接口进行更新，示例如下： public class FormAbilitySlice extends AbilitySlice { ...... @Override public void onStart(Intent intent) { super.onStart(intent); ...... Button button = new Button(this); button.setText(\"Update form data\"); button.setClickedListener(component -> { ...... if (intent.hasParameter(AbilitySlice.PARAM_FORM_IDENTITY_KEY)) { int formId = intent.getIntParam(AbilitySlice.PARAM_FORM_ID_KEY, -1); ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, context); String formData = getUpdateFormData(formId); componentProvider.setText(ResourceTable.Id_modifylayout, \"update formData-\" + formData); getAbility().updateForm(formId, componentProvider); } }); ...... }} Java卡片控制事件。 Java卡片当前通过IntentAgent能力支持对卡片控制设置事件，例如可以使用START_ABILITY、START_SERVICE这两类能力，在点击整张卡片时，跳转到提供卡片的ability。 示例如下： @Overrideprotected ProviderFormInfo onCreateForm(Intent intent) { ...... ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this); ComponentProvider componentProvider = new ComponentProvider(); // 针对title控件设置事件 componentProvider.setIntentAgent(ResourceTable.Id_title, startAbilityIntentAgent()); formInfo.mergeActions(componentProvider); ...... return formInfo;} // 设置触发的事件为系统预置的HarmonyOS betaApp应用private IntentAgent startAbilityIntentAgent() { Intent intent = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.huawei.ohos.betaapp.link\") .withAbilityName(\"com.huawei.ohos.betaapp.link.MainAbility\") .build(); intent.setOperation(operation); List intentList = new ArrayList<>(); intentList.add(intent); List flags = new ArrayList<>(); flags.add(Flags.UPDATE_PRESENT_FLAG); IntentAgentInfo paramsInfo = new IntentAgentInfo(200, IntentAgentConstant.OperationType.START_ABILITY, flags, intentList, null); IntentAgent intentAgent = IntentAgentHelper.getIntentAgent(this, paramsInfo); return intentAgent;} 开发Java卡片布局。 在使用DevEco Studio创建模块时会生成对应的Java UI xml布局文件，具体规则请参考《XML创建布局》，需要注意设置ohos:remote=\"true\"。 以下是天气卡片xml布局示例，供参考： "},"widget-provider-optional.html":{"url":"widget-provider-optional.html","title":"其他可选功能开发指引","keywords":"","body":"其他可选功能开发指引 使用DevEco Studio创建卡片工程。 卡片应用是一款特殊的元能力服务，其配置文件config.json中声明以下几项，系统能够识别该应用为一款卡片应用，并与系统进行绑定。 config.json文件\"abilities\"配置forms模块细节如下，各属性详情可见表1。 \"forms\": [ { \"name\": \"Form_Java\", \"description\": \"form_description\", \"type\": \"Java\", \"colorMode\": \"auto\", \"isDefault\": true, \"updateEnabled\": true, \"scheduledUpateTime\": \"10:30\", \"updateDuration\": 1, \"defaultDimension\": \"2*2\", \"formVisibleNotify\": true, \"supportDimensions\": [ \"1*2\", \"2*2\", \"2*4\", \"4*4\" ], \"landscapeLayouts\": [ \"$layout:form_ability_layout_1_2\", \"$layout:form_ability_layout_2_2\", \"$layout:form_ability_layout_2_4\", \"$layout:form_ability_layout_4_4\" ], \"portraitLayouts\": [ \"$layout:form_ability_layout_1_2\", \"$layout:form_ability_layout_2_2\", \"$layout:form_ability_layout_2_4\", \"$layout:form_ability_layout_4_4\" ], \"formConfigAbility\": \"ability://SecondFormAbility\", \"metaData\": { \"customizeData\": [ { \"name\": \"originWidgetName\", \"value\": \"com.huawei.weather.testWidget\" } ] } }] 说明 \"forms\"模块中的name为卡片名，即在onCreateForm中根据AbilitySlice.PARAM_FORM_NAME_KEY可取到的值。 除此之外，在卡片所在的\"abilities\"中还需要配置\"visible\": true和\"formsEnabled\": true。 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示卡片的类名。字符串最大长度为127字节。 字符串 否 description - 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。 isDefault - 表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。true：默认卡片。false：非默认卡片。 布尔值 否 type - 表示卡片的类型。取值范围如下：Java：Java卡片。JS：JS卡片。 字符串 否 colorMode - 表示卡片的主题样式，取值范围如下：auto：自适应。dark：深色主题。light：浅色主题。 字符串 可缺省，缺省值为“auto”。 supportDimensions - 表示卡片支持的外观规格，取值范围：12：表示1行2列的二宫格。22：表示2行2列的四宫格。24：表示2行4列的八宫格。44：表示4行4列的十六宫格。 字符串数组 否 defaultDimension - 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否 landscapeLayouts - 表示卡片外观规格对应的横向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 portraitLayouts - 表示卡片外观规格对应的竖向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 updateEnabled - 表示卡片是否支持周期性刷新，取值范围：true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。false：表示不支持周期性刷新。 布尔类型 否 scheduledUpdateTime - 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 字符串 可缺省，缺省值为“0:0”。 updateDuration - 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。 数值 可缺省，缺省值为“0”。 formConfigAbility - 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。 jsComponentName - 表示JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。 字符串 否 metaData - 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。 customizeData - 表示自定义的卡片信息。 对象数组 可缺省，缺省值为空。 name 表示数据项的键名称。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 value 表示数据项的值。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 创建一个FormAbility，覆写卡片相关回调函数。 onCreateForm(Intent intent) onUpdateForm(long formId) onDeleteForm(long formId) onCastTempForm(long formId) onEventNotify(Map formEvents) 在onCreateForm(Intent intent)中，当卡片使用方请求获取卡片时，卡片提供方会被拉起并调用onCreateForm(Intent intent)回调，intent中会带有卡片ID，卡片名称，临时卡片标记和卡片外观规格信息，分别通过AbilitySlice.PARAM_FORM_IDENTITY_KEY、AbilitySlice.PARAM_FORM_NAME_KEY、AbilitySlice.PARAM_FORM_TEMORARY_KEY和AbilitySlice.PARAM_FORM_DIMENSION_KEY按需获取。 提供方可以通过AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY获取卡片使用方设置的自定义数据。 public class FormAbility extends Ability { ...... @Override public void onStart(Intent intent) { super.onStart(intent); ...... } @Override protected ProviderFormInfo onCreateForm(Intent intent) { long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY, 0); String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY); int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0); boolean tempFlag = intent.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false); // 获取自定义数据 IntentParams intentParams = intent.getParam(AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); // 开发者需要根据卡片的名称以及外观规格获取对应的xml布局并构造卡片对象，此处ResourceTable.Layout_form_ability_layout_2_2仅为示例 ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this); // 获取卡片信息 String formData = getInitFormData(formName, specificationId); ComponentProvider componentProvider = new ComponentProvider(); componentProvider.setText(ResourceTable.Id_title, \"formData-\" + formData); formInfo.mergeActions(componentProvider); ...... HiLog.info(LABEL_LOG, \"onCreateForm finish.......\"); return formInfo; } @Override protected void onDeleteForm(long formId) { super.onDeleteForm(formId); // 删除卡片实例数据，需要由开发者实现 deleteFormInfo(formId); ...... } @Override // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要覆写该方法以支持数据更新 protected void onUpdateForm(long formId) { super.onUpdateForm(formId); // 更新卡片信息，由开发者实现 ...... } @Override protected void onCastTempForm(long formId) { // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理，将数据持久化。 super.onCastTempForm (formId); ...... } @Override protected void onEventNotify(Map formEvents) { // 使用方发起可见或者不可见通知触发，提供方需要做相应的处理，比如卡片可见时刷新卡片，仅系统应用能收到该回调。 super.onEventNotify(formEvents); ...... }} 卡片信息持久化。 因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息。且卡片框架支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要提供方对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。 同时，需要适配onDeleteForm(int formId)卡片删除通知接口，在其中实现卡片实例数据的删除。和JS卡片相同，需要注意卡片使用方在请求卡片时传递给提供方应用的Intent数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片，由于临时卡片的数据不会持久化的特殊性，某些场景比如卡片服务框架死亡重启，此时临时卡片数据在卡片服务框架中已经删除，且对应的卡片ID不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片ID进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。 @Overrideprotected ProviderFormInfo onCreateForm(Intent intent) { long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_ID_KEY, -1L); String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY); int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0); boolean tempFlag = params.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); ....... // 将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用，该方法需要由开发者实现。 storeFormInfo(formId, formName, specificationId, formData); ...... HiLog.info(LABEL_LOG, \"onCreateForm finish.......\"); return formInfo;}@Overrideprotected void onDeleteForm(long formId) { super.onDeleteForm(formId); // 由开发人员自行实现，删除卡片实例数据 deleteFormInfo(formId); ......}@Overrideprotected void onCastTempForm(long formId) { // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理 super.onCastTempForm (formId); ......} 卡片数据更新。 当需要卡片提供方更新数据时（如触发了定时更新，定点更新，或者卡片使用方主动请求更新），卡片提供方获取最新数据，并调用updateForm接口更新卡片。示例如下： @Overrideprotected void onUpdateForm(long formId) { super.onUpdateForm(formId); ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, this); // 获取卡片实例需要更新的卡片数据，需要由开发者实现 String formData = getUpdateFormData(formId); componentProvider.setText(ResourceTable.Id_title, \"update formData-\" + formData); updateForm(formId, componentProvider); ......} 卡片使用方点击拉起卡片页面，会在onStart(Intent intent)中携带formId（通过AbilitySlice.PARAM_FORM_IDENTITY_KEY获取），若需要在AbilitySlice中更新，也可以使用updateForm接口进行更新，示例如下： public class FormAbilitySlice extends AbilitySlice { ...... @Override public void onStart(Intent intent) { super.onStart(intent); ...... Button button = new Button(this); button.setText(\"Update form data\"); button.setClickedListener(component -> { ...... if (intent.hasParameter(AbilitySlice.PARAM_FORM_IDENTITY_KEY)) { int formId = intent.getIntParam(AbilitySlice.PARAM_FORM_ID_KEY, -1); ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, context); String formData = getUpdateFormData(formId); componentProvider.setText(ResourceTable.Id_modifylayout, \"update formData-\" + formData); getAbility().updateForm(formId, componentProvider); } }); ...... }} Java卡片控制事件。 Java卡片当前通过IntentAgent能力支持对卡片控制设置事件，例如可以使用START_ABILITY、START_SERVICE这两类能力，在点击整张卡片时，跳转到提供卡片的ability。 示例如下： @Overrideprotected ProviderFormInfo onCreateForm(Intent intent) { ...... ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this); ComponentProvider componentProvider = new ComponentProvider(); // 针对title控件设置事件 componentProvider.setIntentAgent(ResourceTable.Id_title, startAbilityIntentAgent()); formInfo.mergeActions(componentProvider); ...... return formInfo;} // 设置触发的事件为系统预置的HarmonyOS betaApp应用private IntentAgent startAbilityIntentAgent() { Intent intent = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.huawei.ohos.betaapp.link\") .withAbilityName(\"com.huawei.ohos.betaapp.link.MainAbility\") .build(); intent.setOperation(operation); List intentList = new ArrayList<>(); intentList.add(intent); List flags = new ArrayList<>(); flags.add(Flags.UPDATE_PRESENT_FLAG); IntentAgentInfo paramsInfo = new IntentAgentInfo(200, IntentAgentConstant.OperationType.START_ABILITY, flags, intentList, null); IntentAgent intentAgent = IntentAgentHelper.getIntentAgent(this, paramsInfo); return intentAgent;} 开发Java卡片布局。 在使用DevEco Studio创建模块时会生成对应的Java UI xml布局文件，具体规则请参考《XML创建布局》，需要注意设置ohos:remote=\"true\"。 以下是天气卡片xml布局示例，供参考： "},"pasteboard-overview.html":{"url":"pasteboard-overview.html","title":"剪贴板开发概述","keywords":"","body":"剪贴板开发概述 用户通过系统剪贴板服务，可实现应用之间的简单数据传递。例如：在应用A中复制的数据，可以在应用B中粘贴，反之亦可。 HarmonyOS提供系统剪贴板服务的操作接口，支持用户程序从系统剪贴板中读取、写入和查询剪贴板数据，以及添加、移除系统剪贴板数据变化的回调。 HarmonyOS提供剪贴板数据的对象定义，包含内容对象和属性对象。 "},"pasteboard-guidelines.html":{"url":"pasteboard-guidelines.html","title":"剪贴板开发指导","keywords":"","body":"剪贴板开发指导 场景介绍 同一设备的应用程序A、B之间可以借助系统剪贴板服务完成简单数据的传递，即应用程序A向剪贴板服务写入数据后，应用程序B可以从中读取出数据。 图1 剪贴板服务示意图 在使用剪贴板服务时，需要注意以下几点： 只有在前台获取到焦点的应用才有读取系统剪贴板的权限（系统默认输入法应用除外）。 写入到剪贴板服务中的剪贴板数据不会随应用程序结束而销毁。 对同一用户而言，写入剪贴板服务的数据会被下一次写入的剪贴板数据所覆盖。 在同一设备内，剪贴板单次传递内容不应超过500KB。 接口说明 SystemPasteboard提供系统剪贴板操作的相关接口，比如复制、粘贴、配置回调等。PasteData是剪贴板服务操作的数据对象，一个PasteData由若干个内容节点（PasteData.Record）和一个属性集合对象（PasteData.DataProperty）组成。Record是存放剪贴板数据内容信息的最小单位，每个Record都有其特定的MIME类型，如纯文本、HTML、URI、Intent。剪贴板数据的属性信息存在放PasteData.DataProperty中，包括标签、时间戳等。 SystemPasteboard SystemPasteboard提供系统剪贴板服务的操作接口，比如复制、粘贴、配置回调等。 接口名 描述 getSystemPasteboard(Context context) 获取系统剪切板服务的对象实例。 getPasteData() 读取当前系统剪贴板中的数据。 hasPasteData() 判断当前系统剪贴板中是否有内容。 setPasteData(PasteData data) 将剪贴板数据写入到系统剪贴板。 clear() 清空系统剪贴板数据。 addPasteDataChangedListener(IPasteDataChangedListener listener) 用户程序添加系统剪贴板数据变化的回调，当系统剪贴板数据发生变化时，会触发用户程序的回调实现。 removePasteDataChangedListener(IPasteDataChangedListener listener) 用户程序移除系统剪贴板数据变化的回调。 PasteData PasteData是剪贴板服务操作的数据对象，其中内容节点定义为PasteData.Record，属性集合定义为PasteData.DataProperty。 接口名 描述 PasteData() 构造器，创建一个空内容数据对象。 creatPlainTextData(CharSequence text) 构建一个包含纯文本内容节点的数据对象。 creatHtmlData(String htmlText) 构建一个包含HTML内容节点的数据对象。 creatUriData(Uri uri) 构建一个包含URI内容节点的数据对象。 creatIntentData(Intent intent) 构建一个包含Intent内容节点的数据对象。 getPrimaryMimeType() 获取数据对象中首个内容节点的MIME类型，如果没有查询到内容，将返回一个空字符串。 getPrimaryText() 获取数据对象中首个内容节点的纯文本内容，如果没有查询到内容，将返回一个空对象。 addTextRecord(CharSequence text) 向数据对象中添加一个纯文本内容节点，该方法会自动更新数据属性中的MIME类型集合，最多只能添加128个内容节点。 addRecord(Record record) 向数据对象中添加一个内容节点，该方法会自动更新数据属性中的MIME类型集合，最多只能添加128个内容节点。 getRecordCount() 获取数据对象中内容节点的数量。 getRecordAt(int index) 获取数据对象在指定下标处的内容节点，如果操作失败会返回空对象。 removeRecordAt(int index) 移除数据对象在指定下标处的内容节点，如果操作成功会返回true，操作失败会返回false。 getMimeTypes() 获取数据对象中上所有内容节点的MIME类型列表，当内容节点为空时，返回列表为空对象。 getProperty() 获取该数据对象的属性集合成员。 常量名 描述 MIMETYPE_TEXT_PLAIN= \"text/plain\" 纯文本的MIME类型定义。 MIMETYPE_TEXT_HTML= \"text/html\" HTML的MIME类型定义。 MIMETYPE_TEXT_URI= \"text/uri\" URI的MIME类型定义。 MIMETYPE_TEXT_INTENT= \"text/ohos.intent\" Intent的MIME类型定义。 MAX_RECORD_NUM=128 单个PasteData中所能包含的Record的数量上限。 PasteData.Record 一个PasteData中包含若干个特定MIME类型的PasteData.Record，每个Record是存放剪贴板数据内容信息的最小单位。 接口名 描述 createPlainTextRecord(CharSequence text) 构造一个MIME类型为纯文本的内容节点。 createHtmlTextRecord(String htmlText) 构造一个MIME类型为HTML的内容节点。 createUriRecord(Uri uri) 构造一个MIME类型为URI的内容节点。 createIntentRecord(Intent intent) 构造一个MIME类型为Intent的内容节点。 getPlainText() 获取该内容节点中的文本内容，如果没有内容将返回空对象。 getHtmlText() 获取该内容节点中的HTML内容，如果没有内容将返回空对象。 getUri() 获取该内容节点中的URI内容，如果没有内容将返回空对象。 getIntent() 获取该内容节点中的Intent内容，如果没有内容将返回空对象。 getMimeType() 获取该内容节点的MIME类型。 convertToText(Context context) 将该内容节点的内容转为文本形式。 PasteData.DataProperty 每个PasteData中都有一个PasteData.DataProperty成员，其中存放着该数据对象的属性集合，例如自定义标签、MIME类型集合列表等。 接口名 描述 getMimeTypes() 获取所属数据对象的MIME类型集合列表，当内容节点为空时，返回列表为空对象。 hasMimeType(String mimeType) 判断所属数据对象中是否包含特定MIME类型的内容。 getTimestamp() 获取所属数据对象被写入系统剪贴板时的时间戳，如果该数据对象尚未被写入，则返回0。 setTag(CharSequence tag) 设置自定义标签。 getTag() 获取自定义标签。 setAdditions(PacMap extraProps) 设置一些附加键值对信息。 getAdditions() 获取附加键值对信息。 IPasteDataChangedListener IPasteDataChangedListener是定义剪贴板数据变化回调的接口类，开发者需要实现此接口来编码触发回调时的处理逻辑。 接口名 描述 onChanged() 当系统剪贴板数据发生变化时的回调接口。 开发步骤 应用A获取系统剪贴板服务。 SystemPasteboard pasteboard = SystemPasteboard.getSystemPasteboard(appContext); 应用A向系统剪贴板中写入一条纯文本数据。 if (pasteboard != null) { pasteboard.setPasteData(PasteData.creatPlainTextData(\"Hello, world!\"));} 应用B从系统剪贴板读取数据，将数据对象中的首个文本类型（纯文本/HTML）内容信息在控件中显示，忽略其他类型内容。 PasteData pasteData = pasteboard.getPasteData();if (pasteData == null) { return;}DataProperty dataProperty = pasteData.getProperty();boolean hasHtml = dataProperty.hasMimeType(PasteData.MIMETYPE_TEXT_HTML);boolean hasText = dataProperty.hasMimeType(PasteData.MIMETYPE_TEXT_PLAIN);if (hasHtml || hasText) { Text text = (Text) findComponentById(ResourceTable.Id_text); for (int i = 0; i 应用C注册添加系统剪贴板数据变化回调，当系统剪贴板数据发生变化时触发处理逻辑。 IPasteDataChangedListener listener = new IPasteDataChangedListener() { @Override public void onChanged() { PasteData pasteData = pasteboard.getPasteData(); if (pasteData == null) { return; } // Operations to handle data change on the system pasteboard }};pasteboard.addPasteDataChangedListener(listener); 相关实例 针对剪贴板开发指导，有以下示例工程可供参考： Pasteboard 本示例演示了应用之间的数据剪贴。 "},"thread-mgmt-overview.html":{"url":"thread-mgmt-overview.html","title":"线程管理开发概述","keywords":"","body":"线程管理开发概述 不同应用在各自独立的进程中运行。当应用以任何形式启动时，系统为其创建进程，该进程将持续运行。当进程完成当前任务处于等待状态，且系统资源不足时，系统自动回收。 在启动应用时，系统会为该应用创建一个称为“主线程”的执行线程。该线程随着应用创建或消失，是应用的核心线程。UI界面的显示和更新等操作，都是在主线程上进行。主线程又称UI线程，默认情况下，所有的操作都是在主线程上执行。如果需要执行比较耗时的任务（如下载文件、查询数据库），可创建其他线程来处理。 "},"thread-mgmt-guidelines.html":{"url":"thread-mgmt-guidelines.html","title":"线程管理开发指导","keywords":"","body":"线程管理开发指导 "},"inter-thread-overview.html":{"url":"inter-thread-overview.html","title":"线程间通信开发概述","keywords":"","body":"线程间通信开发概述 "},"inter-thread-guidelines.html":{"url":"inter-thread-guidelines.html","title":"线程间通信开发指导","keywords":"","body":"线程间通信开发指导 场景介绍 如果应用的业务逻辑比较复杂，可能需要创建多个线程来执行多个任务。这种情况下，代码复杂难以维护，任务与线程的交互也会更加繁杂。要解决此问题，开发者可以使用“TaskDispatcher”来分发不同的任务。 接口说明 TaskDispatcher是一个任务分发器，它是Ability分发任务的基本接口，隐藏任务所在线程的实现细节。 为保证应用有更好的响应性，我们需要设计任务的优先级。在UI线程上运行的任务默认以高优先级运行，如果某个任务无需等待结果，则可以用低优先级。 优先级 详细描述 HIGH 最高任务优先级，比默认优先级、低优先级的任务有更高的几率得到执行。 DEFAULT 默认任务优先级， 比低优先级的任务有更高的几率得到执行。 LOW 低任务优先级，比高优先级、默认优先级的任务有更低的几率得到执行。 TaskDispatcher具有多种实现，每种实现对应不同的任务分发器。在分发任务时可以指定任务的优先级，由同一个任务分发器分发出的任务具有相同的优先级。系统提供的任务分发器有GlobalTaskDispatcher、ParallelTaskDispatcher、SerialTaskDispatcher 、SpecTaskDispatcher。 GlobalTaskDispatcher 全局并发任务分发器，由Ability执行getGlobalTaskDispatcher()获取。适用于任务之间没有联系的情况。一个应用只有一个GlobalTaskDispatcher，它在程序结束时才被销毁。 TaskDispatcher globalTaskDispatcher = getGlobalTaskDispatcher(TaskPriority.DEFAULT); ParallelTaskDispatcher 并发任务分发器，由Ability执行createParallelTaskDispatcher()创建并返回。与GlobalTaskDispatcher不同的是，ParallelTaskDispatcher不具有全局唯一性，可以创建多个。开发者在创建或销毁dispatcher时，需要持有对应的对象引用 。 String dispatcherName = \"parallelTaskDispatcher\";TaskDispatcher parallelTaskDispatcher = createParallelTaskDispatcher(dispatcherName, TaskPriority.DEFAULT); SerialTaskDispatcher 串行任务分发器，由Ability执行createSerialTaskDispatcher()创建并返回。由该分发器分发的所有的任务都是按顺序执行，但是执行这些任务的线程并不是固定的。如果要执行并行任务，应使用ParallelTaskDispatcher或者GlobalTaskDispatcher，而不是创建多个SerialTaskDispatcher。如果任务之间没有依赖，应使用GlobalTaskDispatcher来实现。它的创建和销毁由开发者自己管理，开发者在使用期间需要持有该对象引用。 String dispatcherName = \"serialTaskDispatcher\";TaskDispatcher serialTaskDispatcher = createSerialTaskDispatcher(dispatcherName, TaskPriority.DEFAULT); SpecTaskDispatcher 专有任务分发器，绑定到专有线程上的任务分发器。目前已有的专有线程为UI线程，通过UITaskDispatcher进行任务分发。 UITaskDispatcher：绑定到应用主线程的专有任务分发器， 由Ability执行getUITaskDispatcher()创建并返回。 由该分发器分发的所有的任务都是在主线程上按顺序执行，它在应用程序结束时被销毁。 TaskDispatcher uiTaskDispatcher = getUITaskDispatcher(); 开发步骤 syncDispatch 同步派发任务：派发任务并在当前线程等待任务执行完成。在返回前，当前线程会被阻塞。 如下代码示例展示了如何使用GlobalTaskDispatcher派发同步任务： TaskDispatcher globalTaskDispatcher = getGlobalTaskDispatcher(TaskPriority.DEFAULT);globalTaskDispatcher.syncDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"sync task1 run\"); }});HiLog.info(LABEL_LOG, \"after sync task1\"); globalTaskDispatcher.syncDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"sync task2 run\"); }});HiLog.info(LABEL_LOG, \"after sync task2\"); globalTaskDispatcher.syncDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"sync task3 run\"); }});HiLog.info(LABEL_LOG, \"after sync task3\"); // 执行结果如下：// sync task1 run// after sync task1// sync task2 run// after sync task2// sync task3 run// after sync task3 说明 如果对syncDispatch使用不当, 将会导致死锁。如下情形可能导致死锁发生： 在专有线程上，利用该专有任务分发器进行syncDispatch。 在被某个串行任务分发器（dispatcher_a）派发的任务中，再次利用同一个串行任务分发器（dispatcher_a）对象派发任务。 在被某个串行任务分发器（dispatcher_a）派发的任务中，经过数次派发任务，最终又利用该（dispatcher_a）串行任务分发器派发任务。例如：dispatcher_a派发的任务使用dispatcher_b进行任务的派发，在dispatcher_b派发的任务中又利用dispatcher_a进行派发任务。 串行任务分发器（dispatcher_a）派发的任务中利用串行任务分发器（dispatcher_b）进行同步派发任务，同时dispatcher_b派发的任务中利用串行任务分发器（dispatcher_a）进行同步派发任务。在特定的线程执行顺序下将导致死锁。 asyncDispatch 异步派发任务：派发任务，并立即返回，返回值是一个可用于取消任务的接口。 如下代码示例展示了如何使用GlobalTaskDispatcher派发异步任务： TaskDispatcher globalTaskDispatcher = getGlobalTaskDispatcher(TaskPriority.DEFAULT);Revocable revocable = globalTaskDispatcher.asyncDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"async task1 run\"); }});HiLog.info(LABEL_LOG, \"after async task1\"); // 执行结果可能如下：// after async task1// async task1 run delayDispatch 异步延迟派发任务：异步执行，函数立即返回，内部会在延时指定时间后将任务派发到相应队列中。延时时间参数仅代表在这段时间以后任务分发器会将任务加入到队列中，任务的实际执行时间可能晚于这个时间。具体比这个数值晚多久，取决于队列及内部线程池的繁忙情况。 如下代码示例展示了如何使用GlobalTaskDispatcher延迟派发任务： final long callTime = System.currentTimeMillis();final long delayTime = 50L;TaskDispatcher globalTaskDispatcher = getGlobalTaskDispatcher(TaskPriority.DEFAULT); Revocable revocable = globalTaskDispatcher.delayDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"delayDispatch task1 run\"); final long actualDelay = System.currentTimeMillis() - callTime; HiLog.info(LABEL_LOG, \"actualDelayTime >= delayTime: %{public}b\", (actualDelay >= delayTime)); }}, delayTime);HiLog.info(LABEL_LOG, \"after delayDispatch task1\"); // 执行结果可能如下：// after delayDispatch task1// delayDispatch task1 run// actualDelayTime >= delayTime : true Group 任务组：表示一组任务，且该组任务之间有一定的联系，由TaskDispatcher执行createDispatchGroup创建并返回。将任务加入任务组，返回一个用于取消任务的接口。 如下代码示例展示了任务组的使用方式：将一系列相关联的下载任务放入一个任务组，执行完下载任务后关闭应用。 String dispatcherName = \"parallelTaskDispatcher\";TaskDispatcher dispatcher = createParallelTaskDispatcher(dispatcherName, TaskPriority.DEFAULT);// 创建任务组。Group group = dispatcher.createDispatchGroup();// 将任务1加入任务组，返回一个用于取消任务的接口。dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"download task1 is running\"); }});// 将与任务1相关联的任务2加入任务组。dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"download task2 is running\"); }});// 在任务组中的所有任务执行完成后执行指定任务。dispatcher.groupDispatchNotify(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"the close task is running after all tasks in the group are completed\"); }});// 可能的执行结果:// download task1 is running// download task2 is running// the close task is running after all tasks in the group are completed // 另外一种可能的执行结果：// download task2 is running// download task1 is running// the close task is running after all tasks in the group are completed Revocable 取消任务：Revocable是取消一个异步任务的接口。异步任务包括通过 asyncDispatch、delayDispatch、asyncGroupDispatch 派发的任务。如果任务已经在执行中或执行完成，则会返回取消失败。 如下代码示例展示了如何取消一个异步延时任务： TaskDispatcher dispatcher = getUITaskDispatcher();Revocable revocable = dispatcher.delayDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"delay dispatch\"); }}, 10);boolean revoked = revocable.revoke();HiLog.info(LABEL_LOG, \"%{public}b\", revoked);// 一种可能的结果如下 :// true syncDispatchBarrier 同步设置屏障任务：在任务组上设立任务执行屏障，同步等待任务组中的所有任务执行完成，再执行指定任务。 说明 在全局并发任务分发器（GlobalTaskDispatcher）上同步设置任务屏障，将不会起到屏障作用。 如下代码示例展示了如何同步设置屏障： String dispatcherName = \"parallelTaskDispatcher\";TaskDispatcher dispatcher = createParallelTaskDispatcher(dispatcherName, TaskPriority.DEFAULT);// 创建任务组。Group group = dispatcher.createDispatchGroup();// 将任务加入任务组，返回一个用于取消任务的接口。dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"task1 is running\"); // 1 }});dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"task2 is running\"); // 2 }}); dispatcher.syncDispatchBarrier(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"barrier\"); // 3 }}); HiLog.info(LABEL_LOG, \"after syncDispatchBarrier\"); // 4// 1和2的执行顺序不定；3和4总是在1和2之后按顺序执行。 // 可能的执行结果:// task1 is running// task2 is running// barrier// after syncDispatchBarrier // 另外一种执行结果：// task2 is running// task1 is running// barrier// after syncDispatchBarrier asyncDispatchBarrier 异步设置屏障任务：在任务组上设立任务执行屏障后直接返回，指定任务将在任务组中的所有任务执行完成后再执行。 说明 在全局并发任务分发器（GlobalTaskDispatcher）上异步设置任务屏障，将不会起到屏障作用。可以使用并发任务分发器（ParallelTaskDispatcher）分离不同的任务组，达到微观并行、宏观串行的行为。 如下代码示例展示了如何异步设置屏障： TaskDispatcher dispatcher = createParallelTaskDispatcher(\"dispatcherName\", TaskPriority.DEFAULT);// 创建任务组。Group group = dispatcher.createDispatchGroup();// 将任务加入任务组，返回一个用于取消任务的接口。dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"task1 is running\"); // 1 }});dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"task2 is running\"); // 2 }}); dispatcher.asyncDispatchBarrier(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"barrier\"); // 3 }}); HiLog.info(LABEL_LOG, \"after asyncDispatchBarrier\"); // 4// 1和2的执行顺序不定，但总在3之前执行；4不需要等待1、2、3执行完成。 // 可能的执行结果:// task1 is running// task2 is running// after asyncDispatchBarrier// barrier applyDispatch 执行多次任务：对指定任务执行多次。 如下代码示例展示了如何执行多次任务： final int total = 10;final CountDownLatch latch = new CountDownLatch(total);final List indexList = new ArrayList<>(total);TaskDispatcher dispatcher = getGlobalTaskDispatcher(TaskPriority.DEFAULT); // 执行任务 total 次。dispatcher.applyDispatch((index) -> { indexList.add(index); latch.countDown();}, total);// 设置任务超时。try { latch.await();} catch (InterruptedException exception) { HiLog.error(LABEL_LOG, \"latch exception\");}HiLog.info(LABEL_LOG, \"list size matches, %{public}b\", (total == indexList.size()));// 执行结果：// list size matches, true 相关实例 针对线程管理，有以下示例工程可供参考： TaskDispatcher 如果应用的业务逻辑比较复杂，可能需要创建多个线程来执行多个任务。本示例演示了如何使用“TaskDispatcher”来分发不同的任务，例如：同步派发、异步派发、异步延迟派发等。 "},"java-overview.html":{"url":"java-overview.html","title":"Java UI框架概述","keywords":"","body":"Java UI框架概述 应用的Ability在屏幕上将显示一个用户界面，该界面用来显示所有可被用户查看和交互的内容。 应用中所有的用户界面元素都是由Component和ComponentContainer对象构成。Component是绘制在屏幕上的一个对象，用户能与之交互。ComponentContainer是一个用于容纳其他Component和ComponentContainer对象的容器。 Java UI框架提供了一部分Component和ComponentContainer的具体子类，即创建用户界面（UI）的各类组件，包括一些常用的组件（比如：文本、按钮、图片、列表等）和常用的布局（比如：DirectionalLayout和DependentLayout）。用户可通过组件进行交互操作，并获得响应。 所有的UI操作都应该在主线程进行设置。 组件和布局 用户界面元素统称为组件，组件根据一定的层级结构进行组合形成布局。组件在未被添加到布局中时，既无法显示也无法交互，因此一个用户界面至少包含一个布局。在UI框架中，具体的布局类通常以XXLayout命名，完整的用户界面是一个布局，用户界面中的一部分也可以是一个布局。布局中容纳Component与ComponentContainer对象。 Component和ComponentContainer Component：提供内容显示，是界面中所有组件的基类，开发者可以给Component设置事件处理回调来创建一个可交互的组件。Java UI框架提供了一些常用的界面元素，也可称之为组件，组件一般直接继承Component或它的子类，如Text、Image等。 ComponentContainer：作为容器容纳Component或ComponentContainer对象，并对它们进行布局。Java UI框架提供了一些标准布局功能的容器，它们继承自ComponentContainer，一般以“Layout”结尾，如DirectionalLayout、DependentLayout等。 图1 Component结构 LayoutConfig 每种布局都根据自身特点提供LayoutConfig供子Component设定布局属性和参数，通过指定布局属性可以对子Component在布局中的显示效果进行约束。例如：“width”、“height”是最基本的布局属性，它们指定了组件的大小。 图2 LayoutConfig 组件树 布局把Component和ComponentContainer以树状的层级结构进行组织，这样的一个布局就称为组件树。组件树的特点是仅有一个根组件，其他组件有且仅有一个父节点，组件之间的关系受到父节点的规则约束。 "},"java-component-layout-overview.html":{"url":"java-component-layout-overview.html","title":"开发说明","keywords":"","body":"开发说明 HarmonyOS提供了Ability和AbilitySlice两个基础类，一个有界面的Ability可以由一个或多个AbilitySlice构成，AbilitySlice主要用于承载单个页面的具体逻辑实现和界面UI，是应用显示、运行和跳转的最小单元。AbilitySlice通过setUIContent为界面设置布局。 接口声明 接口描述 setUIContent(ComponentContainer root) 设置界面入口，root为界面组件树根节点。 组件需要进行组合，并添加到界面的布局中。在Java UI框架中，提供了两种编写布局的方式： 在代码中创建布局：用代码创建Component和ComponentContainer对象，为这些对象设置合适的布局参数和属性值，并将Component添加到ComponentContainer中，从而创建出完整界面。 在XML中声明UI布局：按层级结构来描述Component和ComponentContainer的关系，给组件节点设定合适的布局参数和属性值，代码中可直接加载生成此布局。 这两种方式创建出的布局没有本质差别，在XML中声明布局，在加载后同样可在代码中对该布局进行修改。 组件分类 根据组件的功能，可以将组件分为布局类、显示类、交互类三类： 组件类别 组件名称 功能描述 布局类 PositionLayout、DirectionalLayout、StackLayout、DependentLayout、TableLayout、AdaptiveBoxLayout 提供了不同布局规范的组件容器，例如以单一方向排列的DirectionalLayout、以相对位置排列的DependentLayout、以确切位置排列的PositionLayout等。 显示类 Text、Image、Clock、TickTimer、ProgressBar 提供了单纯的内容显示，例如用于文本显示的Text，用于图像显示的Image等。 交互类 TextField、Button、Checkbox、RadioButton/RadioContainer、Switch、ToggleButton、Slider、Rating、ScrollView、TabList、ListContainer、PageSlider、PageFlipper、PageSliderIndicator、Picker、TimePicker、DatePicker、SurfaceProvider、ComponentProvider 提供了具体场景下与用户交互响应的功能，例如Button提供了点击响应功能，Slider提供了进度选择功能等。 框架提供的组件使应用界面开发更加便利，这些组件的具体功能说明及属性设置详见API参考。 相关实例 针对常用组件和布局开发，有以下示例工程可供参考： Components 本示例演示了Text和Button两种常用组件的基础使用方法。 CommonLayout 本示例演示了DirectionalLayout和DependentLayout两种常用布局的基础使用方法。 针对Java UI框架的组件与布局开发，有以下Codelabs可供参考： 常用组件和布局 基于HarmonyOS Java UI，实现常见组件或者布局。 分布式新闻客户端 基于HarmonyOS应用中Service Ability和Page Ability的使用，实现跨设备FA拉起。 跨设备视频播放 基于分布式能力和IDL跨进程通信，实现视频跨设备播放、控制。 分布式游戏手柄 基于分布式能力，将手机作为智慧屏的虚拟手柄终端，组成全新的多人娱乐场景。 "},"java-component-layout-code.html":{"url":"java-component-layout-code.html","title":"代码创建布局","keywords":"","body":"代码创建布局 开发如下图所示界面，需要添加一个Text组件和Button组件。由于两个组件从上到下依次居中排列，可以选择使用竖向的DirectionalLayout布局来放置组件。 图1 开发样例图 代码创建布局需要在AbilitySlice中分别创建组件和布局，并将它们进行组织关联。 创建组件 声明组件 Button button = new Button(getContext()); 设置组件大小 button.setWidth(ComponentContainer.LayoutConfig.MATCH_CONTENT);button.setHeight(ComponentContainer.LayoutConfig.MATCH_CONTENT); 设置组件属性 button.setText(\"My name is Button.\");button.setTextSize(50); 创建布局并使用 声明布局 DirectionalLayout directionalLayout = new DirectionalLayout(getContext()); 设置布局大小 directionalLayout.setWidth(ComponentContainer.LayoutConfig.MATCH_PARENT);directionalLayout.setHeight(ComponentContainer.LayoutConfig.MATCH_PARENT); 设置布局属性 directionalLayout.setOrientation(Component.VERTICAL); 将组件添加到布局中（视布局需要对组件设置布局属性进行约束） directionalLayout.addComponent(button); 将布局添加到组件树中 setUIContent(directionalLayout); 示例代码如下： public class ExampleAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 声明布局 DirectionalLayout directionalLayout = new DirectionalLayout(getContext()); // 设置布局大小 directionalLayout.setWidth(ComponentContainer.LayoutConfig.MATCH_PARENT); directionalLayout.setHeight(ComponentContainer.LayoutConfig.MATCH_PARENT); // 设置布局属性 directionalLayout.setOrientation(Component.VERTICAL); directionalLayout.setPadding(32, 32, 32, 32); Text text = new Text(getContext()); text.setText(\"My name is Text.\"); text.setTextSize(50); text.setId(100); // 为组件添加对应布局的布局属性 DirectionalLayout.LayoutConfig layoutConfig = new DirectionalLayout.LayoutConfig(ComponentContainer.LayoutConfig.MATCH_CONTENT, ComponentContainer.LayoutConfig.MATCH_CONTENT); layoutConfig.alignment = LayoutAlignment.HORIZONTAL_CENTER; text.setLayoutConfig(layoutConfig); // 将Text添加到布局中 directionalLayout.addComponent(text); // 类似的添加一个Button Button button = new Button(getContext()); layoutConfig.setMargins(0, 50, 0, 0); button.setLayoutConfig(layoutConfig); button.setText(\"My name is Button.\"); button.setTextSize(50); ShapeElement background = new ShapeElement(); background.setRgbColor(new RgbColor(0, 125, 255)); background.setCornerRadius(25); button.setBackground(background); button.setPadding(10, 10, 10, 10); button.setClickedListener(new Component.ClickedListener() { @Override // 在组件中增加对点击事件的检测 public void onClick(Component component) { // 此处添加按钮被点击需要执行的操作 } }); directionalLayout.addComponent(button); // 将布局作为根布局添加到视图树中 super.setUIContent(directionalLayout); }} 根据以上步骤创建组件和布局后的界面显示效果如图1所示。其中，代码示例中为组件设置了一个按键回调，在按键被按下后，应用会执行自定义的操作。 在代码示例中，可以看到设置组件大小的方法有两种： 通过setWidth/setHeight直接设置宽高。 通过setLayoutConfig方法设置布局属性来设定宽高。 这两种方法的区别是后者还可以增加更多的布局属性设置，例如：使用“alignment”设置水平居中的约束。另外，这两种方法设置的宽高以最后设置的作为最终结果。它们的取值一致，可以是以下取值： 具体以像素为单位的数值。 MATCH_PARENT：表示组件大小将扩展为父组件允许的最大值，它将占据父组件方向上的剩余大小。 MATCH_CONTENT：表示组件大小与它内容占据的大小范围相适应。 "},"java-component-layout-xml.html":{"url":"java-component-layout-xml.html","title":"XML创建布局","keywords":"","body":"XML创建布局 XML声明布局的方式更加简便直观。每一个Component和ComponentContainer对象大部分属性都支持在XML中进行设置，它们都有各自的XML属性列表。某些属性仅适用于特定的组件，例如：只有Text支持“text_color”属性，但不支持该属性的组件如果添加了该属性，该属性则会被忽略。具有继承关系的组件子类将继承父类的属性列表，Component作为组件的基类，拥有各个组件常用的属性，比如：ID、布局参数等。 ID ohos:id=\"$+id:text\" 在XML中使用此格式声明一个对开发者友好的ID，它会在编译过程中转换成一个常量。尤其在DependentLayout布局中，组件之间需要描述相对位置关系，描述时要通过ID来指定对应组件。 布局中的组件通常要设置独立的ID，以便在程序中查找该组件。如果布局中有不同组件设置了相同的ID，在通过ID查找组件时会返回查找到的第一个组件，因此尽量保证在所要查找的布局中为组件设置独立的ID值，避免出现与预期不符合的问题。 布局参数 ohos:width=\"20vp\"ohos:height=\"10vp\" 与代码中设置组件的宽度和高度类似，在XML中它们的取值可以是： 具体的数值：10（以像素为单位）、10vp（以屏幕相对像素为单位）。 match_parent：表示组件大小将扩展为父组件允许的最大值，它将占据父组件方向上的剩余大小。 match_content：表示组件大小与它的内容占据的大小范围相适应。 创建XML布局文件 在DevEco Studio的“Project”窗口，打开“entry > src > main > resources > base”，右键点击“layout”文件夹，选择“New > Layout Resource File”，命名为“first_layout”。 打开新创建的first_layout.xml布局文件，修改其中的内容，对布局和组件的属性和层级进行描述。 加载XML布局 在代码中需要加载XML布局，并添加为根布局或作为其他布局的子Component。 package com.example.myapplication.slice; import com.example.myapplication.ResourceTable;import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.colors.RgbColor;import ohos.agp.components.*;import ohos.agp.components.element.ShapeElement; public class ExampleAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 加载XML布局作为根布局 super.setUIContent(ResourceTable.Layout_first_layout); Button button = (Button) findComponentById(ResourceTable.Id_button); if (button != null) { // 设置组件的属性 ShapeElement background = new ShapeElement(); background.setRgbColor(new RgbColor(0, 125, 255)); background.setCornerRadius(25); button.setBackground(background); button.setClickedListener(new Component.ClickedListener() { @Override // 在组件中增加对点击事件的检测 public void onClick(Component component) { // 此处添加按钮被点击需要执行的操作 } }); } }} "},"java-component-text.html":{"url":"java-component-text.html","title":"Text","keywords":"","body":"Text Text是用来显示字符串的组件，在界面上显示为一块文本区域。Text作为一个基本组件，有很多扩展，常见的有按钮组件Button，文本编辑组件TextField。 支持的XML属性 Text的共有XML属性继承自：Component Text的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 text 显示文本 string类型 可以直接设置文本字串，也可以引用string资源。 ohos:text=\"熄屏时间\"ohos:text=\"$string:test_str\" hint 提示文本 string类型 可以直接设置文本字串，也可以引用string资源。 ohos:hint=\"联系人\"ohos:hint=\"$string:test_str\" text_font 字体 sans-serif 可以设置的字体如表中所列。 ohos:text_font=\"HwChinese-medium\" sans-serif-medium HwChinese-medium sans-serif-condensed sans-serif-condensed-medium monospace truncation_mode 长文本截断方式 none 表示文本超长时无截断。 ohos:truncation_mode=\"none\" ellipsis_at_start 表示文本超长时在文本框起始处使用省略号截断。 ohos:truncation_mode=\"ellipsis_at_start\" ellipsis_at_middle 表示文本超长时在文本框中间位置使用省略号截断。 ohos:truncation_mode=\"ellipsis_at_middle\" ellipsis_at_end 表示文本超长时在文本框结尾处使用省略号截断。 ohos:truncation_mode=\"ellipsis_at_end\" auto_scrolling 表示文本超长时滚动显示全部文本。 ohos:truncation_mode=\"auto_scrolling\" text_size 文本大小 float类型 表示字体大小的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:text_size=\"30\"ohos:text_size=\"16fp\"ohos:text_size=\"$float:size_value\" element_padding 文本与图片的边距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:element_padding=\"20\"ohos:element_padding=\"8vp\"ohos:element_padding=\"$float:size_value\" bubble_width 文本气泡宽度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_width=\"20\"ohos:bubble_width=\"10vp\"ohos:bubble_width=\"$float:size_value\" bubble_height 文本气泡高度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_height=\"20\"ohos:bubble_height=\"10vp\"ohos:bubble_height=\"$float:size_value\" bubble_left_width 文本气泡左宽度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_left_width=\"20\"ohos:bubble_left_width=\"10vp\"ohos:bubble_left_width=\"$float:size_value\" bubble_left_height 文本气泡左高度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_left_height=\"20\"ohos:bubble_left_height=\"10vp\"ohos:bubble_left_height=\"$float:size_value\" bubble_right_width 文本气泡右宽度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_right_width=\"20\"ohos:bubble_right_width=\"10vp\"ohos:bubble_right_width=\"$float:size_value\" bubble_right_height 文本气泡右高度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_right_height=\"20\"ohos:bubble_right_height=\"10vp\"ohos:bubble_right_height=\"$float:size_value\" text_color 文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:text_color=\"#A8FFFFFF\"ohos:text_color=\"$color:black\" hint_color 提示文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:hint_color=\"#A8FFFFFF\"ohos:hint_color=\"$color:black\" selection_color 选中文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:selection_color=\"#A8FFFFFF\"ohos:selection_color=\"$color:black\" text_alignment 文本对齐方式 left 表示文本靠左对齐。 可以设置取值项如表中所列，也可以使用“\\ ”进行多项组合。ohos:text_alignment=\"top\"ohos:text_alignment=\"top\\ left\" top 表示文本靠顶部对齐。 right 表示文本靠右对齐。 bottom 表示文本靠底部对齐。 horizontal_center 表示文本水平居中对齐。 vertical_center 表示文本垂直居中对齐。 center 表示文本居中对齐。 start 表示文本靠起始端对齐。 end 表示文本靠结尾端对齐。 max_text_lines 文本最大行数 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:max_text_lines=\"2\"ohos:max_text_lines=\"$integer:two\" text_input_type 文本输入类型 pattern_null 表示未指定文本输入类型，默认文本输入类型为内容模式。 ohos:text_input_type=\"pattern_null\" pattern_text 表示文本输入类型为普通文本模式。 ohos:text_input_type=\"pattern_text\" pattern_number 表示文本输入类型为数字。 ohos:text_input_type=\"pattern_number\" pattern_password 表示文本输入类型为密码。 ohos:text_input_type=\"pattern_password\" input_enter_key_type 输入键类型 enter_key_type_unspecified 表示指定输入键类型，采用默认类型。 ohos:input_enter_key_type=\"enter_key_type_unspecified\" enter_key_type_search 表示采用执行“搜索”动作的输入键类型。 ohos:input_enter_key_type=\"enter_key_type_search\" enter_key_type_go 表示采用执行“go”动作的输入键类型。 ohos:input_enter_key_type=\"enter_key_type_go\" enter_key_type_send 表示采用执行“发送”动作的输入键类型。 ohos:input_enter_key_type=\"enter_key_type_send\" auto_scrolling_duration 自动滚动时长 integer类型 可以直接设置整型数值，也可以引用integer资源。表示时间的值不可小于0，单位为ms。 ohos:auto_scrolling_duration=\"1000\"ohos:auto_scrolling_duration=\"$integer:during\" multiple_lines 多行模式设置 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:multiple_lines=\"true\"ohos:multiple_lines=\"$boolean:true\" auto_font_size 是否支持文本自动调整文本字体大小 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:auto_font_size=\"true\"ohos:auto_font_size=\"$boolean:true\" scrollable 文本是否可滚动 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:scrollable=\"true\"ohos:scrollable=\"$boolean:true\" text_cursor_visible 文本光标是否可见。只有在可编辑的组件上可配置，否则该值始终为false。 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:text_cursor_visible=\"true\"ohos:text_cursor_visible=\"$boolean:true\" italic 文本是否斜体字体 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:italic=\"true\"ohos:italic=\"$boolean:true\" padding_for_text 设置文本顶部与底部是否默认留白。默认值为true，true表示保留默认留白，false表示顶部与底部不留白 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:padding_for_text=\"true\"ohos:padding_for_text=\"$boolean:true\" additional_line_spacing 需增加的行间距 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:additional_line_spacing=\"2\"ohos:additional_line_spacing=\"$float:line_spacing_add\" line_height_num 行间距倍数 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:line_height_num=\"1.5\"ohos:line_height_num=\"$float:line_spacing_multi\" element_left 文本左侧图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。说明element_left与element_start、element_end属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，element_left会与element_start属性冲突；在“水平布局方向为从右到左”时，element_left会与element_end属性冲突。同时配置时，element_start、element_end优先级高于element_left属性。 ohos:element_left=\"#FFFFFFFF\"ohos:element_left=\"$color:black\"ohos:element_left=\"$media:media_src\"ohos:element_left=\"$graphic:graphic_src\" element_top 文本上方图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:element_top=\"#FFFFFFFF\"ohos:element_top=\"$color:black\"ohos:element_top=\"$media:media_src\"ohos:element_top=\"$graphic:graphic_src\" element_right 文本右侧图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。说明element_right与element_start、element_end属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，element_right会与element_end属性冲突；在“水平布局方向为从右到左”时，element_right会与element_start属性冲突。同时配置时，element_start、element_end优先级高于element_right属性。 ohos:element_right=\"#FFFFFFFF\"ohos:element_right=\"$color:black\"ohos:element_right=\"$media:media_src\"ohos:element_right=\"$graphic:graphic_src\" element_bottom 文本下方图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:element_bottom=\"#FFFFFFFF\"ohos:element_bottom=\"$color:black\"ohos:element_bottom=\"$media:media_src\"ohos:element_bottom=\"$graphic:graphic_src\" element_start 文本开始方向图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。说明element_start与element_left、element_right属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，element_start会与element_left属性冲突；在“水平布局方向为从右到左”时，element_start会与element_right属性冲突。同时配置时，element_start优先级高于element_left、element_right属性。 ohos:element_start=\"#FFFFFFFF\"ohos:element_start=\"$color:black\"ohos:element_start=\"$media:media_src\"ohos:element_start=\"$graphic:graphic_src\" element_end 文本结束方向图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。说明element_end与element_left、element_right属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，element_end会与element_right属性冲突；在“水平布局方向为从右到左”时，element_end会与element_left属性冲突。同时配置时，element_end优先级高于element_left、element_right属性。 ohos:element_end=\"#FFFFFFFF\"ohos:element_end=\"$color:black\"ohos:element_end=\"$media:media_src\"ohos:element_end=\"$graphic:graphic_src\" element_cursor_bubble 文本的光标气泡图形只有在可编辑的组件上可配置 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:element_cursor_bubble=\"#FFFFFFFF\"ohos:element_cursor_bubble=\"$color:black\"ohos:element_cursor_bubble=\"$media:media_src\"ohos:element_cursor_bubble=\"$graphic:graphic_src\" element_selection_left_bubble 选中文本的左侧气泡图形 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:element_selection_left_bubble=\"#FFFFFFFF\"ohos:element_selection_left_bubble=\"$color:black\"ohos:element_selection_left_bubble=\"$media:media_src\"ohos:element_selection_left_bubble=\"$graphic:graphic_src\" element_selection_right_bubble 选中文本的右侧气泡图形 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:element_selection_right_bubble=\"#FFFFFFFF\"ohos:element_selection_right_bubble=\"$color:black\"ohos:element_selection_right_bubble=\"$media:media_src\"ohos:element_selection_right_bubble=\"$graphic:graphic_src\" 创建Text 在layout目录下的xml文件中创建Text。 设置Text 在xml中设置Text的背景。 layout目录下xml文件的代码示例如下： 常用的背景如常见的文本背景、按钮背景，可以采用XML格式放置在graphic目录下。 在“Project”窗口，打开“entry > src > main > resources > base”，右键点击“graphic”文件夹，选择“New > File”，命名为“background_text.xml”，在background_text.xml中定义文本的背景。 图1 使用xml设置Text背景的效果 设置字体大小和颜色 图2 设置字体大小和颜色的效果 设置字体风格和字重 图3 设置字体风格和字重的效果 设置文本对齐方式 图4 设置文本对齐方式的效果 设置文本换行和最大显示行数 图5 设置文本换行和最大显示行数的效果 自动调节字体大小 Text对象支持根据文本长度自动调整文本的字体大小和换行。 设置自动换行、最大显示行数和自动调节字体大小。 通过setAutoFontSizeRule设置自动调整规则，三个入参分别是最小的字体大小、最大的字体大小、每次调整文本字体大小的步长。 Text text = (Text) findComponentById(ResourceTable.Id_text);// 设置自动调整规则text.setAutoFontSizeRule(30, 100, 1);// 设置点击一次增多一个\"T\"text.setClickedListener(new Component.ClickedListener() { @Override public void onClick(Component component) { text.setText(text.getText() + \"T\"); }}); 图6 自动调节字体大小 跑马灯效果 当文本过长时，可以设置跑马灯效果，实现文本滚动显示。前提是文本换行关闭且最大显示行数为1，默认情况下即可满足前提要求。 // 跑马灯效果text.setTruncationMode(Text.TruncationMode.AUTO_SCROLLING);// 始终处于自动滚动状态text.setAutoScrollingCount(Text.AUTO_SCROLLING_FOREVER);// 启动跑马灯效果text.startAutoScrolling(); 图7 跑马灯效果 场景示例 利用文本组件实现一个标题栏和详细内容的界面。 图8 界面效果 源码示例： color_light_gray_element.xml： background_text.xml： "},"java-component-button.html":{"url":"java-component-button.html","title":"Button","keywords":"","body":"Button Button是一种常见的组件，点击可以触发对应的操作，通常由文本或图标组成，也可以由图标和文本共同组成。 图1 文本按钮 图2 图标按钮 图3 图标和文本共同组成的按钮 支持的XML属性 Button无自有的XML属性，共有XML属性继承自Text 创建Button 创建如下样式的按钮： 在layout目录下的xml文件中创建Button，并设置按钮的背景形状、颜色。 常用的背景如文本背景、按钮背景，通常采用XML格式放置在graphic目录下。 在“Project”窗口，打开“entry > src > main > resources > base”，右键点击“graphic”文件夹，选择“New > File”，命名为“background_button.xml”，在该文件中定义按钮的背景形状、颜色。 响应点击事件 按钮的重要作用是当用户单击按钮时，会执行相应的操作或者界面出现相应的变化。实际上用户点击按钮时，Button对象将收到一个点击事件。开发者可以自定义响应点击事件的方法。例如，通过创建一个Component.ClickedListener对象，然后通过调用setClickedListener将其分配给按钮。 Button button = (Button) findComponentById(ResourceTable.Id_button);// 为按钮设置点击事件回调button.setClickedListener(new Component.ClickedListener() { @Override public void onClick(Component component) { // 此处添加点击按钮后的事件处理逻辑 }}); 不同类型的按钮 按照按钮的形状，按钮可以分为：普通按钮，椭圆按钮，胶囊按钮，圆形按钮等。 普通按钮 普通按钮和其他按钮的区别在于不需要设置任何形状，只设置文本和背景颜色即可，例如： color_blue_element.xml： 椭圆按钮 椭圆按钮是通过设置background_element的来实现的，background_element的shape设置为椭圆（oval），例如： oval_button_element.xml: 胶囊按钮 胶囊按钮是一种常见的按钮，设置按钮背景时将背景设置为矩形形状，并且设置ShapeElement的radius的半径，例如： capsule_button_element.xml: 圆形按钮 圆形按钮和椭圆按钮的区别在于组件本身的宽度和高度需要相同，例如： circle_button_element.xml: 场景示例 利用圆形按钮，胶囊按钮，文本组件可以绘制出如下拨号盘的UI界面。 图4 界面效果 源码示例： color_light_gray_element.xml： green_text_element.xml： green_circle_button_element.xml： green_capsule_button_element.xml： "}}