{"./":{"url":"./","title":"鸿蒙OS开发文档","keywords":"","body":"手册简介 华为自有开源操作系统鸿蒙OS，鸿蒙OS凭借多终端开发IDE，多语言统一编译，分布式架构Kit提供屏幕布局控件以及交互的自动适配，支持控件拖拽，面向预览的可视化编程，从而使开发者可以基于同一工程高效构建多端自动运行App，实现真正的一次开发，多端部署，在跨设备之间实现共享生态。 "},"dao-du.html":{"url":"dao-du.html","title":"导读","keywords":"","body":""},"xi-tong-ding-yi.html":{"url":"xi-tong-ding-yi.html","title":"系统定义","keywords":"","body":"系统定义 HarmonyOS 是一款“面向未来”、面向全场景（移动办公、运动健康、社交通信、媒体娱乐等）的分布式操作系统。在传统的单设备系统能力的基础上，HarmonyOS 提出了基于同一套系统能力、适配多种终端形态的分布式理念，能够支持多种终端设备。 对消费者而言，HarmonyOS 能够将生活场景中的各类终端进行能力整合，形成一个“超级虚拟终端”，可以实现不同的终端设备之间的快速连接、能力互助、资源共享，匹配合适的设备、提供流畅的全场景体验。 对应用开发者而言，HarmonyOS 采用了多种分布式技术，使得应用程序的开发实现与不同终端设备的形态差异无关，降低了开发难度和成本。这能够让开发者聚焦上层业务逻辑，更加便捷、高效地开发应用。 对设备开发者而言，HarmonyOS 采用了组件化的设计方案，可以根据设备的资源能力和业务特征进行灵活裁剪，满足不同形态的终端设备对于操作系统的要求。 HarmonyOS提供了支持多种开发语言的API，供开发者进行应用开发。支持的开发语言包括Java、XML（Extensible Markup Language）、C/C++ 、 JS（JavaScript）、CSS（Cascading Style Sheets）和HML（HarmonyOS Markup Language）。 技术架构 HarmonyOS整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 > 子系统 > 功能/模块”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的子系统或功能/模块。HarmonyOS技术架构如下所示。 Play Video3192 内核层 内核子系统： HarmonyOS 采用多内核设计，支持针对不同资源受限设备选用适合的OS内核。内核抽象层（KAL，Kernel Abstract Layer）通过屏蔽多内核差异，对上层提供基础的内核能力，包括进程/线程管理、内存管理、文件系统、网络管理和外设管理等。 驱动子系统： 硬件驱动框架（HDF） 是 HarmonyOS 硬件生态开放的基础，提供统一外设访问能力和驱动开发、管理框架。 系统服务层 系统服务层是HarmonyOS的核心能力集合，通过框架层对应用程序提供服务。该层包含以下几个部分： 系统基本能力子系统集：为分布式应用在 HarmonyOS多设备上的运行、调度、迁移等操作提供了基础能力，由分布式软总线、分布式数据管理、分布式任务调度、方舟多语言运行时、公共基础库、多模输入、图形、安全、AI等子系统组成。其中，方舟运行时提供了C/C++/JS多语言运行时和基础的系统类库，也为使用方舟编译器静态化的Java程序（即应用程序或框架层中使用Java语言开发的部分）提供运行时。 基础软件服务子系统集：为HarmonyOS提供公共的、通用的软件服务，由事件通知、电话、多媒体、DFX（Design For X） 、MSDP&DV等子系统组成。 增强软件服务子系统集：为HarmonyOS提供针对不同设备的、差异化的能力增强型软件服务，由智慧屏专有业务、穿戴专有业务、IoT专有业务等子系统组成。 硬件服务子系统集：为HarmonyOS提供硬件服务，由位置服务、生物特征识别、穿戴专有硬件服务、IoT专有硬件服务等子系统组成。 根据不同设备形态的部署环境，基础软件服务子系统集、增强软件服务子系统集、硬件服务子系统集内部可以按子系统粒度裁剪，每个子系统内部又可以按功能粒度裁剪。 框架层 框架层为HarmonyOS应用开发提供了Java/C/C++/JS等多语言的用户程序框架和Ability框架，两种UI框架（包括适用于Java语言的Java UI框架、适用于JS语言的JS UI框架），以及各种软硬件服务对外开放的多语言框架API。根据系统的组件化裁剪程度，HarmonyOS设备支持的API也会有所不同。 应用层 应用层包括系统应用和第三方非系统应用。HarmonyOS的应用由一个或多个FA（Feature Ability）或PA（Particle Ability）组成。其中，FA有UI界面，提供与用户交互的能力；而PA无UI界面，提供后台运行任务的能力以及统一的数据访问抽象。FA在进行用户交互时所需的后台数据访问也需要由对应的PA提供支撑。基于FA/PA开发的应用，能够实现特定的业务功能，支持跨设备调度与分发，为用户提供一致、高效的应用体验。 "},"ji-zhu-te-zheng.html":{"url":"ji-zhu-te-zheng.html","title":"技术特征","keywords":"","body":"技术特性 硬件互助，资源共享 多种设备之间能够实现硬件互助、资源共享，依赖的关键技术包括分布式软总线、分布式设备虚拟化、分布式数据管理、分布式任务调度等。 分布式软总线 分布式软总线是手机、平板、智能穿戴、智慧屏、车机等分布式设备的通信基座，为设备之间的互联互通提供了统一的分布式通信能力，为设备之间的无感发现和零等待传输创造了条件。开发者只需聚焦于业务逻辑的实现，无需关注组网方式与底层协议。分布式软总线示意图见图1。 典型应用场景举例： 智能家居场景：在烹饪时，手机可以通过碰一碰和烤箱连接，并将自动按照菜谱设置烹调参数，控制烤箱来制作菜肴。与此类似，料理机、油烟机、空气净化器、空调、灯、窗帘等都可以在手机端显示并通过手机控制。设备之间即连即用，无需繁琐的配置。 多屏联动课堂：老师通过智慧屏授课，与学生开展互动，营造课堂氛围；学生通过手机完成课程学习和随堂问答。统一、全连接的逻辑网络确保了传输通道的高带宽、低时延、高可靠。 图1 分布式软总线示意图 分布式设备虚拟化 分布式设备虚拟化平台可以实现不同设备的资源融合、设备管理、数据处理，多种设备共同形成一个超级虚拟终端。针对不同类型的任务，为用户匹配并选择能力合适的执行硬件，让业务连续地在不同设备间流转，充分发挥不同设备的能力优势，如显示能力、摄像能力、音频能力、交互能力以及传感器能力等。分布式设备虚拟化示意图见图2。 典型应用场景举例： 视频通话场景：在做家务时接听视频电话，可以将手机与智慧屏连接，并将智慧屏的屏幕、摄像头与音箱虚拟化为本地资源，替代手机自身的屏幕、摄像头、听筒与扬声器，实现一边做家务、一边通过智慧屏和音箱来视频通话。 游戏场景：在智慧屏上玩游戏时，可以将手机虚拟化为遥控器，借助手机的重力传感器、加速度传感器、触控能力，为玩家提供更便捷、更流畅的游戏体验。 图2 分布式设备虚拟化示意图 分布式数据管理 分布式数据管理基于分布式软总线的能力，实现应用程序数据和用户数据的分布式管理。用户数据不再与单一物理设备绑定，业务逻辑与数据存储分离，跨设备的数据处理如同本地数据处理一样方便快捷，让开发者能够轻松实现全场景、多设备下的数据存储、共享和访问，为打造一致、流畅的用户体验创造了基础条件。分布式数据管理示意图见图3。 典型应用场景举例： 协同办公场景：将手机上的文档投屏到智慧屏，在智慧屏上对文档执行翻页、缩放、涂鸦等操作，文档的最新状态可以在手机上同步显示。 家庭出游场景：一家人出游时，妈妈用手机拍了很多照片。通过家庭照片共享，爸爸可以在自己的手机上浏览、收藏和保存这些照片，家中的爷爷奶奶也可以通过智慧屏浏览这些照片。 图3 分布式数据管理示意图 分布式任务调度 分布式任务调度基于分布式软总线、分布式数据管理、分布式Profile等技术特性，构建统一的分布式服务管理（发现、同步、注册、调用）机制，支持对跨设备的应用进行远程启动、远程调用、远程连接以及迁移等操作，能够根据不同设备的能力、位置、业务运行状态、资源使用情况，以及用户的习惯和意图，选择合适的设备运行分布式任务。 图4以应用迁移为例，简要地展示了分布式任务调度能力。 典型应用场景举例： 导航场景：如果用户驾车出行，上车前，在手机上规划好导航路线；上车后，导航自动迁移到车机和车载音箱；下车后，导航自动迁移回手机。如果用户骑车出行，在手机上规划好导航路线，骑行时手表可以接续导航。 外卖场景：在手机上点外卖后，可以将订单信息迁移到手表上，随时查看外卖的配送状态。 图4 分布式任务调度示意图 一次开发，多端部署 HarmonyOS提供了用户程序框架、Ability框架以及UI框架，支持应用开发过程中多终端的业务逻辑和界面逻辑进行复用，能够实现应用的一次开发、多端部署，提升了跨设备应用的开发效率。一次开发、多端部署示意图见图5。 其中，UI框架支持Java和JS两种开发语言，并提供了丰富的多态控件，可以在手机、平板、智能穿戴、智慧屏、车机上显示不同的UI效果。采用业界主流设计方式，提供多种响应式布局方案，支持栅格化布局，满足不同屏幕的界面适配能力。 图5 一次开发、多端部署示意图 统一OS，弹性部署 HarmonyOS通过组件化和小型化等设计方法，支持多种终端设备按需弹性部署，能够适配不同类别的硬件资源和功能需求。支撑通过编译链关系去自动生成组件化的依赖关系，形成组件树依赖图，支撑产品系统的便捷开发，降低硬件设备的开发门槛。 支持各组件的选择（组件可有可无） ：根据硬件的形态和需求，可以选择所需的组件。 支持组件内功能集的配置（组件可大可小） ：根据硬件的资源情况和功能需求，可以选择配置组件中的功能集。例如，选择配置图形框架组件中的部分控件。 支持组件间依赖的关联（平台可大可小） ：根据编译链关系，可以自动生成组件化的依赖关系。例如，选择图形框架组件，将会自动选择依赖的图形引擎组件等。 "},"xi-tong-an-quan.html":{"url":"xi-tong-an-quan.html","title":"系统安全","keywords":"","body":"系统安全 在搭载HarmonyOS的分布式终端上，可以保证“正确的人，通过正确的设备，正确地使用数据”。 通过“分布式多端协同身份认证”来保证“正确的人”。 通过“在分布式终端上构筑可信运行环境”来保证“正确的设备”。 通过“分布式数据在跨终端流动的过程中，对数据进行分类分级管理”来保证“正确地使用数据”。 正确的人 在分布式终端场景下，“正确的人”指通过身份认证的数据访问者和业务操作者。“正确的人”是确保用户数据不被非法访问、用户隐私不泄露的前提条件。HarmonyOS通过以下三个方面来实现协同身份认证： 零信任模型：HarmonyOS基于零信任模型，实现对用户的认证和对数据的访问控制。当用户需要跨设备访问数据资源或者发起高安全等级的业务操作（例如，对安防设备的操作）时，HarmonyOS会对用户进行身份认证，确保其身份的可靠性。 多因素融合认证：HarmonyOS通过用户身份管理，将不同设备上标识同一用户的认证凭据关联起来，用于标识一个用户，来提高认证的准确度。 协同互助认证：HarmonyOS、通过将硬件和认证能力解耦（即信息采集和认证可以在不同的设备上完成），来实现不同设备的资源池化以及能力的互助与共享，让高安全等级的设备协助低安全等级的设备完成用户身份认证。 正确的设备 在分布式终端场景下，只有保证用户使用的设备是安全可靠的，才能保证用户数据在虚拟终端上得到有效保护，避免用户隐私泄露。 安全启动确保源头每个虚拟设备运行的系统固件和应用程序是完整的、未经篡改的。通过安全启动，各个设备厂商的镜像包就不易被非法替换为恶意程序，从而保护用户的数据和隐私安全。 可信执行环境提供了基于硬件的可信执行环境（TEE，Trusted Execution Environment）来保护用户的个人敏感数据的存储和处理，确保数据不泄露。由于分布式终端硬件的安全能力不同，对于用户的敏感个人数据，需要使用高安全等级的设备进行存储和处理。HarmonyOS使用基于数学可证明的形式化开发和验证的TEE微内核，获得了商用OS内核CC EAL5+的认证评级。 设备证书认证支持为具备可信执行环境的设备预置设备证书，用于向其他虚拟终端证明自己的安全能力。对于有TEE环境的设备，通过预置PKI（Public Key Infrastructure）设备证书给设备身份提供证明，确保设备是合法制造生产的。设备证书在产线进行预置，设备证书的私钥写入并安全保存在设备的TEE环境中，且只在TEE内进行使用。在必须传输用户的敏感数据（例如密钥、加密的生物特征等信息）时，会在使用设备证书进行安全环境验证后，建立从一个设备的TEE到另一设备的TEE之间的安全通道，实现安全传输。如图1所示。 图1 设备证书使用示意图 正确地使用数据 在分布式终端场景下，需要确保用户能够正确地使用数据。HarmonyOS围绕数据的生成、存储、使用、传输以及销毁过程进行全生命周期的保护，从而保证个人数据与隐私、以及系统的机密数据（如密钥）不泄漏。 数据生成：根据数据所在的国家或组织的法律法规与标准规范，对数据进行分类分级，并且根据分类设置相应的保护等级。每个保护等级的数据从生成开始，在其存储、使用、传输的整个生命周期都需要根据对应的安全策略提供不同强度的安全防护。虚拟超级终端的访问控制系统支持依据标签的访问控制策略，保证数据只能在可以提供足够安全防护的虚拟终端之间存储、使用和传输。 数据存储：HarmonyOS通过区分数据的安全等级，存储到不同安全防护能力的分区，对数据进行安全保护，并提供密钥全生命周期的跨设备无缝流动和跨设备密钥访问控制能力，支撑分布式身份认证协同、分布式数据共享等业务。 数据使用：HarmonyOS通过硬件为设备提供可信执行环境。用户的个人敏感数据仅在分布式虚拟终端的可信执行环境中进行使用，确保用户数据的安全和隐私不泄露。 数据传输：为了保证数据在虚拟超级终端之间安全流转，需要各设备是正确可信的，建立了信任关系（多个设备通过华为帐号建立配对关系），并能够在验证信任关系后，建立安全的连接通道，按照数据流动的规则，安全地传输数据。当设备之间进行通信时，需要基于设备的身份凭据对设备进行身份认证，并在此基础上，建立安全的加密传输通道。 数据销毁：销毁密钥即销毁数据。数据在虚拟终端的存储，都建立在密钥的基础上。当销毁数据时，只需要销毁对应的密钥即完成了数据的销毁。 "},"ying-yong-ji-chu-zhi-shi.html":{"url":"ying-yong-ji-chu-zhi-shi.html","title":"应用基础知识","keywords":"","body":"应用基础知识 用户应用程序 用户应用程序泛指运行在设备的操作系统之上，为用户提供特定服务的程序，简称“应用”。 在HarmonyOS上运行的应用，有两种形态： 传统方式的需要安装的应用。 提供特定功能，免安装的应用（即 原子化服务 ）。 在HarmonyOS文档中，如无特殊说明，“应用”所指代的对象包括上述两种形态。 用户应用程序包结构 HarmonyOS的用户应用程序包以APPPack（Application Package）形式发布，它是由一个或多个HAP（HarmonyOS Ability Package）以及描述每个HAP属性的pack.info组成。HAP是Ability的部署包，HarmonyOS应用代码围绕Ability组件展开。 一个HAP是由代码、资源、第三方库及应用配置文件组成的模块包，可分为entry和feature两种模块类型，如图1所示。 entry ：应用的主模块。一个APP中，对于同一设备类型必须有且只有一个entry类型的HAP，可独立安装运行。 feature ：应用的动态特性模块。一个APP可以包含一个或多个feature类型的HAP，也可以不含。只有包含Ability的HAP才能够独立运行。 图1 APP逻辑视图 Ability Ability是应用所具备的能力的抽象，一个应用可以包含一个或多个Ability。Ability分为两种类型：FA（Feature Ability）和PA（Particle Ability）。FA/PA是应用的基本组成单元，能够实现特定的业务功能。FA有UI界面，而PA无UI界面。 库文件 库文件是应用依赖的第三方代码（例如so、jar、bin、har等二进制文件），存放在libs目录。 资源文件 应用的资源文件（字符串、图片、音频等）存放于resources目录下，便于开发者使用和维护，详见资源文件的分类。 配置文件 配置文件 (config.json) 是应用的Ability信息，用于声明应用的Ability，以及应用所需权限等信息，详见应用配置文件。 pack.info 描述应用软件包中每个HAP的属性，由IDE编译生成，应用市场根据该文件进行拆包和HAP的分类存储。HAP的具体属性包括： delivery-with-install: 表示该HAP是否支持随应用安装。 “true” 表示支持随应用安装； “false” 表示不支持随应用安装。 name：HAP文件名。 module-type：模块类型，entry或feature。 device-type：表示支持该HAP运行的设备类型。 HAR HAR（HarmonyOS Ability Resources）可以提供构建应用所需的所有内容，包括源代码、资源文件和config.json文件。HAR不同于HAP，HAR不能独立安装运行在设备上，只能作为应用模块的依赖项被引用。 "},"jian-jie.html":{"url":"jian-jie.html","title":"简介","keywords":"","body":"简介 应用的每个HAP的根目录下都存在一个“config.json”配置文件，文件内容主要涵盖以下三个方面： 应用的全局配置信息，包含应用的包名、生产厂商、版本号等基本信息。 应用在具体设备上的配置信息，包含应用的备份恢复、网络安全等能力。 HAP包的配置信息，包含每个Ability必须定义的基本属性（如包名、类名、类型以及Ability提供的能力），以及应用访问系统或其他应用受保护部分所需的权限等。 配置文件的组成 配置文件“config.json”采用JSON文件格式，其中包含了一系列配置项，每个配置项由属性和值两部分构成： 属性 属性出现顺序不分先后，且每个属性最多只允许出现一次。 值 每个属性的值为JSON的基本数据类型（数值、字符串、布尔值、数组、对象或者null类型）。如果属性值需要引用资源文件，可参见资源文件。 "},"pei-zhi-wen-jian-de-yuan-su.html":{"url":"pei-zhi-wen-jian-de-yuan-su.html","title":"配置文件的元素","keywords":"","body":"配置文件的元素 此部分提供配置文件“config.json”中所有属性的详细解释。 DevEco Studio提供了两种编辑“config.json”文件的方式。在“config.json”的编辑窗口中，可在右上角切换代码编辑视图或可视化编辑视图。 图1 config.json文件的可视化编辑视图 配置文件的内部结构 “config.json”由“app”、“deviceConfig”和“module”三个部分组成，缺一不可。配置文件的内部结构说明参见表1。 属性名称 含义 数据类型 是否可缺省 app 表示应用的全局配置信息。同一个应用的不同HAP包的“app”配置必须保持一致。 对象 否 deviceConfig 表示应用在具体设备上的配置信息。 对象 否 module 表示HAP包的配置信息。该标签下的配置只对当前HAP包生效。 对象 否 app对象的内部结构 app对象包含应用的全局配置信息，内部结构说明参见表2。 属性名称 子属性名称 含义 数据类型 是否可缺省 bundleName - 表示应用的包名，用于标识应用的唯一性。包名是由字母、数字、下划线（_）和点号（.）组成的字符串，必须以字母开头。支持的字符串长度为7~127字节。包名通常采用反域名形式表示（例如，com.huawei.himusic）。建议第一级为域名后缀“com”，第二级为厂商/个人名，第三级为应用名，也可以采用多级。 字符串 否 vendor - 表示对应用开发厂商的描述。字符串长度不超过255字节。 字符串 可缺省，缺省值为空。 version - 表示应用的版本信息。 对象 否 code 表示应用的版本号，仅用于HarmonyOS管理该应用，对用户不可见。取值为大于零的整数。 数值 否 name 表示应用的版本号，用于向用户呈现。取值可以自定义。 字符串 否 minCompatibleVersionCode 表示应用可兼容的最低版本号，用于在跨设备场景下，判断其他设备上该应用的版本是否兼容。 数值 可缺省，缺省值为code标签值。 apiVersion - 表示应用依赖的HarmonyOS的API版本。 对象 否 compatible 表示应用运行需要的API最小版本。取值为大于零的整数。 数值 否 target 表示应用运行需要的API目标版本。取值为大于零的整数。 数值 可缺省，缺省值为应用所在设备的当前API版本。 releaseType 表示应用运行需要的API目标版本的类型。取值为“CanaryN”、“BetaN”或者“Release”，其中，N代表大于零的整数。Canary：受限发布的版本。Beta：公开发布的Beta版本。Release：公开发布的正式版本。 字符串 可缺省，缺省值为“Release”。 multiFrameworkBundle - 表示应用是否为混合打包的HarmonyOS应用。混合打包场景配置为“true”，非混合打包场景配置为“false”。该标签值由IDE自动配置。 布尔类型 可缺省，缺省值为“false”。 smartWindowSize - 该标签用于在悬浮窗场景下表示应用的模拟窗口的尺寸。配置格式为“正整数*正整数”，单位为vp。正整数取值范围为[200,2000]。 字符串 可缺省，缺省值为空。 smartWindowDeviceType - 表示应用可以在哪些设备上使用模拟窗口打开。取值为：智能手机：phone平板：tablet智慧屏：tv 字符串数组 可缺省，缺省值为空。 targetBundleList - 表示允许以免安装方式拉起的其他HarmonyOS应用，列表取值为每个HarmonyOS应用的bundleName，多个bundleName之间用英文“,”区分，最多配置10个bundleName。如果被拉起的应用不支持免安装方式，则拉起失败。 字符串 否 app示例： \"app\": { \"bundleName\": \"com.huawei.hiworld.example\", \"vendor\": \"huawei\", \"version\": { \"code\": 2, \"name\": \"2.0\" } \"apiVersion\": { \"compatible\": 3, \"target\": 3, \"releaseType\": \"Beta1\" } } deviceConfig对象的内部结构 deviceConfig包含在具体设备上的应用配置信息，可以包含default、phone、tablet、tv、car、wearable、liteWearable和smartVision等属性。default标签内的配置是适用于所有设备通用，其他设备类型如果有特殊的需求，则需要在该设备类型的标签下进行配置。内部结构说明参见表3。 属性名称 含义 数据类型 是否可缺省 default 表示所有设备通用的应用配置信息。 对象 否 phone 表示手机类设备的应用信息配置。 对象 可缺省，缺省为空 tablet 表示平板的应用配置信息。 对象 可缺省，缺省为空。 tv 表示智慧屏特有的应用配置信息。 对象 可缺省，缺省为空。 car 表示车机特有的应用配置信息。 对象 可缺省，缺省为空。 wearable 表示智能穿戴特有的应用配置信息。 对象 可缺省，缺省为空。 liteWearable 表示轻量级智能穿戴特有的应用配置信息。 对象 可缺省，缺省为空。 smartVision 表示智能摄像头特有的应用配置信息。 对象 可缺省，缺省为空。 default、phone、tablet、tv、car、wearable、liteWearable和smartVision等对象的内部结构说明，可参见表4。 属性名称 含义 数据类型 是否可缺省 jointUserId 表示应用的共享userid。通常情况下，不同的应用运行在不同的进程中，应用的资源是无法共享。如果开发者的多个应用之间需要共享资源，则可以通过相同的jointUserId值实现，前提是这些应用的签名相同。该标签仅对系统应用生效，且仅适用于手机、平板、智慧屏、车机、智能穿戴。该字段在API Version 3及更高版本不再支持配置。 字符串 可缺省，缺省为空。 process 表示应用或者Ability的进程名。如果在“deviceConfig”标签下配置了“process”标签，则该应用的所有Ability都运行在这个进程中。 如果在“abilities”标签下也为某个Ability配置了“process”标签，则该Ability就运行在这个进程中。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为应用的软件包名。 supportBackup 表示应用是否支持备份和恢复。如果配置为“false”，则不支持为该应用执行备份或恢复操作。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省为“false”。 compressNativeLibs 表示libs库是否以压缩存储的方式打包到HAP包。如果配置为“false”，则libs库以不压缩的方式存储，HAP包在安装时无需解压libs，运行时会直接从HAP内加载libs库。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省为“true”。 network 表示网络安全性配置。该标签允许应用通过配置文件的安全声明来自定义其网络安全，无需修改应用代码。 对象 可缺省，缺省为空。 属性名称 含义 数据类型 是否可缺省 cleartextTraffic 表示是否允许应用使用明文网络流量（例如，明文HTTP）。true：允许应用使用明文流量的请求。false：拒绝应用使用明文流量的请求。 布尔类型 可缺省，缺省为“false”。 securityConfig 表示应用的网络安全配置信息。 对象 可缺省，缺省为空。 属性名称 子属性名称 含义 数据类型 是否可缺省 domainSettings - 表示自定义的网域范围的安全配置，支持多层嵌套，即一个domainSettings对象中允许嵌套更小网域范围的domainSettings对象。 对象 可缺省，缺省为空。 cleartextPermitted 表示自定义的网域范围内是否允许明文流量传输。当usesCleartext和securityConfig同时存在时，自定义网域是否允许明文流量传输以cleartextPermitted的取值为准。true：允许明文流量传输。false：拒绝明文流量传输。 布尔类型 否 domains 表示域名配置信息，包含两个参数：subdomains和name。subdomains（布尔类型）：表示是否包含子域名。如果为 “true”，此网域规则将与相应网域及所有子网域（包括子网域的子网域）匹配。否则，该规则仅适用于精确匹配项。name（字符串）：表示域名名称。 对象数组 否 deviceConfig示例： \"deviceConfig\": { \"default\": { \"process\": \"com.huawei.hiworld.example\", \"supportBackup\": false, \"network\": { \"cleartextTraffic\": true, \"securityConfig\": { \"domainSettings\": { \"cleartextPermitted\": true, \"domains\": [ { \"subDomains\": true, \"name\": \"example.ohos.com\" } ] } } } } } module对象的内部结构 module对象包含HAP包的配置信息，内部结构说明参见表7。 属性名称 含义 数据类型 是否可缺省 mainAbility 表示HAP包的入口ability名称。该标签的值应配置为“module > abilities”中存在的Page类型ability的名称。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 如果存在page类型的ability，则该字段不可缺省。 package 表示HAP的包结构名称，在应用内应保证唯一性。采用反向域名格式（建议与HAP的工程目录保持一致）。字符串长度不超过127字节。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 否 name 表示HAP的类名。采用反向域名方式表示，前缀需要与同级的package标签指定的包名一致，也可采用“.”开头的命名方式。字符串长度不超过255字节。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 否 description 表示HAP的描述信息。字符串长度不超过255字节。如果字符串超出长度或者需要支持多语言，可以采用资源索引的方式添加描述内容。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。 supportedModes 表示应用支持的运行模式。当前只定义了驾驶模式（drive）。该标签仅适用于车机。 字符串数组 可缺省，缺省值为空。 deviceType 表示允许Ability运行的设备类型。系统预定义的设备类型包括：phone（手机）、tablet（平板）、tv（智慧屏）、car（车机）、wearable（智能穿戴）、liteWearable（轻量级智能穿戴）等。 字符串数组 否 distro 表示HAP发布的具体描述。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 对象 否 metaData 表示HAP的元信息。 对象 可缺省，缺省值为空。 abilities 表示当前模块内的所有Ability。采用对象数组格式，其中每个元素表示一个Ability对象。 对象数组 可缺省，缺省值为空。 js 表示基于JS UI框架开发的JS模块集合，其中的每个元素代表一个JS模块的信息。 对象数组 可缺省，缺省值为空。 shortcuts 表示应用的快捷方式信息。采用对象数组格式，其中的每个元素表示一个快捷方式对象。 对象数组 可缺省，缺省值为空。 defPermissions 表示应用定义的权限。应用调用者必须申请这些权限，才能正常调用该应用。 对象数组 可缺省，缺省值为空。 reqPermissions 表示应用运行时向系统申请的权限。 对象数组 可缺省，缺省值为空。 colorMode 表示应用自身的颜色模式。dark：表示按照深色模式选取资源。light：表示按照浅色模式选取资源。auto：表示跟随系统的颜色模式值选取资源。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为“auto”。 theme 表示应用的主题，标签值为自定义主题资源的索引，或系统资源的索引。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。 entryTheme 表示内部主题的关键字，标签值配置为该名称对应的资源索引。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。 resizeable 表示应用是否支持多窗口特性。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“true”。 module示例： \"module\": { \"mainAbility\": \"MainAbility\", \"package\": \"com.example.myapplication.entry\", \"name\": \".MyOHOSAbilityPackage\", \"description\": \"$string:description_application\", \"supportedModes\": [ \"drive\" ], \"deviceType\": [ \"car\" ], \"distro\": { \"deliveryWithInstall\": true, \"moduleName\": \"ohos_entry\", \"moduleType\": \"entry\" }, \"abilities\": [ ... ], \"shortcuts\": [ ... ], \"js\": [ ... ], \"reqPermissions\": [ ... ], \"defPermissions\": [ ... ], \"colorMode\": \"light\"} 属性名称 含义 数据类型 是否可缺省 deliveryWithInstall 表示当前HAP是否支持随应用安装。true：支持随应用安装。false：不支持随应用安装。说明该属性建议设置为true。设置false可能导致最终应用上架应用市场异常。 布尔类型 否 moduleName 表示当前HAP的名称。 字符串 否 moduleType 表示当前HAP的类型，包括两种类型：entry和feature。 字符串 否 installationFree 表示当前该FA是否支持免安装特性。true：表示支持免安装特性，且符合免安装约束。false：表示不支持免安装特性。 布尔类型 entry.hap可缺省，feature.hap不可缺省。 distro示例： \"distro\": { \"deliveryWithInstall\": true, \"moduleName\": \"ohos_entry\", \"moduleType\": \"entry\", \"installationFree\": true} 属性名称 子属性名称 含义 数据类型 是否可缺省 parameters - 表示调用Ability时所有调用参数的元信息。每个调用参数的元信息由以下三个标签组成：description、name、type。 对象 可缺省，缺省值为空。 description 表示对调用参数的描述，可以是表示描述内容的字符串，也可以是对描述内容的资源索引以支持多语言。 字符串 可缺省，缺省值为空。 name 表示调用参数的名称。 字符串 可缺省，缺省值为空。 type 表示调用参数的类型，如Integer。 字符串 否 results - 表示Ability返回值的元信息。每个返回值的元信息由以下三个标签组成：description、name、type。 对象 可缺省，缺省值为空。 description 表示对返回值的描述，可以是表示描述内容的字符串，也可以是对描述内容的资源索引以支持多语言。 字符串 可缺省，缺省值为空。 name 表示返回值的名字。 字符串 可缺省，缺省值为空。 type 表示返回值的类型，如Integer。 字符串 否 customizeData - 表示父级组件的自定义元信息，parameters和results在module中不可配。 对象 可缺省，缺省值为空。 name 表示数据项的键名称，字符串类型（最大长度255字节）。 字符串 可缺省，缺省值为空。 value 表示数据项的值，字符串类型（最大长度255字节）。 字符串 可缺省，缺省值为空。 extra 表示用户自定义数据格式，标签值为标识该数据的资源的索引值。 字符串 可缺省，缺省值为空。 metaData示例： \"metaData\": { \"parameters\" : [{ \"name\" : \"string\", \"type\" : \"Float\", \"description\" : \"$string:parameters_description\" }], \"results\" : [{ \"name\" : \"string\", \"type\" : \"Float\", \"description\" : \"$string:results_description\" }], \"customizeData\" : [{ \"name\" : \"string\", \"value\" : \"string\", \"extra\" : \"$string:customizeData_description\" }]} 属性名称 含义 数据类型 是否可缺省 name 表示Ability名称。取值可采用反向域名方式表示，由包名和类名组成，如“com.example.myapplication.MainAbility”；也可采用“.”开头的类名方式表示，如“.MainAbility”。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。说明在使用DevEco Studio新建项目时，默认生成首个Ability的配置，包括生成“MainAbility.java”文件，及“config.json”中“MainAbility”的配置。如使用其他IDE工具，可自定义名称。 字符串 否 description 表示对Ability的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。 字符串 可缺省，缺省值为空。 icon 表示Ability图标资源文件的索引。取值示例：$media:ability_icon。如果在该Ability的“skills”属性中，“actions”的取值包含 “action.system.home”，“entities”取值中包含“entity.system.home”，则该Ability的icon将同时作为应用的icon。如果存在多个符合条件的Ability，则取位置靠前的Ability的icon作为应用的icon。说明应用的“icon”和“label”是用户可感知配置项，需要区别于当前所有已有的应用“icon”或“label”（至少有一个不同）。 字符串 可缺省，缺省值为空。 label 表示Ability对用户显示的名称。取值可以是Ability名称，也可以是对该名称的资源索引，以支持多语言。如果在该Ability的“skills”属性中，“actions”的取值包含 “action.system.home”，“entities”取值中包含“entity.system.home”，则该Ability的label将同时作为应用的label。如果存在多个符合条件的Ability，则取位置靠前的Ability的label作为应用的label。说明应用的“icon”和“label”是用户可感知配置项，需要区别于当前所有已有的应用“icon”或“label”（至少有一个不同）。 字符串 可缺省，缺省值为空。 uri 表示Ability的统一资源标识符。格式为[scheme:][//authority][path][?query][#fragment]。 字符串 可缺省，对于data类型的Ability不可缺省。 launchType 表示Ability的启动模式，支持“standard”和“singleton”两种模式：standard：表示该Ability可以有多实例。“standard”模式适用于大多数应用场景。singleton：表示该Ability只可以有一个实例。例如，具有全局唯一性的呼叫来电界面即采用“singleton”模式。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为“standard”。 visible 表示Ability是否可以被其他应用调用。true：可以被其他应用调用。false：不能被其他应用调用。 布尔类型 可缺省，缺省值为“false”。 permissions 表示其他应用的Ability调用此Ability时需要申请的权限。通常采用反向域名格式，取值可以是系统预定义的权限，也可以是开发者自定义的权限。如果是自定义权限，取值必须与“defPermissions”标签中定义的某个权限的“name”标签值一致。 字符串数组 可缺省，缺省值为空。 skills 表示Ability能够接收的Intent的特征。 对象数组 可缺省，缺省值为空。 deviceCapability 表示Ability运行时要求设备具有的能力，采用字符串数组的格式表示。 字符串数组 可缺省，缺省值为空。 metaData 表示Ability的元信息。调用Ability时调用参数的元信息，例如：参数个数和类型。Ability执行完毕返回值的元信息，例如：返回值个数和类型。该标签仅适用于智慧屏、智能穿戴、车机。 对象 可缺省，缺省值为空。 type 表示Ability的类型。取值范围如下：page：表示基于Page模板开发的FA，用于提供与用户交互的能力。service：表示基于Service模板开发的PA，用于提供后台运行任务的能力。data：表示基于Data模板开发的PA，用于对外部提供统一的数据访问抽象。CA：表示支持其他应用以窗口方式调起该Ability。 字符串 否 orientation 表示该Ability的显示模式。该标签仅适用于page类型的Ability。取值范围如下：unspecified：由系统自动判断显示方向。landscape：横屏模式。portrait：竖屏模式。followRecent：跟随栈中最近的应用。 字符串 可缺省，缺省值为“unspecified”。 backgroundModes 表示后台服务的类型，可以为一个服务配置多个后台服务类型。该标签仅适用于service类型的Ability。取值范围如下：dataTransfer：通过网络/对端设备进行数据下载、备份、分享、传输等业务。audioPlayback：音频输出业务。audioRecording：音频输入业务。pictureInPicture：画中画、小窗口播放视频业务。voip：音视频电话、VOIP业务。location：定位、导航业务。bluetoothInteraction：蓝牙扫描、连接、传输业务。wifiInteraction：WLAN扫描、连接、传输业务。screenFetch：录屏、截屏业务。 字符串数组 可缺省，缺省值为空。 readPermission 表示读取Ability的数据所需的权限。该标签仅适用于data类型的Ability。取值为长度不超过255字节的字符串。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为空。 writePermission 表示向Ability写数据所需的权限。该标签仅适用于data类型的Ability。取值为长度不超过255字节的字符串。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为空。 configChanges 表示Ability关注的系统配置集合。当已关注的配置发生变更后，Ability会收到onConfigurationUpdated回调。取值范围：locale：表示语言区域发生变更。layout：表示屏幕布局发生变更。fontSize：表示字号发生变更。orientation：表示屏幕方向发生变更。density：表示显示密度发生变更。 字符串数组 可缺省，缺省为空。 mission 表示Ability指定的任务栈。该标签仅适用于page类型的Ability。默认情况下应用中所有Ability同属一个任务栈。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为应用的包名。 targetAbility 表示当前Ability重用的目标Ability。该标签仅适用于page类型的Ability。如果配置了targetAbility属性，则当前Ability（即别名Ability）的属性中仅“name”、“icon”、“label”、“visible”、“permissions”、“skills”生效，其它属性均沿用targetAbility中的属性值。目标Ability必须与别名Ability在同一应用中，且在配置文件中目标Ability必须在别名之前进行声明。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。表示当前Ability不是一个别名Ability。 multiUserShared 表示Ability是否支持多用户状态进行共享，该标签仅适用于data类型的Ability。配置为“true”时，表示在多用户下只有一份存储数据。需要注意的是，该属性会使visible属性失效。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“false”。 supportPipMode 表示Ability是否支持用户进入PIP模式（用于在在页面最上层悬浮小窗口，俗称“画中画”，常见于视频播放等场景）。该标签仅适用于page类型的Ability。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“false”。 formsEnabled 表示Ability是否支持卡片（forms）功能。该标签仅适用于page类型的Ability。true：支持卡片能力。false：不支持卡片能力。 布尔类型 可缺省，缺省值为“false”。 forms 表示服务卡片的属性。该标签仅当“formsEnabled”为“true”时，才能生效。 对象数组 可缺省，缺省值为空。 resizeable 表示Ability是否支持多窗口特性。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“true”。 abilities示例： \"abilities\": [ { \"name\": \".MainAbility\", \"description\": \"himusic main ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"permissions\": [ ], \"visible\": true, \"skills\": [ { \"actions\": [ \"action.system.home\" ], \"entities\": [ \"entity.system.home\" ] } ], \"configChanges\": [ \"locale\", \"layout\", \"fontSize\", \"orientation\" ], \"type\": \"page\" }, { \"name\": \".PlayService\", \"description\": \"himusic play ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"visible\": false, \"skills\": [ { \"actions\": [ \"action.play.music\", \"action.stop.music\" ], \"entities\": [ \"entity.audio\" ] } ], \"type\": \"service\", \"backgroundModes\": [ \"audioPlayback\" ] }, { \"name\": \".UserADataAbility\", \"type\": \"data\", \"uri\": \"dataability://com.huawei.hiworld.himusic.UserADataAbility\", \"visible\": true }] 属性名称 子属性名称 含义 数据类型 是否可缺省 actions - 表示能够接收的Intent的action值，可以包含一个或多个action。取值通常为系统预定义的action值，详见《API参考》中的ohos.aafwk.content.Intent类。 字符串数组 可缺省，缺省值为空。 entities - 表示能够接收的Intent的Ability的类别（如视频、桌面应用等），可以包含一个或多个entity。取值通常为系统预定义的类别，详见《API参考》中的ohos.aafwk.content.Intent类，也可以自定义。 字符串数组 可缺省，缺省值为空。 uris - 表示能够接收的Intent的uri，可以包含一个或者多个uri。 对象数组 可缺省，缺省值为空。 scheme 表示uri的scheme值。 字符串 不可缺省。 host 表示uri的host值。 字符串 可缺省，缺省值为空。 port 表示uri的port值。 字符串 可缺省，缺省值为空。 path 表示uri的path值。 字符串 可缺省，缺省值为空。 type 表示uri的type值。 字符串 可缺省，缺省值为空。 skills示例： \"skills\": [ { \"actions\": [ \"action.system.home\" ], \"entities\": [ \"entity.system.home\" ], \"uris\": [ { \"scheme\": \"http\", \"host\": \"www.xxx.com\", \"port\": \"8080\", \"path\": \"query/student/name\", \"type\": \"text/*\" } ] }] 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示JS Component的名字。该标签不可缺省，默认值为default。 字符串 否 pages - 表示JS Component的页面用于列举JS Component中每个页面的路由信息[页面路径+页面名称]。该标签不可缺省，取值为数组，数组第一个元素代表JS FA首页。 数组 否 window - 用于定义与显示窗口相关的配置。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 对象 可缺省。 designWidth 表示页面设计基准宽度。以此为基准，根据实际设备宽度来缩放元素大小。 数值 可缺省，缺省值为750px。 autoDesignWidth 表示页面设计基准宽度是否自动计算。当配置为true时，designWidth将会被忽略，设计基准宽度由设备宽度与屏幕密度计算得出。 布尔类型 可缺省，缺省值为“false”。 type - 表示JS应用的类型。取值范围如下：normal：标识该JS Component为应用实例。form：标识该JS Component为卡片实例。 字符串 可缺省，缺省值为“normal”。 js示例： \"js\": [ { \"name\": \"default\", \"pages\": [ \"pages/index/index\", \"pages/detail/detail\" ], \"window\": { \"designWidth\": 750, \"autoDesignWidth\": false }, \"type\": \"form\" }] 属性名称 子属性名称 含义 数据类型 是否可缺省 shortcutId - 表示快捷方式的ID。字符串的最大长度为63字节。 字符串 否 label - 表示快捷方式的标签信息，即快捷方式对外显示的文字描述信息。取值可以是描述性内容，也可以是标识label的资源索引。字符串最大长度为63字节。 字符串 可缺省，缺省为空。 intents - 表示快捷方式内定义的目标intent信息集合，每个intent可配置两个子标签，targetClass, targetBundle。 - 可缺省，缺省为空。 targetClass 表示快捷方式目标类名。 字符串 可缺省，缺省值为空。 targetBundle 表示快捷方式目标Ability所在应用的包名。 字符串 可缺省，缺省值为空。 shortcuts示例： \"shortcuts\": [ { \"shortcutId\": \"id\", \"label\": \"$string:shortcut\", \"intents\": [ { \"targetBundle\": \"com.huawei.hiworld.himusic\", \"targetClass\": \"com.huawei.hiworld.himusic.entry.MainAbility\" } ] }] 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示卡片的类名。字符串最大长度为127字节。 字符串 否 description - 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。 isDefault - 表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。true：默认卡片。false：非默认卡片。 布尔值 否 type - 表示卡片的类型。取值范围如下：Java：Java卡片。JS：JS卡片。 字符串 否 colorMode - 表示卡片的主题样式，取值范围如下：auto：自适应。dark：深色主题。light：浅色主题。 字符串 可缺省，缺省值为“auto”。 supportDimensions - 表示卡片支持的外观规格，取值范围：12：表示1行2列的二宫格。22：表示2行2列的四宫格。24：表示2行4列的八宫格。44：表示4行4列的十六宫格。 字符串数组 否 defaultDimension - 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否 landscapeLayouts - 表示卡片外观规格对应的横向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 portraitLayouts - 表示卡片外观规格对应的竖向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 updateEnabled - 表示卡片是否支持周期性刷新，取值范围：true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。false：表示不支持周期性刷新。 布尔类型 否 scheduledUpdateTime - 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 字符串 可缺省，缺省值为“0:0”。 updateDuration - 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。 数值 可缺省，缺省值为“0”。 formConfigAbility - 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。 jsComponentName - 表示JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。 字符串 否 metaData - 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。 customizeData - 表示自定义的卡片信息。 对象数组 可缺省，缺省值为空。 name 表示数据项的键名称。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 value 表示数据项的值。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 forms示例： \"forms\": [ { \"name\": \"Form_Js\", \"description\": \"It's Js Form\", \"type\": \"JS\", \"jsComponentName\": \"card\", \"colorMode\": \"auto\", \"isDefault\": true, \"updateEnabled\": true, \"scheduledUpdateTime\": \"11:00\", \"updateDuration\": 1, \"defaultDimension\": \"2*2\", \"supportDimensions\": [ \"2*2\", \"2*4\", \"4*4\" ] }, { \"name\": \"Form_Java\", \"description\": \"It's Java Form\", \"type\": \"Java\", \"colorMode\": \"auto\", \"isDefault\": false, \"updateEnabled\": true, \"scheduledUpdateTime\": \"21:05\", \"updateDuration\": 1, \"defaultDimension\": \"1*2\", \"supportDimensions\": [ \"1*2\" ], \"landscapeLayouts\": [ \"$layout:ability_form\" ], \"portraitLayouts\": [ \"$layout:ability_form\" ], \"formConfigAbility\": \"ability://com.example.myapplication.fa/.MainAbility\", \"metaData\": { \"customizeData\": [ { \"name\": \"originWidgetName\", \"value\": \"com.huawei.weather.testWidget\" } ] } }] HAP与HAR的配置文件的合并 如果应用模块中调用了HAR，在编译构建HAP时，需要将HAP的“config.json”文件与一个或多个HAR的“config.json”文件，合并为一个“config.json”文件。在合并过程中，不同文件的同一个标签的取值可能发生冲突，此时，需要通过配置mergeRule来解决冲突。 配置文件合并规则 HAP与HAR的“config.json”文件合并时，需要将HAR的配置信息全部合并到HAP的配置文件。合并规则参见表15。 HAP的优先级总是高于HAR。当HAP依赖于多个HAR时，先加载的HAR的优先级高于后加载的HAR，按照HAR的加载顺序依次合并到HAP文件。 序号 HAP HAR 合并结果 1 无标签值。 无标签值。 无标签值。 2 有标签值，取值为A。 无标签值。 有标签值，取值为A。 3 无标签值。 有标签值，取值为B。 有标签值，取值为B。 4 有标签值，取值为A。 有标签值，取值为A。 有标签值，取值为A。 5 有标签值，取值为A。 有标签值，取值为B。 冲突，需要添加mergeRule，详见mergeRule对象的使用。 mergeRule对象的使用 mergeRule通常在HAP的“config.json”文件中使用，可以在“abilities”、“defPermissions”、 “reqPermissions”、“js”等属性中添加。不同属性的合并策略，详见表16。 注意 HAR配置文件中不能包含“action.system.home”和“entity.system.home”配置项，否则会导致编译报错。 abilities对象中“name”字段的取值，必须为完整的类名，否则会导致合并出错。 属性名称 合并规则 一级 二级 三级 app - - 只保留HAP的“config.json”文件中的app对象。 deviceConfig - - 只保留HAP的“config.json”文件中的deviceConfig对象。 module package - 只保留HAP的“config.json”文件中的取值。 name - 只保留HAP的“config.json”文件中的取值。 description - 只保留HAP的“config.json”文件中的取值。 supportedModes - 只保留HAP的“config.json”文件中的取值。 deviceType - 只保留HAP的“config.json”文件中的取值。 distro - 只保留HAP的“config.json”文件中的取值。 shortcuts - 只保留HAP的“config.json”文件中的取值。 defPermissions - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 reqPermissions - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 js - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 abilities - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 permissions 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 skills 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 backgroundModes 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 configChanges 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 targetAbility 如果“targetAbility”与“abilities”中的“name”冲突，则导致编译报错。 其他 “abilities”中的其他属性如果发生合并冲突，则需要添加“mergeRule”字段。 属性名称 含义 数据类型 是否可缺省 remove 表示HAP与HAR的“config.json”文件合并时，需要移除的标签。 字符串数组 是 replace 表示HAP与HAR的“config.json”文件合并冲突时，需要替换的标签，始终保留高优先级的值。 字符串数组 是 mergeRule的使用示例： 在下面的示例中，HAP与HAR中的Ability的“name”取值相同，需要对两者“config.json”文件中的Ability进行合并。由于两个文件中的部分字段（例如“launchType”）存在冲突，需要在HAP的“abilities”标签下添加“mergeRule”。 合并前HAP的 “config.json” 文件，如下所示： 其中，remove表示合并后需要移除的子标签，replace表示合并后需要替换的子标签（HAP替换HAR）。 \"abilities\": [ { \"mergeRule\": { \"remove\": [\"orientation\"], \"replace\": [\"launchType\"] } \"name\": \"com.harmony.myapplication.entry.MainAbility\", \"type\": \"page\", \"launchType\": \"standard\", \"visible\": false }], 合并前HAR的 “config.json” 文件，如下所示： \"abilities\": [ { \"name\": \"com.harmony.myapplication.entry.MainAbility\", \"type\": \"page\", \"launchType\": \"singleton\", \"orientation\": \"portrait\", \"visible\": false }], 将上述两个 “config.json” 文件按照mergeRule进行合并，处理完成后mergeRule字段也会被移除。合并后的结果文件，如下所示： \"abilities\": [ { \"name\": \"com.harmony.myapplication.entry.MainAbility\", \"type\": \"page\", \"launchType\": \"standard\", \"visible\": false }], bundleName占位符的使用 HAR的“config.json”文件中多处需要使用包名，例如自定义权限、自定义action等场景，但是包名只有当HAR编译到HAP时才能确定下来。在编译之前，HAR中的包名可以采用占位符来表示，采用{bundleName}形式。 支持bundleName占位符的标签有actions、entities、permissions、readPermission、writePermission、defPermissions.name、uri。 使用示例： HAR中自定义action时，使用{bundleName}来代替包名。如下所示： \"skills\": [ { \"actions\": [ \"{bundleName}.ACTION_PLAY\" ], \"entities\": [ \"{bundleName}.ENTITY_PLAY\" ], }], 将HAP编译到bundleName为 “com.huawei.hiworld” 的HAP包后，原来的{bundleName}将被替换为HAP的实际包名。替换后的结果如下所示： \"app\": { \"bundleName\": \"com.huawei.hiworld\", ……},\"module\": { \"abilities\": [ { \"skills\": [ { \"actions\": [ \"com.huawei.hiworld.ACTION_PLAY\" ], \"entities\": [ \"com.huawei.hiworld.ENTITY_PLAY\" ], } ], "},"pei-zhi-wen-jian-shi-li.html":{"url":"pei-zhi-wen-jian-shi-li.html","title":"配置文件示例","keywords":"","body":"配置文件示例 以JSON文件为config.json的一个简单示例，该示例的应用声明为三个Ability。 { \"app\": { \"bundleName\": \"com.huawei.hiworld.himusic\", \"vendor\": \"huawei\", \"version\": { \"code\": 2, \"name\": \"2.0\" }, \"apiVersion\": { \"compatible\": 3, \"target\": 3, \"releaseType\": \"Beta1\" } }, \"deviceConfig\": { \"default\": { } }, \"module\": { \"mainAbility\": \"MainAbility\", \"package\": \"com.huawei.hiworld.himusic.entry\", \"name\": \".MainApplication\", \"supportedModes\": [ \"drive\" ], \"distro\": { \"moduleType\": \"entry\", \"deliveryWithInstall\": true, \"moduleName\": \"hap-car\" }, \"deviceType\": [ \"car\" ], \"abilities\": [ { \"name\": \".MainAbility\", \"description\": \"himusic main ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"visible\": true, \"skills\": [ { \"actions\": [ \"action.system.home\" ], \"entities\": [ \"entity.system.home\" ] } ], \"type\": \"page\", \"formsEnabled\": false }, { \"name\": \".PlayService\", \"description\": \"himusic play ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"visible\": false, \"skills\": [ { \"actions\": [ \"action.play.music\", \"action.stop.music\" ], \"entities\": [ \"entity.audio\" ] } ], \"type\": \"service\", \"backgroundModes\": [ \"audioPlayback\" ] }, { \"name\": \".UserADataAbility\", \"type\": \"data\", \"uri\": \"dataability://com.huawei.hiworld.himusic.UserADataAbility\", \"visible\": true } ], \"reqPermissions\": [ { \"name\": \"ohos.permission.DISTRIBUTED_DATASYNC\", \"reason\": \"\", \"usedScene\": { \"ability\": [ \"com.huawei.hiworld.himusic.entry.MainAbility\", \"com.huawei.hiworld.himusic.entry.PlayService\" ], \"when\": \"inuse\" } } ] } } "},"zi-yuan-wen-jian-de-fen-lei.html":{"url":"zi-yuan-wen-jian-de-fen-lei.html","title":"资源文件的分类","keywords":"","body":"资源文件的分类 更新时间: 2021-06-02 21:03 resources目录 应用的资源文件（字符串、图片、音频等）统一存放于resources目录下，便于开发者使用和维护。resources目录包括两大类目录，一类为base目录与限定词目录，另一类为rawfile目录，详见表1。 资源目录示例： resources|---base // 默认存在的目录| |---element| | |---string.json| |---media| | |---icon.png|---en_GB-vertical-car-mdpi // 限定词目录示例，需要开发者自行创建 | |---element| | |---string.json| |---media| | |---icon.png|---rawfile // 默认存在的目录 分类 base目录与限定词目录 rawfile目录 组织形式 按照两级目录形式来组织，目录命名必须符合规范，以便根据设备状态去匹配相应目录下的资源文件。一级子目录为base目录和限定词目录。base目录是默认存在的目录。当应用的resources资源目录中没有与设备状态匹配的限定词目录时，会自动引用该目录中的资源文件。限定词目录需要开发者自行创建。目录名称由一个或多个表征应用场景或设备特征的限定词组合而成，具体要求参见限定词目录。二级子目录为资源目录，用于存放字符串、颜色、布尔值等基础元素，以及媒体、动画、布局等资源文件，具体要求参见资源组目录。 支持创建多层子目录，目录名称可以自定义，文件夹内可以自由放置各类资源文件。rawfile目录的文件不会根据设备状态去匹配不同的资源。 编译方式 目录中的资源文件会被编译成二进制文件，并赋予资源文件ID。 目录中的资源文件会被直接打包进应用，不经过编译，也不会被赋予资源文件ID。 引用方式 通过指定资源类型（type）和资源名称（name）来引用，详见资源文件的引用方法。 通过指定文件路径和文件名来引用，详见资源文件的引用方法。 限定词目录 限定词目录可以由一个或多个表征应用场景或设备特征的限定词组合而成，包括移动国家码和移动网络码、语言、文字、国家或地区、横竖屏、设备类型、颜色模式和屏幕密度等维度，限定词之间通过下划线（_）或者中划线（-）连接。开发者在创建限定词目录时，需要掌握限定词目录的命名要求以及与限定词目录与设备状态的匹配规则。 限定词目录的命名**要求** 限定词的组合顺序：移动国家码移动网络码-语言文字_国家或地区-横竖屏-设备类型-深色模式-屏幕密度。开发者可以根据应用的使用场景和设备特征，选择其中的一类或几类限定词组成目录名称。 限定词的连接方式：语言、文字、国家或地区之间采用下划线（）连接，移动国家码和移动网络码之间也采用下划线（）连接，除此之外的其他限定词之间均采用中划线（-）连接。例如：zh_Hant_CN、zh_CN-car-ldpi。 限定词的取值范围：每类限定词的取值必须符合 表2 中的条件，否则，将无法匹配目录中的资源文件。 限定词类型 含义与取值说明 移动国家码和移动网络码 移动国家码（MCC）和移动网络码（MNC）的值取自设备注册的网络。MCC后面可以跟随MNC，使用下划线（）连接，也可以单独使用。例如：mcc460表示中国，mcc460_mnc00表示中国中国移动。详细取值范围，请查阅ITU-T E.212（国际电联相关标准）。 语言 表示设备使用的语言类型，由2~3个小写字母组成。例如：zh表示中文，en表示英语，mai表示迈蒂利语。详细取值范围，请查阅ISO 639（ISO制定的语言编码标准）。 文字 表示设备使用的文字类型，由1个大写字母（首字母）和3个小写字母组成。例如：Hans表示简体中文，Hant表示繁体中文。详细取值范围，请查阅ISO 15924（ISO制定的文字编码标准）。 国家或地区 表示用户所在的国家或地区，由2~3个大写字母或者3个数字组成。例如：CN表示中国，GB表示英国。详细取值范围，请查阅ISO 3166-1（ISO制定的国家和地区编码标准）。 横竖屏 表示设备的屏幕方向，取值如下：vertical：竖屏horizontal：横屏 设备类型 表示设备的类型，取值如下：phone：手机tablet：平板car：车机tv：智慧屏wearable：智能穿戴 颜色模式 表示设备的颜色模式，取值如下：dark：深色模式light：浅色模式 屏幕密度 表示设备的屏幕密度（单位为dpi），取值如下：sdpi：表示小规模的屏幕密度（Small-scale Dots Per Inch），适用于dpi取值为(0, 120]的设备。mdpi：表示中规模的屏幕密度（Medium-scale Dots Per Inch），适用于dpi取值为(120, 160]的设备。ldpi：表示大规模的屏幕密度（Large-scale Dots Per Inch），适用于dpi取值为(160, 240]的设备。xldpi：表示特大规模的屏幕密度（Extra Large-scale Dots Per Inch），适用于dpi取值为(240, 320]的设备。xxldpi：表示超大规模的屏幕密度（Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(320, 480]的设备。xxxldpi：表示超特大规模的屏幕密度（Extra Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(480, 640]的设备。 限定词目录与设备状态的匹配规则 在为设备匹配对应的资源文件时，限定词目录匹配的优先级从高到低依次为：移动国家码和移动网络码 > 区域（语言文字国家或地区）> 横竖屏 > 设备类型 > 颜色模式 > 屏幕密度。 如果限定词目录中包含移动国家码和移动网络码、语言、文字、横竖屏、设备类型、颜色模式限定词，则对应限定词的取值必须与当前的设备状态完全一致，该目录才能够参与设备的资源匹配。例如，限定词目录“zh_CN-car-ldpi”不能参与“en_US”设备的资源匹配。 资源组目录 base目录与限定词目录下面可以创建资源组目录（包括element、media、animation、layout、graphic、profile），用于存放特定类型的资源文件，详见表3。 资源组目录 目录说明 资源文件 element 表示元素资源，以下每一类数据都采用相应的JSON文件来表征。boolean，布尔型color，颜色float，浮点型intarray，整型数组integer，整型pattern，样式plural，复数形式strarray，字符串数组string，字符串 element目录中的文件名称建议与下面的文件名保持一致。每个文件中只能包含同一类型的数据。boolean.jsoncolor.jsonfloat.jsonintarray.jsoninteger.jsonpattern.jsonplural.jsonstrarray.jsonstring.json media 表示媒体资源，包括图片、音频、视频等非文本格式的文件。 文件名可自定义，例如：icon.png。 animation 表示动画资源，采用XML文件格式。 文件名可自定义，例如：zoom_in.xml。 layout 表示布局资源，采用XML文件格式。 文件名可自定义，例如：home_layout.xml。 graphic 表示可绘制资源，采用XML文件格式。 文件名可自定义，例如：notifications_dark.xml。 profile 表示其他类型文件，以原始文件形式保存。 文件名可自定义。 创建资源文件 在resources目录下，可按照限定词目录和资源组目录的说明创建子目录和目录内的文件。 同时，DevEco Studio也提供了创建资源目录和资源文件的界面。 创建资源目录及资源文件 在resources目录右键菜单选择“New > Harmony Resource File”，此时可同时创建目录和文件。 文件默认创建在base目录的对应资源组下。如果选择了限定词，则会按照命名规范自动生成限定词+资源组目录，并将文件创建在目录中。 目录名自动生成，格式固定为“限定词.资源组”，例如创建一个限定词为横竖屏类别下的竖屏，资源组为绘制资源的目录，自动生成的目录名称为“vertical.graphic”。 创建资源目录 在resources目录右键菜单选择“New > Harmony Resource Directory”，此时可创建资源目录。 选择资源组类型，设置限定词，创建后自动生成目录名称。目录名称格式固定为“限定词.资源组”，例如创建一个限定词为横竖屏类别下的竖屏，资源组为绘制资源的目录，自动生成的目录名称为“vertical.graphic”。 创建资源文件 在资源目录的右键菜单选择“New > XXX Resource File”，即可创建对应资源组目录的资源文件。 例如，在element目录下可新建Element Resource File。 "},"zi-yuan-wen-jian-de-shi-yong.html":{"url":"zi-yuan-wen-jian-de-shi-yong.html","title":"资源文件的使用","keywords":"","body":"资源文件的使用 更新时间: 2021-06-02 21:03 资源文件的引用方法 base目录与限定词目录中的资源文件：通过指定资源类型（type）和资源名称（name）来引用。 Java文件引用资源文件的格式： ResourceTable.type_ name 。特别地，如果引用的是系统资源，则采用： ohos.global.systemres.ResourceTable.type_name 。 示例一：在Java文件中，引用 string.json 文件中类型为“String”、名称为“app_name”的资源。 ohos.global.resource.ResourceManager resManager = this.getResourceManager();String result = resManager.getElement(ResourceTable.String_app_name).getString(); 示例二：在Java文件中，引用 color.json 文件中类型为“Color”、名称为“red”的资源。 ohos.global.resource.ResourceManager resManager = this.getResourceManager();int color = resManager.getElement(ResourceTable.Color_red).getColor(); XML文件引用资源文件的格式： $type:name 。特别地，如果引用的是系统资源，则采用： $ohos:type:name 。 在XML文件中，引用string.json文件中类型为“String”、名称为“app_name”的资源，示例如下： rawfile目录中的资源文件：通过指定文件路径和文件名称来引用。 在Java文件中，引用一个路径为“resources/rawfile/”、名称为“example.js”的资源文件，示例如下： ohos.global.resource.ResourceManager resManager = this.getResourceManager();ohos.global.resource.RawFileEntry rawFileEntry = resManager.getRawFileEntry(\"resources/rawfile/example.js\"); 系统资源文件 目前支持的部分系统资源文件详见表1。 系统资源名称 含义 类型 ic_app 表示HarmonyOS应用的默认图标。 媒体 request_location_reminder_title 表示“请求使用设备定位功能”的提示标题。 字符串 request_location_reminder_content 表示“请求使用设备定位功能”的提示内容，即：请在下拉快捷栏打开\"位置信息\"开关。 字符串 颜色模式的定义 应用可以在config.json的module字段下定义“colorMode”字段，“colorMode”字段用来定义应用自身的颜色模式，值可以是“dark”，“light”，“auto”（默认值）。示例： \"colorMode\": \"light\" 当应用的颜色模式值是“dark”时，无论系统当前颜色模式是什么，应用始终会按照深色模式选取资源；同理，当应用的颜色模式值是“light”时，无论系统当前颜色模式是什么，应用始终会按照浅色模式选取资源；当应用的颜色模式值是“auto”时，应用会跟随系统的颜色模式值选取资源。应用可以在代码中通过如下方式获取应用当前的颜色模式： int colorMode = Configuration.colorMode; 为Element资源文件添加注释或特殊标识 Element目录下的不同种类元素的资源均采用JSON文件表示，资源的名称“name”和取值“value”是每一条资源的必备字段。 如果需要为某一条资源备注信息，以便于资源的理解和使用，可以通过comment字段添加注释。 如果value字段中的部分文本不需要被翻译人员处理，也不会被显示在应用界面上，可以通过特殊结构来标识无需翻译的内容。 通过comment字段添加注释 通过comment字段，可以为JSON文件的资源添加注释。示例如下： { \"string\":[ { \"name\":\"message_arrive\", \"value\":\"We will arrive at %s\", \"comment\":\"Transfer Arrival Time. %s is time,like 5:00 am\" } ]} 通过特殊结构来标识无需翻译的内容 在string、strarray、plural这三类资源中，可以通过特殊标识来处理无需被翻译的内容。例如，一个字符串资源的Value取值为“We will arrive at %s”，其中的变量“%s”在翻译过程中希望保持不变。有以下两种方式处理： 方式一：在value字段中添加{}。示例如下： { \"string\":[ { \"name\":\"message_arrive\", \"value\":[\"We will arrive at\",{ \"id\":\"time\", \"example\":\"5:00 am\", \"value\":\"%s\" } ] } ]} 方式二：添加标记对。示例如下： { \"string\":[ { \"name\":\"message_arrive\", \"value\":\"We will arrive at %s\" } ]} boolean.json示例 { \"boolean\":[ { \"name\":\"boolean_1\", \"value\":true }, { \"name\":\"boolean_ref\", \"value\":\"$boolean:boolean_1\" } ]} color.json示例 { \"color\":[ { \"name\":\"red\", \"value\":\"#ff0000\" }, { \"name\":\"red_ref\", \"value\":\"$color:red\" } ]} float.json示例 { \"float\":[ { \"name\":\"float_1\", \"value\":\"30.6\" }, { \"name\":\"float_ref\", \"value\":\"$float:float_1\" }, { \"name\":\"float_px\", \"value\":\"100px\" } ]} intarray.json示例 { \"intarray\":[ { \"name\":\"intarray_1\", \"value\":[ 100, 200, \"$integer:integer_1\" ] } ]} integer.json示例 { \"integer\":[ { \"name\":\"integer_1\", \"value\":100 }, { \"name\":\"integer_ref\", \"value\":\"$integer:integer_1\" } ]} pattern.json示例 { \"pattern\":[ { \"name\":\"base\", \"value\":[ { \"name\":\"width\", \"value\":\"100vp\" }, { \"name\":\"height\", \"value\":\"100vp\" }, { \"name\":\"size\", \"value\":\"25px\" } ] }, { \"name\":\"child\", \"parent\":\"base\", \"value\":[ { \"name\":\"noTitile\", \"value\":\"Yes\" } ] } ]} plural.json示例 { \"plural\":[ { \"name\":\"eat_apple\", \"value\":[ { \"quantity\":\"one\", \"value\":\"%d apple\" }, { \"quantity\":\"other\", \"value\":\"%d apples\" } ] } ]} strarray.json示例 { \"strarray\":[ { \"name\":\"size\", \"value\":[ { \"value\":\"small\" }, { \"value\":\"$string:hello\" }, { \"value\":\"large\" }, { \"value\":\"extra large\" } ] } ]} string.json示例 { \"string\":[ { \"name\":\"hello\", \"value\":\"hello base\" }, { \"name\":\"app_name\", \"value\":\"my application\" }, { \"name\":\"app_name_ref\", \"value\":\"$string:app_name\" }, { \"name\":\"app_sys_ref\", \"value\":\"$ohos:string:request_location_reminder_title\" } ]} "},"guo-ji-hua.html":{"url":"guo-ji-hua.html","title":"国际化","keywords":"","body":"国际化能力的支持 时间日期国际化 不同的区域具有不同的时间日期显示习惯。例如，英语（美国）区域short时间格式为“9:31 AM”；简体中文（中国）区域short时间格式为“上午9:31”；芬兰语（芬兰）区域short时间格式为“9.31”。因此为开发者提供了获取不同区域的时间日期规格的能力。 界面时间日期字串和时间类控件显示，应当遵循当地习惯的规则，当需要展示时间或日期时，建议获取当前地区的时间日期规格，并对显示的字串根据获取到的规格进行格式化后再使用。 示例1： Locale locale = new Locale(\"de\", \"CH\");String skeleton = \"MMMMd\";String bestPattern = DateFormatUtil.getBestPattern(skeleton, locale); // 返回值为\"d. MMMM\" 示例2： String languageTag = \"zh\";String out = DateFormatUtil.format(\"EEEEdMMMMy\", languageTag, \"Asia/Shanghai\", 0, 3600 * 1000); // 返回值为\"1970年1月1日星期四\" 电话号码国际化 不同的区域的电话号码有不同的格式化效果，当需要展示本地电话号码时，应遵循当地电话号码的格式化原则。因此为开发者提供了对不同地区电话号码格式化的能力，以便于在显示电话号码时正确的格式化。并提供了获取电话号码归属地的能力，开发者可以使用相关接口获取电话号码的归属地信息。 示例1： InputFormatter formatter = InputFormatter.getInstance(\"CN\");formatter.inputNumberAndRememberPosition('1'); // 返回值为\"1\"formatter.inputNumber('5'); // 返回值为\"15\"formatter.inputNumber('6'); // 返回值为\"156\"formatter.inputNumberAndRememberPosition('1');// 返回值为\"156 1\" 示例2： Locale.Builder builder = new Locale.Builder();builder.setLanguage(\"zh\");builder.setRegion(\"CN\");builder.setScript(\"Hant\");Locale locale = builder.build();String displayName = PhoneNumberAttribution.getAttribute(\"+8615611xxxxxx\", \"CN\", locale); // x为任意数字，返回值为\"北京市\" 文本识别 提供了对地址、时间日期与电话号码的文本识别能力，可以调用相关接口识别一段文本中包含的地址、时间日期与电话号码。 示例： // 当Locale.getDefault().getLanguage()为\"en\"时String source = \"it is 123 test St\";int[] re = TextRecognitionUtils.getAddress(source);if (re[0] == 1) { result = source.substring(re[1], re[2] + 1);// 返回值为\"123 main St\"} 度量衡格式化 提供了对度量衡国际化能力的支持，可支持度量衡体系和维度之间的转换，与不同国家度量衡体系的自动转换。在开发包含度量衡的功能时，可以调用此能力满足多语言和不同国家用户的需求。 示例1： Locale zhCN = Locale.CHINA;MeasureFormatter mes = MeasureFormatter.getInstance(zhCN);mes.format(MeasureOptions.Unit.AREA_UK_ACRE, 10000, MeasureOptions.Usage.AREA_LAND_AGRICULT, MeasureOptions.FormatStyle.WIDE, MeasureOptions.Style.AUTO_STYLE_ON));// 返回值为\"4,046.856公顷\" 示例2： Locale enUS = Locale.US;MeasureFormatter mes = MeasureFormatter.getInstance(enUS);mes.format(MeasureOptions.Unit.VOLUME_US_CUP, 1000, MeasureOptions.Unit.VOLUME_SI_LITER, MeasureOptions.FormatStyle.WIDE));// 返回值为\"236.588 liters\" 敏感禁忌 提供对政治敏感地区、城市、及语言的获取能力，以及对地区名称更正的能力。 示例： Locale locale = Locale.getDefault();ArrayList result = LocaleHelperUtils.getBlockedRegions(context, locale);//返回值包含\"EH\"与\"XK\"(西撒哈拉与科索沃），这两个地区为有政治争议的地区需谨慎使用 "},"ying-yong-shu-ju-guan-li.html":{"url":"ying-yong-shu-ju-guan-li.html","title":"应用数据管理","keywords":"","body":"应用数据管理 HarmonyOS应用数据管理支持单设备的各种结构化数据的持久化，以及跨设备之间数据的同步、共享以及搜索功能。开发者通过应用数据管理，能够方便地完成应用程序数据在不同终端设备间的无缝衔接，满足用户跨设备使用数据的一致性体验。 本地应用数据管理 提供单设备上结构化数据的存储和访问能力。使用SQLite作为持久化存储引擎，提供了多种类型的本地数据库，分别是关系型数据库（Relational Database）和对象关系映射数据库（Object Relational Mapping Database），此外还提供一种轻量级偏好数据库（Light Weight Preference Database），用以满足开发人员使用不同数据模型对应用数据进行持久化和访问的需求。 有关于本地应用数据管理的详细信息，请参阅关系型数据库、对象关系映射数据库和轻量级偏好数据库。 分布式数据服务 分布式数据库支持用户数据跨设备相互同步，为用户提供在多种终端设备上一致的数据访问体验。通过调用分布式数据接口，应用可以将数据保存到分布式数据库中。通过结合帐号、应用唯一标识和数据库三元组，分布式数据库对属于不同应用的数据进行隔离。 有关于分布式数据库的详细信息，请参阅分布式数据服务。 分布式文件服务 在多个终端设备间为单个设备上应用程序创建的文件提供多终端的分布式共享能力。每台设备上都存储一份全量的文件元数据，应用程序通过文件元数据中的路径，可以实现同一应用文件的跨设备访问。 有关于分布式文件的详细信息，请参阅分布式文件服务。 数据搜索服务 在单个设备上，为应用程序提供搜索引擎级的全文索引管理、建立索引和搜索功能。 有关于数据搜索的详细信息，请参阅融合搜索。 数据存储管理 为应用开发者提供系统存储路径、存储设备列表，存储设备属性的查询和管理功能。 有关于数据存储的详细信息，请参阅数据存储管理。 "},"ying-yong-quan-xian-guan-li.html":{"url":"ying-yong-quan-xian-guan-li.html","title":"应用权限管理","keywords":"","body":"应用权限管理 HarmonyOS中所有的应用均在应用沙盒内运行。默认情况下，应用只能访问有限的系统资源，系统负责管理应用对资源的访问权限。 应用权限管理是由接口提供方（Ability）、接口使用方（应用）、系统（包括云侧和端侧）以及用户等多方共同参与的整个流程，保证受限接口是在约定好的规则下被正常使用，避免接口被滥用而导致用户、应用和设备受损。 本节重点介绍应用权限管理的基本思想。有关权限使用的详细信息，请参阅权限。 权限声明 应用需要在config.json中使用“reqPermissions”属性对需要的权限逐个进行声明。 若使用到的三方库也涉及权限使用，也需统一在应用的config.json中逐个声明。 没有在config.json中声明的权限，应用就无法获得此权限的授权。 动态申请敏感权限 动态申请敏感权限基于用户可知可控的原则，需要应用在运行时主动调用系统动态申请权限的接口，系统弹框由用户授权，用户结合应用运行场景的上下文，识别出应用申请相应敏感权限的合理性，从而做出正确的选择。 即使用户向应用授予了请求的权限，应用在调用受此权限管控的接口前，也应该先检查自己有无此权限，而不能把之前授予的状态持久化，因为用户在动态授予后还可以通过设置取消应用的权限。 有关于应用动态申请敏感权限的详细信息，请参阅动态申请权限。 自定义权限 HarmonyOS为了保证应用对外提供的接口不被恶意调用，需要对调用接口的调用者进行鉴权。 大多情况下，系统已定义的权限满足了应用的基本需要，若有特殊的访问控制需要，应用可在config.json中以\"defPermissions\": []属性来定义新的权限，并通过“availableScope”和“grantMode”两个属性分别确定权限的开放范围和授权方式，使得权限定义更加灵活且易于理解。有关HarmonyOS权限开放范围和授权方式详细的描述，请参阅权限授予方式字段说明和权限限制范围字段说明。 为了避免应用自定义新权限出现重名的情况，建议应用对新权限的命名以包名的前两个字段开头，这样可以防止不同开发者的应用间出现自定义权限重名的情况。 权限保护方法 保护Ability：通过在config.json里对应的Ability中配置\"permissions\": [\"权限名\"]属性，即可实现保护整个Ability的目的，无指定权限的应用不能访问此Ability。 保护API：若Ability对外提供的数据或能力有多种，且开放范围或保护级别也不同，可以针对不同的数据或能力在接口代码实现中通过verifyPermission(String permissionName, int pid, int uid)来对uid标识的调用者进行鉴权。 权限使用原则 权限申请最小化。跟用户提供的功能无关的权限，不要申请；尽量采用其他无需权限的操作来实现相应功能（如：通过intent拉起系统UI界面由用户交互、应用自己生成uuid代替设备ID等）。 权限申请完整。应用所需权限（包括应用调用到的三方库依赖的权限）都要逐个在应用的config.json中按格式声明。 满足用户可知。应用申请的敏感权限的目的需要真实准确告知用户。 权限就近申请。应用在用户触发相关业务功能时，就近提示用户授予实现此功能所需的权限。 权限不扩散。在用户未授权的情况下，不允许提供给其他应用使用。 应用自定义权限防止重名。建议以包名为前缀来命名权限，防止跟系统定义的权限重名。 "},"ying-yong-yin-si-bao-hu.html":{"url":"ying-yong-yin-si-bao-hu.html","title":"应用隐私保护","keywords":"","body":"应用隐私保护 更新时间: 2021-06-04 15:12 随着移动终端及其相关业务（如移动支付、终端云等）的普及，用户隐私保护的重要性愈发突出。应用开发者在产品设计阶段就需要考虑用户隐私的保护，提高应用的安全性。HarmonyOS应用开发需要遵从其隐私保护规则，在应用上架应用市场时，应用市场会根据规则进行校验，如不满足条件则无法上架。 个人数据是指与一个身份已被识别或者身份可被识别的自然人相关的任何信息，包括但不限于个人身份信息、身份验证信息、财务和付款信息、联系方式、用户搜索、浏览记录、使用习惯、位置信息、短信和通话相关数据、麦克风数据、摄像头数据以及其他设备或应用使用情况数据等，其中敏感个人数据是个人数据的一个重要子集，指的是涉及数据主体的最私密领域的信息或者一旦泄露可能会给数据主体造成重大不利影响的数据，如导致个人名誉、身心健康受到损害或歧视性待遇等；敏感个人数据在各国家/地区相关法律法规中的定义有所不同，建议根据当地的法律法规要求处理。 数据收集及使用公开透明 应用采集个人数据时，应清晰、明确地告知用户，并确保告知用户的个人信息将被如何使用。 应用申请操作系统 敏感权限 时，需要明确告知用户权限申请的目的和用途，并获取用户的同意；敏感权限弹框参考示例如下。权限API使用方案请参考 权限 章节。详细的设计原则请参考 隐私设计 。 图1 敏感权限获取弹框示例 开发者应制定并遵从适当的隐私政策，在收集、使用留存和第三方分享用户数据时需要符合所有适用法律、政策和规定。如在收集个人数据前，需充分告知用户处理个人数据的种类、目的、处理方式、保留期限等，满足数据主体权利等要求。 应用向第三方披露任何个人信息须在隐私政策中说明披露内容、目的和披露对象。 根据以上要求，我们设计了示例以供参考。隐私通知/声明的参考示例如下： 图2 应用隐私通知与隐私声明示例图 个人数据应当基于具体、明确、合法的目的收集，不应与此目的不相符的方式作进一步处理。对于收集目的变更和用户撤销同意后再次使用的场景都需要用户重新同意。隐私声明变更与隐私声明撤销同意如图所示。 图3 隐私声明变更示例图 图4 隐私声明撤销同意示例图 应用需要提供用户查看隐私声明的入口。例如在应用的“关于”界面提供查看隐私声明的入口，如示例图所示： 图5 隐私声明的查看界面示例图 应用的隐私声明应覆盖本应用所有收集的个人数据。 在后台持续读取位置信息场景时，请申请ohos.permission.LOCATION_IN_BACKGROUND权限，详见敏感权限； 应用存在调用第三方的元能力（Particle Ability）或元服务（Feature Ability）场景时，需要在应用的隐私声明中明确第三方责任，如涉及个人数据收集则需要告知用户第三方的名称及收集的个人数据类型、目的和方式，申请的敏感权限、申请目的等。 数据收集及使用最小化 应用个人数据收集应与数据处理目的相关，且是适当、必要的。开发者应尽可能对个人数据进行匿名化或假名化处理，降低数据主体的风险。仅可收集和处理与特定目的相关且必需的个人数据，不能对数据做出与特定目的不相关的处理。 敏感权限申请的时候要满足权限最小化的要求，在进行权限申请时，只申请获取必需的信息或资源所需要的权限。如应用不需要相机权限就能够实现其功能时，则不应该向用户申请相机权限。 应用针对数据的收集要满足最小化要求，不收集与应用提供服务无关联的数据。如通信社交类应用，不应收集用户的网页浏览记录。 数据使用的功能要求能够使用户受益，收集的数据不能用于与用户正常使用无关的功能。如应用不得将“生物特征”、“健康数据”等敏感个人数据用于服务改进、投放广告或营销等非业务核心功能。 系统禁止应用在后台访问相机和麦克风的数据； 应用使用第三方支付交易过程中，如非适用法律要求或为提供第三方支付服务所必需，不得记录用户交易类鉴权信息，或向第三方批露与用户特定交易无关的用户个人信息。 应用不得仅出于广告投放或数据分析的目的而请求位置权限。 禁止在日志中打印敏感个人数据，如需要打印个人数据时，应对个人数据进行匿名化或假名化处理； 避免使用IMEI和序列号等永久性的标识符，尽量使用可以重置的标识符，如系统提供了NetworkID和DVID作为分布式场景下的设备标识符，广告业务场景下则建议使用OAID，基于应用的分析则建议使用ODID和AAID，其他需要唯一标识符的场景可以使用UUID接口生成； 不再需要使用的数据需要及时清除，降低数据泄露的风险。如分布式业务场景下设备断开分布式网络，临时缓存的数据需要及时删除。 数据处理选择和控制 对个人数据处理必须要征得用户的同意或遵守适用的法律法规，用户对其个人数据要有充分的控制权。 系统对于用户的敏感数据和系统关键资源的获取设置了对应的权限，应用访问这些数据时需要申请对应的权限。相关权限列表请参考应用权限列表章节。 应用申请使用敏感权限：应用弹窗提醒，向用户呈现应用需要获取的权限和权限使用目的、应用需要收集的数据和使用目的等，通过用户点击“同意”或“始终允许”的方式完成用户授权，让用户对应用权限的授予和个人数据的使用做到透明、可知、可控。 用户可以修改、取消授予应用的权限：当用户不同意某一权限或者数据收集时，应当允许用户使用与这部分权限和数据收集不相关的功能。如通信社交类应用，用户可以拒绝授予相机权限，不应该影响与相机无关的功能操作，如语音通话。 在进入应用的主界面之前不建议直接弹窗申请敏感权限，仅在用户使用功能时才请求对应的权限。如通信社交类应用，在没有启用位置相关的功能时，不建议在启动应用时就申请位置权限。 应用若使用个人数据用于个性化广告和精准营销，需提供独立的关闭选项。 需要向用户提供对个人数据的控制能力；如在云服务上存储了个人数据，需要提供删除数据的方法。 应用同时支持单设备和跨设备场景时，用户能够单独关闭跨设备应用场景。 数据安全 从技术上保证数据处理活动的安全性，包括个人数据的加密存储、安全传输等安全机制，应默认开启或采取安全保护措施。 数据存储 应用产生的密钥以及用户的敏感个人数据需要存储在应用的私有目录下。 应用可以调用系统提供的本地数据库RdbStore的加密接口对敏感个人数据进行加密存储。接口详见关系型数据库章节。 应用产生的分布式数据可以调用系统的分布式数据库进行存储，对于敏感个人数据需要采用分布式数据库提供的加密接口进行加密，接口详见分布式数据服务章节。 安全传输 需要分别针对本地传输和远程传输采取不同的安全保护措施。 本地传输： 应用通过intent跨应用传输数据时避免包含敏感个人数据，防止隐式调用导致intent劫持，导致个人数据泄露。 应用内组件调用应采用安全方式，避免通过隐式方式进行调用组件，防止组件劫持。 避免使用socket方式进行本地通信，如需使用，localhost端口号随机生成，并对端口连接对象进行身份认证和鉴权。 本地IPC通信安全：作为服务提供方需要校验服务使用方的身份和访问权限，防止服务使用方进行身份仿冒或者权限绕过。 远程传输： 使用https代替http进行通信，并对https证书进行严格校验。 避免进行远程端口进行通信，如需使用，需要对端口连接对象进行身份认证和鉴权。 应用进行跨设备通信时，需要校验被访问设备和应用的身份信息，防止被访问方的设备和应用进行身份仿冒。 应用进行跨设备通信时，作为服务提供方需要校验服务使用方的身份和权限，防止服务使用方进行身份仿冒或者权限绕过。 本地化处理 应用开发的数据优先在本地进行处理，对于本地无法处理的数据上传云服务要满足最小化的原则，不能默认选择上传云服务。 未成年人数据保护要求 如果应用是给未成年人设计的，或者应用通过收集的用户年龄数据识别出用户是未成年人，开发者应该结合目标市场国家的相关法律，专门分析未成年人个人数据保护的问题。收集未成年人数据前需要征得监护人的同意。 专为未成年人设计的应用不建议请求获取位置权限。 元服务（Feature Ability） 对于Visible=true的元服务，需要满足如下要求： 元服务启动时，需要在明显位置展示元服务的功能名称及开发者名称/logo。 元服务如涉及个人数据的收集，应提供独立的隐私声明，并在收集个人数据前向用户告知隐私声明。 元服务应按照法律法规要求收集个人数据，基于用户同意收集的个人数据，用户有权撤销同意。 元服务需要提供隐私声明的查看入口。 元服务隐私声明发生变更时，需要用户重新同意。 禁止在元服务免安装过程中捆绑安装与本服务不相关的功能，如扫描二维码的元服务不应该支持录音功能。 "},"san-fang-ying-yong-diao-yong-guan-kong-ji-zhi.html":{"url":"san-fang-ying-yong-diao-yong-guan-kong-ji-zhi.html","title":"三方应用调用管控机制","keywords":"","body":"三方应用调用管控机制 为什么要进行调用管控 后台进程启动过多，会消耗系统的内存、CPU等资源，造成用户设备耗电快、卡顿等现象。因此，为了保证用户体验，系统会对三方用户应用程序之间的PA调用进行管控，减少不必要的关联拉起。 相关概念 前台：用户应用程序有可见的FA正在显示，则认为用户应用程序在前台。 用户应用程序内调用：同一用户应用程序内的FA、PA之间的访问。 调用管控总体思路 用户应用程序内调用不管控。 三方用户应用程序间调用严格管控：禁止三方用户应用程序在后台调用其他三方应用的PA；严格管控三方用户应用程序在前台调用其他用户应用程序的PA。 管控规则 用户应用程序内调用 不管控。 三方用户应用程序间调用 三方应用程序A调用三方应用程序B的PA，具体限制如下： 禁止A在后台调用B的PA。 当B有进程存活时，允许A在前台调用B的PA；当B无进程存活时，禁止A的调用。 "},"kaifazhunbei.html":{"url":"kaifazhunbei.html","title":"开发准备","keywords":"","body":"开发准备 任务说明 本文档适用于HarmonyOS应用开发的初学者。通过构建一个简单的具有页面跳转功能的应用（如下图预览器运行效果所示），熟悉HarmonyOS应用开发流程。 为确保运行效果，请使用最新版本的DevEco Studio完成本任务，点击此处获取下载链接。 开发准备 开始前请参考下载与安装软件、配置开发环境，完成DevEco Studio的安装和开发环境的配置。 开发环境配置完成后，请参考创建和运行Hello World创建一个新工程，设备类型以“Phone”为例，使用Java语言开发，模板选择“Empty Feature Ability(Java)”。 工程创建完成后，使用预览器或Phone模拟器运行该工程。 完成上述操作后，请继续下一步的学习。 "},"diyigeyemian.html":{"url":"diyigeyemian.html","title":"编写第一个页面","keywords":"","body":"编写第一个页面 更新时间: 2021-06-02 21:03 在Java UI框架中，提供了两种编写布局的方式：在XML中声明UI布局和在代码中创建布局。这两种方式创建出的布局没有本质差别，为了熟悉两种方式，我们将通过XML的方式编写第一个页面，通过代码的方式编写第二个页面。 在“Project”窗口，点击“entry > src > main > resources > base > layout”，打开“ability_main.xml”文件。 第一个页面内有一个文本和一个按钮，使用DependentLayout布局，通过Text和Button组件来实现，其中vp和fp分别表示虚拟像素和字体像素。“ability_main.xml”的示例代码如下： 按钮的背景是蓝色胶囊样式，可以通过graphic目录下的XML文件来设置。 右键点击“graphic”文件夹，选择“New > File”，命名为“background_button.xml”，单击回车键。 “background_button.xml”的示例代码如下： 在layout目录下的“ability_main.xml”文件中，使用background_element=\"$graphic:background_button\"的方式引用“background_button.xml”文件： 在XML文件中添加组件后，需要在Java代码中加载XML布局。 在“Project”窗口，选择“entry > src > main > java > com.example.myapplication > slice” ，打开“MainAbilitySlice.java”文件，使用setUIContent方法加载“ability_main.xml”布局。 说明 HarmonyOS提供了Ability和AbilitySlice两个基础类，一个有界面的Ability可以由一个或多个AbilitySlice构成，AbilitySlice主要用于承载单个页面的具体逻辑实现和界面UI，是应用显示、运行和跳转的最小单元。 本文档以同一个Ability内的两个AbilitySlice之间的跳转为例，如果开发者希望实现两个Ability之间的跳转，请参考不同Page间导航。 “MainAbilitySlice.java”的示例代码如下： package com.example.myapplication.slice; import com.example.myapplication.ResourceTable;import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent; public class MainAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); // 加载XML布局 }} 使用预览器或模拟器运行项目，效果如下图所示。 "},"lingyigeyemian.html":{"url":"lingyigeyemian.html","title":"创建另一个页面","keywords":"","body":"创建另一个页面 在上一节中，我们用XML的方式编写了一个包含文本和按钮的页面。为了帮助开发者熟悉在代码中创建布局的方式，接下来我们使用代码的方式编写第二个页面。 在“Project”窗口，打开“entry > src > main > java > com.example.myapplication”，右键点击“slice”文件夹，选择“New > Java Class”，命名为“SecondAbilitySlice”，单击回车键。 第二个页面上有一个文本。在上一步创建的“SecondAbilitySlice”文件中，添加一个Text，示例代码如下： package com.example.myapplication.slice; import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.colors.RgbColor;import ohos.agp.components.DependentLayout;import ohos.agp.components.Text;import ohos.agp.components.element.ShapeElement;import ohos.agp.utils.Color;import ohos.agp.components.DependentLayout.LayoutConfig; public class SecondAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 声明布局 DependentLayout myLayout = new DependentLayout(this); // 设置布局宽高 myLayout.setWidth(LayoutConfig.MATCH_PARENT); myLayout.setHeight(LayoutConfig.MATCH_PARENT); // 设置布局背景为白色 ShapeElement background = new ShapeElement(); background.setRgbColor(new RgbColor(255, 255, 255)); myLayout.setBackground(background); // 创建一个文本 Text text = new Text(this); text.setText(\"Hi there\"); text.setWidth(LayoutConfig.MATCH_PARENT); text.setTextSize(100); text.setTextColor(Color.BLACK); // 设置文本的布局 DependentLayout.LayoutConfig textConfig = new DependentLayout.LayoutConfig(LayoutConfig.MATCH_CONTENT, LayoutConfig.MATCH_CONTENT); textConfig.addRule(LayoutConfig.CENTER_IN_PARENT); text.setLayoutConfig(textConfig); myLayout.addComponent(text); super.setUIContent(myLayout); }} "},"shi-xian-ye-mian-tiao-zhuan.html":{"url":"shi-xian-ye-mian-tiao-zhuan.html","title":"实现页面跳转","keywords":"","body":"实现页面跳转 打开第一个页面的“MainAbilitySlice.java”文件，添加按钮的响应逻辑，实现点击按钮跳转到下一页，示例代码如下： package com.example.myapplication.slice; import com.example.myapplication.ResourceTable; import ohos.aafwk.ability.AbilitySlice; import ohos.aafwk.content.Intent; import ohos.agp.components.Button; public class MainAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); Button button = (Button) findComponentById(ResourceTable.Id_button); // 点击按钮跳转至第二个页面 button.setClickedListener(listener -> present(new SecondAbilitySlice(), new Intent())); } } 再次运行项目，效果如下图所示。 恭喜你，至此已成功完成HarmonyOS快速入门。 "}}