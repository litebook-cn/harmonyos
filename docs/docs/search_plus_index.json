{"./":{"url":"./","title":"鸿蒙OS开发文档","keywords":"","body":"手册简介 华为自有开源操作系统鸿蒙OS，鸿蒙OS凭借多终端开发IDE，多语言统一编译，分布式架构Kit提供屏幕布局控件以及交互的自动适配，支持控件拖拽，面向预览的可视化编程，从而使开发者可以基于同一工程高效构建多端自动运行App，实现真正的一次开发，多端部署，在跨设备之间实现共享生态。 "},"dao-du.html":{"url":"dao-du.html","title":"导读","keywords":"","body":""},"xi-tong-ding-yi.html":{"url":"xi-tong-ding-yi.html","title":"系统定义","keywords":"","body":"系统定义 HarmonyOS 是一款“面向未来”、面向全场景（移动办公、运动健康、社交通信、媒体娱乐等）的分布式操作系统。在传统的单设备系统能力的基础上，HarmonyOS 提出了基于同一套系统能力、适配多种终端形态的分布式理念，能够支持多种终端设备。 对消费者而言，HarmonyOS 能够将生活场景中的各类终端进行能力整合，形成一个“超级虚拟终端”，可以实现不同的终端设备之间的快速连接、能力互助、资源共享，匹配合适的设备、提供流畅的全场景体验。 对应用开发者而言，HarmonyOS 采用了多种分布式技术，使得应用程序的开发实现与不同终端设备的形态差异无关，降低了开发难度和成本。这能够让开发者聚焦上层业务逻辑，更加便捷、高效地开发应用。 对设备开发者而言，HarmonyOS 采用了组件化的设计方案，可以根据设备的资源能力和业务特征进行灵活裁剪，满足不同形态的终端设备对于操作系统的要求。 HarmonyOS提供了支持多种开发语言的API，供开发者进行应用开发。支持的开发语言包括Java、XML（Extensible Markup Language）、C/C++ 、 JS（JavaScript）、CSS（Cascading Style Sheets）和HML（HarmonyOS Markup Language）。 技术架构 HarmonyOS整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 > 子系统 > 功能/模块”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的子系统或功能/模块。HarmonyOS技术架构如下所示。 Play Video3192 内核层 内核子系统： HarmonyOS 采用多内核设计，支持针对不同资源受限设备选用适合的OS内核。内核抽象层（KAL，Kernel Abstract Layer）通过屏蔽多内核差异，对上层提供基础的内核能力，包括进程/线程管理、内存管理、文件系统、网络管理和外设管理等。 驱动子系统： 硬件驱动框架（HDF） 是 HarmonyOS 硬件生态开放的基础，提供统一外设访问能力和驱动开发、管理框架。 系统服务层 系统服务层是HarmonyOS的核心能力集合，通过框架层对应用程序提供服务。该层包含以下几个部分： 系统基本能力子系统集：为分布式应用在 HarmonyOS多设备上的运行、调度、迁移等操作提供了基础能力，由分布式软总线、分布式数据管理、分布式任务调度、方舟多语言运行时、公共基础库、多模输入、图形、安全、AI等子系统组成。其中，方舟运行时提供了C/C++/JS多语言运行时和基础的系统类库，也为使用方舟编译器静态化的Java程序（即应用程序或框架层中使用Java语言开发的部分）提供运行时。 基础软件服务子系统集：为HarmonyOS提供公共的、通用的软件服务，由事件通知、电话、多媒体、DFX（Design For X） 、MSDP&DV等子系统组成。 增强软件服务子系统集：为HarmonyOS提供针对不同设备的、差异化的能力增强型软件服务，由智慧屏专有业务、穿戴专有业务、IoT专有业务等子系统组成。 硬件服务子系统集：为HarmonyOS提供硬件服务，由位置服务、生物特征识别、穿戴专有硬件服务、IoT专有硬件服务等子系统组成。 根据不同设备形态的部署环境，基础软件服务子系统集、增强软件服务子系统集、硬件服务子系统集内部可以按子系统粒度裁剪，每个子系统内部又可以按功能粒度裁剪。 框架层 框架层为HarmonyOS应用开发提供了Java/C/C++/JS等多语言的用户程序框架和Ability框架，两种UI框架（包括适用于Java语言的Java UI框架、适用于JS语言的JS UI框架），以及各种软硬件服务对外开放的多语言框架API。根据系统的组件化裁剪程度，HarmonyOS设备支持的API也会有所不同。 应用层 应用层包括系统应用和第三方非系统应用。HarmonyOS的应用由一个或多个FA（Feature Ability）或PA（Particle Ability）组成。其中，FA有UI界面，提供与用户交互的能力；而PA无UI界面，提供后台运行任务的能力以及统一的数据访问抽象。FA在进行用户交互时所需的后台数据访问也需要由对应的PA提供支撑。基于FA/PA开发的应用，能够实现特定的业务功能，支持跨设备调度与分发，为用户提供一致、高效的应用体验。 "},"ji-zhu-te-zheng.html":{"url":"ji-zhu-te-zheng.html","title":"技术特征","keywords":"","body":"技术特性 硬件互助，资源共享 多种设备之间能够实现硬件互助、资源共享，依赖的关键技术包括分布式软总线、分布式设备虚拟化、分布式数据管理、分布式任务调度等。 分布式软总线 分布式软总线是手机、平板、智能穿戴、智慧屏、车机等分布式设备的通信基座，为设备之间的互联互通提供了统一的分布式通信能力，为设备之间的无感发现和零等待传输创造了条件。开发者只需聚焦于业务逻辑的实现，无需关注组网方式与底层协议。分布式软总线示意图见图1。 典型应用场景举例： 智能家居场景：在烹饪时，手机可以通过碰一碰和烤箱连接，并将自动按照菜谱设置烹调参数，控制烤箱来制作菜肴。与此类似，料理机、油烟机、空气净化器、空调、灯、窗帘等都可以在手机端显示并通过手机控制。设备之间即连即用，无需繁琐的配置。 多屏联动课堂：老师通过智慧屏授课，与学生开展互动，营造课堂氛围；学生通过手机完成课程学习和随堂问答。统一、全连接的逻辑网络确保了传输通道的高带宽、低时延、高可靠。 图1 分布式软总线示意图 分布式设备虚拟化 分布式设备虚拟化平台可以实现不同设备的资源融合、设备管理、数据处理，多种设备共同形成一个超级虚拟终端。针对不同类型的任务，为用户匹配并选择能力合适的执行硬件，让业务连续地在不同设备间流转，充分发挥不同设备的能力优势，如显示能力、摄像能力、音频能力、交互能力以及传感器能力等。分布式设备虚拟化示意图见图2。 典型应用场景举例： 视频通话场景：在做家务时接听视频电话，可以将手机与智慧屏连接，并将智慧屏的屏幕、摄像头与音箱虚拟化为本地资源，替代手机自身的屏幕、摄像头、听筒与扬声器，实现一边做家务、一边通过智慧屏和音箱来视频通话。 游戏场景：在智慧屏上玩游戏时，可以将手机虚拟化为遥控器，借助手机的重力传感器、加速度传感器、触控能力，为玩家提供更便捷、更流畅的游戏体验。 图2 分布式设备虚拟化示意图 分布式数据管理 分布式数据管理基于分布式软总线的能力，实现应用程序数据和用户数据的分布式管理。用户数据不再与单一物理设备绑定，业务逻辑与数据存储分离，跨设备的数据处理如同本地数据处理一样方便快捷，让开发者能够轻松实现全场景、多设备下的数据存储、共享和访问，为打造一致、流畅的用户体验创造了基础条件。分布式数据管理示意图见图3。 典型应用场景举例： 协同办公场景：将手机上的文档投屏到智慧屏，在智慧屏上对文档执行翻页、缩放、涂鸦等操作，文档的最新状态可以在手机上同步显示。 家庭出游场景：一家人出游时，妈妈用手机拍了很多照片。通过家庭照片共享，爸爸可以在自己的手机上浏览、收藏和保存这些照片，家中的爷爷奶奶也可以通过智慧屏浏览这些照片。 图3 分布式数据管理示意图 分布式任务调度 分布式任务调度基于分布式软总线、分布式数据管理、分布式Profile等技术特性，构建统一的分布式服务管理（发现、同步、注册、调用）机制，支持对跨设备的应用进行远程启动、远程调用、远程连接以及迁移等操作，能够根据不同设备的能力、位置、业务运行状态、资源使用情况，以及用户的习惯和意图，选择合适的设备运行分布式任务。 图4以应用迁移为例，简要地展示了分布式任务调度能力。 典型应用场景举例： 导航场景：如果用户驾车出行，上车前，在手机上规划好导航路线；上车后，导航自动迁移到车机和车载音箱；下车后，导航自动迁移回手机。如果用户骑车出行，在手机上规划好导航路线，骑行时手表可以接续导航。 外卖场景：在手机上点外卖后，可以将订单信息迁移到手表上，随时查看外卖的配送状态。 图4 分布式任务调度示意图 一次开发，多端部署 HarmonyOS提供了用户程序框架、Ability框架以及UI框架，支持应用开发过程中多终端的业务逻辑和界面逻辑进行复用，能够实现应用的一次开发、多端部署，提升了跨设备应用的开发效率。一次开发、多端部署示意图见图5。 其中，UI框架支持Java和JS两种开发语言，并提供了丰富的多态控件，可以在手机、平板、智能穿戴、智慧屏、车机上显示不同的UI效果。采用业界主流设计方式，提供多种响应式布局方案，支持栅格化布局，满足不同屏幕的界面适配能力。 图5 一次开发、多端部署示意图 统一OS，弹性部署 HarmonyOS通过组件化和小型化等设计方法，支持多种终端设备按需弹性部署，能够适配不同类别的硬件资源和功能需求。支撑通过编译链关系去自动生成组件化的依赖关系，形成组件树依赖图，支撑产品系统的便捷开发，降低硬件设备的开发门槛。 支持各组件的选择（组件可有可无） ：根据硬件的形态和需求，可以选择所需的组件。 支持组件内功能集的配置（组件可大可小） ：根据硬件的资源情况和功能需求，可以选择配置组件中的功能集。例如，选择配置图形框架组件中的部分控件。 支持组件间依赖的关联（平台可大可小） ：根据编译链关系，可以自动生成组件化的依赖关系。例如，选择图形框架组件，将会自动选择依赖的图形引擎组件等。 "},"xi-tong-an-quan.html":{"url":"xi-tong-an-quan.html","title":"系统安全","keywords":"","body":"系统安全 在搭载HarmonyOS的分布式终端上，可以保证“正确的人，通过正确的设备，正确地使用数据”。 通过“分布式多端协同身份认证”来保证“正确的人”。 通过“在分布式终端上构筑可信运行环境”来保证“正确的设备”。 通过“分布式数据在跨终端流动的过程中，对数据进行分类分级管理”来保证“正确地使用数据”。 正确的人 在分布式终端场景下，“正确的人”指通过身份认证的数据访问者和业务操作者。“正确的人”是确保用户数据不被非法访问、用户隐私不泄露的前提条件。HarmonyOS通过以下三个方面来实现协同身份认证： 零信任模型：HarmonyOS基于零信任模型，实现对用户的认证和对数据的访问控制。当用户需要跨设备访问数据资源或者发起高安全等级的业务操作（例如，对安防设备的操作）时，HarmonyOS会对用户进行身份认证，确保其身份的可靠性。 多因素融合认证：HarmonyOS通过用户身份管理，将不同设备上标识同一用户的认证凭据关联起来，用于标识一个用户，来提高认证的准确度。 协同互助认证：HarmonyOS、通过将硬件和认证能力解耦（即信息采集和认证可以在不同的设备上完成），来实现不同设备的资源池化以及能力的互助与共享，让高安全等级的设备协助低安全等级的设备完成用户身份认证。 正确的设备 在分布式终端场景下，只有保证用户使用的设备是安全可靠的，才能保证用户数据在虚拟终端上得到有效保护，避免用户隐私泄露。 安全启动确保源头每个虚拟设备运行的系统固件和应用程序是完整的、未经篡改的。通过安全启动，各个设备厂商的镜像包就不易被非法替换为恶意程序，从而保护用户的数据和隐私安全。 可信执行环境提供了基于硬件的可信执行环境（TEE，Trusted Execution Environment）来保护用户的个人敏感数据的存储和处理，确保数据不泄露。由于分布式终端硬件的安全能力不同，对于用户的敏感个人数据，需要使用高安全等级的设备进行存储和处理。HarmonyOS使用基于数学可证明的形式化开发和验证的TEE微内核，获得了商用OS内核CC EAL5+的认证评级。 设备证书认证支持为具备可信执行环境的设备预置设备证书，用于向其他虚拟终端证明自己的安全能力。对于有TEE环境的设备，通过预置PKI（Public Key Infrastructure）设备证书给设备身份提供证明，确保设备是合法制造生产的。设备证书在产线进行预置，设备证书的私钥写入并安全保存在设备的TEE环境中，且只在TEE内进行使用。在必须传输用户的敏感数据（例如密钥、加密的生物特征等信息）时，会在使用设备证书进行安全环境验证后，建立从一个设备的TEE到另一设备的TEE之间的安全通道，实现安全传输。如图1所示。 图1 设备证书使用示意图 正确地使用数据 在分布式终端场景下，需要确保用户能够正确地使用数据。HarmonyOS围绕数据的生成、存储、使用、传输以及销毁过程进行全生命周期的保护，从而保证个人数据与隐私、以及系统的机密数据（如密钥）不泄漏。 数据生成：根据数据所在的国家或组织的法律法规与标准规范，对数据进行分类分级，并且根据分类设置相应的保护等级。每个保护等级的数据从生成开始，在其存储、使用、传输的整个生命周期都需要根据对应的安全策略提供不同强度的安全防护。虚拟超级终端的访问控制系统支持依据标签的访问控制策略，保证数据只能在可以提供足够安全防护的虚拟终端之间存储、使用和传输。 数据存储：HarmonyOS通过区分数据的安全等级，存储到不同安全防护能力的分区，对数据进行安全保护，并提供密钥全生命周期的跨设备无缝流动和跨设备密钥访问控制能力，支撑分布式身份认证协同、分布式数据共享等业务。 数据使用：HarmonyOS通过硬件为设备提供可信执行环境。用户的个人敏感数据仅在分布式虚拟终端的可信执行环境中进行使用，确保用户数据的安全和隐私不泄露。 数据传输：为了保证数据在虚拟超级终端之间安全流转，需要各设备是正确可信的，建立了信任关系（多个设备通过华为帐号建立配对关系），并能够在验证信任关系后，建立安全的连接通道，按照数据流动的规则，安全地传输数据。当设备之间进行通信时，需要基于设备的身份凭据对设备进行身份认证，并在此基础上，建立安全的加密传输通道。 数据销毁：销毁密钥即销毁数据。数据在虚拟终端的存储，都建立在密钥的基础上。当销毁数据时，只需要销毁对应的密钥即完成了数据的销毁。 "},"ying-yong-ji-chu-zhi-shi.html":{"url":"ying-yong-ji-chu-zhi-shi.html","title":"应用基础知识","keywords":"","body":"应用基础知识 用户应用程序 用户应用程序泛指运行在设备的操作系统之上，为用户提供特定服务的程序，简称“应用”。 在HarmonyOS上运行的应用，有两种形态： 传统方式的需要安装的应用。 提供特定功能，免安装的应用（即 原子化服务 ）。 在HarmonyOS文档中，如无特殊说明，“应用”所指代的对象包括上述两种形态。 用户应用程序包结构 HarmonyOS的用户应用程序包以APPPack（Application Package）形式发布，它是由一个或多个HAP（HarmonyOS Ability Package）以及描述每个HAP属性的pack.info组成。HAP是Ability的部署包，HarmonyOS应用代码围绕Ability组件展开。 一个HAP是由代码、资源、第三方库及应用配置文件组成的模块包，可分为entry和feature两种模块类型，如图1所示。 entry ：应用的主模块。一个APP中，对于同一设备类型必须有且只有一个entry类型的HAP，可独立安装运行。 feature ：应用的动态特性模块。一个APP可以包含一个或多个feature类型的HAP，也可以不含。只有包含Ability的HAP才能够独立运行。 图1 APP逻辑视图 Ability Ability是应用所具备的能力的抽象，一个应用可以包含一个或多个Ability。Ability分为两种类型：FA（Feature Ability）和PA（Particle Ability）。FA/PA是应用的基本组成单元，能够实现特定的业务功能。FA有UI界面，而PA无UI界面。 库文件 库文件是应用依赖的第三方代码（例如so、jar、bin、har等二进制文件），存放在libs目录。 资源文件 应用的资源文件（字符串、图片、音频等）存放于resources目录下，便于开发者使用和维护，详见资源文件的分类。 配置文件 配置文件 (config.json) 是应用的Ability信息，用于声明应用的Ability，以及应用所需权限等信息，详见应用配置文件。 pack.info 描述应用软件包中每个HAP的属性，由IDE编译生成，应用市场根据该文件进行拆包和HAP的分类存储。HAP的具体属性包括： delivery-with-install: 表示该HAP是否支持随应用安装。 “true” 表示支持随应用安装； “false” 表示不支持随应用安装。 name：HAP文件名。 module-type：模块类型，entry或feature。 device-type：表示支持该HAP运行的设备类型。 HAR HAR（HarmonyOS Ability Resources）可以提供构建应用所需的所有内容，包括源代码、资源文件和config.json文件。HAR不同于HAP，HAR不能独立安装运行在设备上，只能作为应用模块的依赖项被引用。 "},"jian-jie.html":{"url":"jian-jie.html","title":"简介","keywords":"","body":"简介 应用的每个HAP的根目录下都存在一个“config.json”配置文件，文件内容主要涵盖以下三个方面： 应用的全局配置信息，包含应用的包名、生产厂商、版本号等基本信息。 应用在具体设备上的配置信息，包含应用的备份恢复、网络安全等能力。 HAP包的配置信息，包含每个Ability必须定义的基本属性（如包名、类名、类型以及Ability提供的能力），以及应用访问系统或其他应用受保护部分所需的权限等。 配置文件的组成 配置文件“config.json”采用JSON文件格式，其中包含了一系列配置项，每个配置项由属性和值两部分构成： 属性 属性出现顺序不分先后，且每个属性最多只允许出现一次。 值 每个属性的值为JSON的基本数据类型（数值、字符串、布尔值、数组、对象或者null类型）。如果属性值需要引用资源文件，可参见资源文件。 "},"pei-zhi-wen-jian-de-yuan-su.html":{"url":"pei-zhi-wen-jian-de-yuan-su.html","title":"配置文件的元素","keywords":"","body":"配置文件的元素 此部分提供配置文件“config.json”中所有属性的详细解释。 DevEco Studio提供了两种编辑“config.json”文件的方式。在“config.json”的编辑窗口中，可在右上角切换代码编辑视图或可视化编辑视图。 图1 config.json文件的可视化编辑视图 配置文件的内部结构 “config.json”由“app”、“deviceConfig”和“module”三个部分组成，缺一不可。配置文件的内部结构说明参见表1。 属性名称 含义 数据类型 是否可缺省 app 表示应用的全局配置信息。同一个应用的不同HAP包的“app”配置必须保持一致。 对象 否 deviceConfig 表示应用在具体设备上的配置信息。 对象 否 module 表示HAP包的配置信息。该标签下的配置只对当前HAP包生效。 对象 否 app对象的内部结构 app对象包含应用的全局配置信息，内部结构说明参见表2。 属性名称 子属性名称 含义 数据类型 是否可缺省 bundleName - 表示应用的包名，用于标识应用的唯一性。包名是由字母、数字、下划线（_）和点号（.）组成的字符串，必须以字母开头。支持的字符串长度为7~127字节。包名通常采用反域名形式表示（例如，com.huawei.himusic）。建议第一级为域名后缀“com”，第二级为厂商/个人名，第三级为应用名，也可以采用多级。 字符串 否 vendor - 表示对应用开发厂商的描述。字符串长度不超过255字节。 字符串 可缺省，缺省值为空。 version - 表示应用的版本信息。 对象 否 code 表示应用的版本号，仅用于HarmonyOS管理该应用，对用户不可见。取值为大于零的整数。 数值 否 name 表示应用的版本号，用于向用户呈现。取值可以自定义。 字符串 否 minCompatibleVersionCode 表示应用可兼容的最低版本号，用于在跨设备场景下，判断其他设备上该应用的版本是否兼容。 数值 可缺省，缺省值为code标签值。 apiVersion - 表示应用依赖的HarmonyOS的API版本。 对象 否 compatible 表示应用运行需要的API最小版本。取值为大于零的整数。 数值 否 target 表示应用运行需要的API目标版本。取值为大于零的整数。 数值 可缺省，缺省值为应用所在设备的当前API版本。 releaseType 表示应用运行需要的API目标版本的类型。取值为“CanaryN”、“BetaN”或者“Release”，其中，N代表大于零的整数。Canary：受限发布的版本。Beta：公开发布的Beta版本。Release：公开发布的正式版本。 字符串 可缺省，缺省值为“Release”。 multiFrameworkBundle - 表示应用是否为混合打包的HarmonyOS应用。混合打包场景配置为“true”，非混合打包场景配置为“false”。该标签值由IDE自动配置。 布尔类型 可缺省，缺省值为“false”。 smartWindowSize - 该标签用于在悬浮窗场景下表示应用的模拟窗口的尺寸。配置格式为“正整数*正整数”，单位为vp。正整数取值范围为[200,2000]。 字符串 可缺省，缺省值为空。 smartWindowDeviceType - 表示应用可以在哪些设备上使用模拟窗口打开。取值为：智能手机：phone平板：tablet智慧屏：tv 字符串数组 可缺省，缺省值为空。 targetBundleList - 表示允许以免安装方式拉起的其他HarmonyOS应用，列表取值为每个HarmonyOS应用的bundleName，多个bundleName之间用英文“,”区分，最多配置10个bundleName。如果被拉起的应用不支持免安装方式，则拉起失败。 字符串 否 app示例： \"app\": { \"bundleName\": \"com.huawei.hiworld.example\", \"vendor\": \"huawei\", \"version\": { \"code\": 2, \"name\": \"2.0\" } \"apiVersion\": { \"compatible\": 3, \"target\": 3, \"releaseType\": \"Beta1\" } } deviceConfig对象的内部结构 deviceConfig包含在具体设备上的应用配置信息，可以包含default、phone、tablet、tv、car、wearable、liteWearable和smartVision等属性。default标签内的配置是适用于所有设备通用，其他设备类型如果有特殊的需求，则需要在该设备类型的标签下进行配置。内部结构说明参见表3。 属性名称 含义 数据类型 是否可缺省 default 表示所有设备通用的应用配置信息。 对象 否 phone 表示手机类设备的应用信息配置。 对象 可缺省，缺省为空 tablet 表示平板的应用配置信息。 对象 可缺省，缺省为空。 tv 表示智慧屏特有的应用配置信息。 对象 可缺省，缺省为空。 car 表示车机特有的应用配置信息。 对象 可缺省，缺省为空。 wearable 表示智能穿戴特有的应用配置信息。 对象 可缺省，缺省为空。 liteWearable 表示轻量级智能穿戴特有的应用配置信息。 对象 可缺省，缺省为空。 smartVision 表示智能摄像头特有的应用配置信息。 对象 可缺省，缺省为空。 default、phone、tablet、tv、car、wearable、liteWearable和smartVision等对象的内部结构说明，可参见表4。 属性名称 含义 数据类型 是否可缺省 jointUserId 表示应用的共享userid。通常情况下，不同的应用运行在不同的进程中，应用的资源是无法共享。如果开发者的多个应用之间需要共享资源，则可以通过相同的jointUserId值实现，前提是这些应用的签名相同。该标签仅对系统应用生效，且仅适用于手机、平板、智慧屏、车机、智能穿戴。该字段在API Version 3及更高版本不再支持配置。 字符串 可缺省，缺省为空。 process 表示应用或者Ability的进程名。如果在“deviceConfig”标签下配置了“process”标签，则该应用的所有Ability都运行在这个进程中。 如果在“abilities”标签下也为某个Ability配置了“process”标签，则该Ability就运行在这个进程中。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为应用的软件包名。 supportBackup 表示应用是否支持备份和恢复。如果配置为“false”，则不支持为该应用执行备份或恢复操作。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省为“false”。 compressNativeLibs 表示libs库是否以压缩存储的方式打包到HAP包。如果配置为“false”，则libs库以不压缩的方式存储，HAP包在安装时无需解压libs，运行时会直接从HAP内加载libs库。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省为“true”。 network 表示网络安全性配置。该标签允许应用通过配置文件的安全声明来自定义其网络安全，无需修改应用代码。 对象 可缺省，缺省为空。 属性名称 含义 数据类型 是否可缺省 cleartextTraffic 表示是否允许应用使用明文网络流量（例如，明文HTTP）。true：允许应用使用明文流量的请求。false：拒绝应用使用明文流量的请求。 布尔类型 可缺省，缺省为“false”。 securityConfig 表示应用的网络安全配置信息。 对象 可缺省，缺省为空。 属性名称 子属性名称 含义 数据类型 是否可缺省 domainSettings - 表示自定义的网域范围的安全配置，支持多层嵌套，即一个domainSettings对象中允许嵌套更小网域范围的domainSettings对象。 对象 可缺省，缺省为空。 cleartextPermitted 表示自定义的网域范围内是否允许明文流量传输。当usesCleartext和securityConfig同时存在时，自定义网域是否允许明文流量传输以cleartextPermitted的取值为准。true：允许明文流量传输。false：拒绝明文流量传输。 布尔类型 否 domains 表示域名配置信息，包含两个参数：subdomains和name。subdomains（布尔类型）：表示是否包含子域名。如果为 “true”，此网域规则将与相应网域及所有子网域（包括子网域的子网域）匹配。否则，该规则仅适用于精确匹配项。name（字符串）：表示域名名称。 对象数组 否 deviceConfig示例： \"deviceConfig\": { \"default\": { \"process\": \"com.huawei.hiworld.example\", \"supportBackup\": false, \"network\": { \"cleartextTraffic\": true, \"securityConfig\": { \"domainSettings\": { \"cleartextPermitted\": true, \"domains\": [ { \"subDomains\": true, \"name\": \"example.ohos.com\" } ] } } } } } module对象的内部结构 module对象包含HAP包的配置信息，内部结构说明参见表7。 属性名称 含义 数据类型 是否可缺省 mainAbility 表示HAP包的入口ability名称。该标签的值应配置为“module > abilities”中存在的Page类型ability的名称。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 如果存在page类型的ability，则该字段不可缺省。 package 表示HAP的包结构名称，在应用内应保证唯一性。采用反向域名格式（建议与HAP的工程目录保持一致）。字符串长度不超过127字节。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 否 name 表示HAP的类名。采用反向域名方式表示，前缀需要与同级的package标签指定的包名一致，也可采用“.”开头的命名方式。字符串长度不超过255字节。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 否 description 表示HAP的描述信息。字符串长度不超过255字节。如果字符串超出长度或者需要支持多语言，可以采用资源索引的方式添加描述内容。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。 supportedModes 表示应用支持的运行模式。当前只定义了驾驶模式（drive）。该标签仅适用于车机。 字符串数组 可缺省，缺省值为空。 deviceType 表示允许Ability运行的设备类型。系统预定义的设备类型包括：phone（手机）、tablet（平板）、tv（智慧屏）、car（车机）、wearable（智能穿戴）、liteWearable（轻量级智能穿戴）等。 字符串数组 否 distro 表示HAP发布的具体描述。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 对象 否 metaData 表示HAP的元信息。 对象 可缺省，缺省值为空。 abilities 表示当前模块内的所有Ability。采用对象数组格式，其中每个元素表示一个Ability对象。 对象数组 可缺省，缺省值为空。 js 表示基于JS UI框架开发的JS模块集合，其中的每个元素代表一个JS模块的信息。 对象数组 可缺省，缺省值为空。 shortcuts 表示应用的快捷方式信息。采用对象数组格式，其中的每个元素表示一个快捷方式对象。 对象数组 可缺省，缺省值为空。 defPermissions 表示应用定义的权限。应用调用者必须申请这些权限，才能正常调用该应用。 对象数组 可缺省，缺省值为空。 reqPermissions 表示应用运行时向系统申请的权限。 对象数组 可缺省，缺省值为空。 colorMode 表示应用自身的颜色模式。dark：表示按照深色模式选取资源。light：表示按照浅色模式选取资源。auto：表示跟随系统的颜色模式值选取资源。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为“auto”。 theme 表示应用的主题，标签值为自定义主题资源的索引，或系统资源的索引。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。 entryTheme 表示内部主题的关键字，标签值配置为该名称对应的资源索引。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。 resizeable 表示应用是否支持多窗口特性。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“true”。 module示例： \"module\": { \"mainAbility\": \"MainAbility\", \"package\": \"com.example.myapplication.entry\", \"name\": \".MyOHOSAbilityPackage\", \"description\": \"$string:description_application\", \"supportedModes\": [ \"drive\" ], \"deviceType\": [ \"car\" ], \"distro\": { \"deliveryWithInstall\": true, \"moduleName\": \"ohos_entry\", \"moduleType\": \"entry\" }, \"abilities\": [ ... ], \"shortcuts\": [ ... ], \"js\": [ ... ], \"reqPermissions\": [ ... ], \"defPermissions\": [ ... ], \"colorMode\": \"light\"} 属性名称 含义 数据类型 是否可缺省 deliveryWithInstall 表示当前HAP是否支持随应用安装。true：支持随应用安装。false：不支持随应用安装。说明该属性建议设置为true。设置false可能导致最终应用上架应用市场异常。 布尔类型 否 moduleName 表示当前HAP的名称。 字符串 否 moduleType 表示当前HAP的类型，包括两种类型：entry和feature。 字符串 否 installationFree 表示当前该FA是否支持免安装特性。true：表示支持免安装特性，且符合免安装约束。false：表示不支持免安装特性。 布尔类型 entry.hap可缺省，feature.hap不可缺省。 distro示例： \"distro\": { \"deliveryWithInstall\": true, \"moduleName\": \"ohos_entry\", \"moduleType\": \"entry\", \"installationFree\": true} 属性名称 子属性名称 含义 数据类型 是否可缺省 parameters - 表示调用Ability时所有调用参数的元信息。每个调用参数的元信息由以下三个标签组成：description、name、type。 对象 可缺省，缺省值为空。 description 表示对调用参数的描述，可以是表示描述内容的字符串，也可以是对描述内容的资源索引以支持多语言。 字符串 可缺省，缺省值为空。 name 表示调用参数的名称。 字符串 可缺省，缺省值为空。 type 表示调用参数的类型，如Integer。 字符串 否 results - 表示Ability返回值的元信息。每个返回值的元信息由以下三个标签组成：description、name、type。 对象 可缺省，缺省值为空。 description 表示对返回值的描述，可以是表示描述内容的字符串，也可以是对描述内容的资源索引以支持多语言。 字符串 可缺省，缺省值为空。 name 表示返回值的名字。 字符串 可缺省，缺省值为空。 type 表示返回值的类型，如Integer。 字符串 否 customizeData - 表示父级组件的自定义元信息，parameters和results在module中不可配。 对象 可缺省，缺省值为空。 name 表示数据项的键名称，字符串类型（最大长度255字节）。 字符串 可缺省，缺省值为空。 value 表示数据项的值，字符串类型（最大长度255字节）。 字符串 可缺省，缺省值为空。 extra 表示用户自定义数据格式，标签值为标识该数据的资源的索引值。 字符串 可缺省，缺省值为空。 metaData示例： \"metaData\": { \"parameters\" : [{ \"name\" : \"string\", \"type\" : \"Float\", \"description\" : \"$string:parameters_description\" }], \"results\" : [{ \"name\" : \"string\", \"type\" : \"Float\", \"description\" : \"$string:results_description\" }], \"customizeData\" : [{ \"name\" : \"string\", \"value\" : \"string\", \"extra\" : \"$string:customizeData_description\" }]} 属性名称 含义 数据类型 是否可缺省 name 表示Ability名称。取值可采用反向域名方式表示，由包名和类名组成，如“com.example.myapplication.MainAbility”；也可采用“.”开头的类名方式表示，如“.MainAbility”。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。说明在使用DevEco Studio新建项目时，默认生成首个Ability的配置，包括生成“MainAbility.java”文件，及“config.json”中“MainAbility”的配置。如使用其他IDE工具，可自定义名称。 字符串 否 description 表示对Ability的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。 字符串 可缺省，缺省值为空。 icon 表示Ability图标资源文件的索引。取值示例：$media:ability_icon。如果在该Ability的“skills”属性中，“actions”的取值包含 “action.system.home”，“entities”取值中包含“entity.system.home”，则该Ability的icon将同时作为应用的icon。如果存在多个符合条件的Ability，则取位置靠前的Ability的icon作为应用的icon。说明应用的“icon”和“label”是用户可感知配置项，需要区别于当前所有已有的应用“icon”或“label”（至少有一个不同）。 字符串 可缺省，缺省值为空。 label 表示Ability对用户显示的名称。取值可以是Ability名称，也可以是对该名称的资源索引，以支持多语言。如果在该Ability的“skills”属性中，“actions”的取值包含 “action.system.home”，“entities”取值中包含“entity.system.home”，则该Ability的label将同时作为应用的label。如果存在多个符合条件的Ability，则取位置靠前的Ability的label作为应用的label。说明应用的“icon”和“label”是用户可感知配置项，需要区别于当前所有已有的应用“icon”或“label”（至少有一个不同）。 字符串 可缺省，缺省值为空。 uri 表示Ability的统一资源标识符。格式为[scheme:][//authority][path][?query][#fragment]。 字符串 可缺省，对于data类型的Ability不可缺省。 launchType 表示Ability的启动模式，支持“standard”和“singleton”两种模式：standard：表示该Ability可以有多实例。“standard”模式适用于大多数应用场景。singleton：表示该Ability只可以有一个实例。例如，具有全局唯一性的呼叫来电界面即采用“singleton”模式。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为“standard”。 visible 表示Ability是否可以被其他应用调用。true：可以被其他应用调用。false：不能被其他应用调用。 布尔类型 可缺省，缺省值为“false”。 permissions 表示其他应用的Ability调用此Ability时需要申请的权限。通常采用反向域名格式，取值可以是系统预定义的权限，也可以是开发者自定义的权限。如果是自定义权限，取值必须与“defPermissions”标签中定义的某个权限的“name”标签值一致。 字符串数组 可缺省，缺省值为空。 skills 表示Ability能够接收的Intent的特征。 对象数组 可缺省，缺省值为空。 deviceCapability 表示Ability运行时要求设备具有的能力，采用字符串数组的格式表示。 字符串数组 可缺省，缺省值为空。 metaData 表示Ability的元信息。调用Ability时调用参数的元信息，例如：参数个数和类型。Ability执行完毕返回值的元信息，例如：返回值个数和类型。该标签仅适用于智慧屏、智能穿戴、车机。 对象 可缺省，缺省值为空。 type 表示Ability的类型。取值范围如下：page：表示基于Page模板开发的FA，用于提供与用户交互的能力。service：表示基于Service模板开发的PA，用于提供后台运行任务的能力。data：表示基于Data模板开发的PA，用于对外部提供统一的数据访问抽象。CA：表示支持其他应用以窗口方式调起该Ability。 字符串 否 orientation 表示该Ability的显示模式。该标签仅适用于page类型的Ability。取值范围如下：unspecified：由系统自动判断显示方向。landscape：横屏模式。portrait：竖屏模式。followRecent：跟随栈中最近的应用。 字符串 可缺省，缺省值为“unspecified”。 backgroundModes 表示后台服务的类型，可以为一个服务配置多个后台服务类型。该标签仅适用于service类型的Ability。取值范围如下：dataTransfer：通过网络/对端设备进行数据下载、备份、分享、传输等业务。audioPlayback：音频输出业务。audioRecording：音频输入业务。pictureInPicture：画中画、小窗口播放视频业务。voip：音视频电话、VOIP业务。location：定位、导航业务。bluetoothInteraction：蓝牙扫描、连接、传输业务。wifiInteraction：WLAN扫描、连接、传输业务。screenFetch：录屏、截屏业务。 字符串数组 可缺省，缺省值为空。 readPermission 表示读取Ability的数据所需的权限。该标签仅适用于data类型的Ability。取值为长度不超过255字节的字符串。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为空。 writePermission 表示向Ability写数据所需的权限。该标签仅适用于data类型的Ability。取值为长度不超过255字节的字符串。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为空。 configChanges 表示Ability关注的系统配置集合。当已关注的配置发生变更后，Ability会收到onConfigurationUpdated回调。取值范围：locale：表示语言区域发生变更。layout：表示屏幕布局发生变更。fontSize：表示字号发生变更。orientation：表示屏幕方向发生变更。density：表示显示密度发生变更。 字符串数组 可缺省，缺省为空。 mission 表示Ability指定的任务栈。该标签仅适用于page类型的Ability。默认情况下应用中所有Ability同属一个任务栈。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省为应用的包名。 targetAbility 表示当前Ability重用的目标Ability。该标签仅适用于page类型的Ability。如果配置了targetAbility属性，则当前Ability（即别名Ability）的属性中仅“name”、“icon”、“label”、“visible”、“permissions”、“skills”生效，其它属性均沿用targetAbility中的属性值。目标Ability必须与别名Ability在同一应用中，且在配置文件中目标Ability必须在别名之前进行声明。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 字符串 可缺省，缺省值为空。表示当前Ability不是一个别名Ability。 multiUserShared 表示Ability是否支持多用户状态进行共享，该标签仅适用于data类型的Ability。配置为“true”时，表示在多用户下只有一份存储数据。需要注意的是，该属性会使visible属性失效。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“false”。 supportPipMode 表示Ability是否支持用户进入PIP模式（用于在在页面最上层悬浮小窗口，俗称“画中画”，常见于视频播放等场景）。该标签仅适用于page类型的Ability。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“false”。 formsEnabled 表示Ability是否支持卡片（forms）功能。该标签仅适用于page类型的Ability。true：支持卡片能力。false：不支持卡片能力。 布尔类型 可缺省，缺省值为“false”。 forms 表示服务卡片的属性。该标签仅当“formsEnabled”为“true”时，才能生效。 对象数组 可缺省，缺省值为空。 resizeable 表示Ability是否支持多窗口特性。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 布尔类型 可缺省，缺省值为“true”。 abilities示例： \"abilities\": [ { \"name\": \".MainAbility\", \"description\": \"himusic main ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"permissions\": [ ], \"visible\": true, \"skills\": [ { \"actions\": [ \"action.system.home\" ], \"entities\": [ \"entity.system.home\" ] } ], \"configChanges\": [ \"locale\", \"layout\", \"fontSize\", \"orientation\" ], \"type\": \"page\" }, { \"name\": \".PlayService\", \"description\": \"himusic play ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"visible\": false, \"skills\": [ { \"actions\": [ \"action.play.music\", \"action.stop.music\" ], \"entities\": [ \"entity.audio\" ] } ], \"type\": \"service\", \"backgroundModes\": [ \"audioPlayback\" ] }, { \"name\": \".UserADataAbility\", \"type\": \"data\", \"uri\": \"dataability://com.huawei.hiworld.himusic.UserADataAbility\", \"visible\": true }] 属性名称 子属性名称 含义 数据类型 是否可缺省 actions - 表示能够接收的Intent的action值，可以包含一个或多个action。取值通常为系统预定义的action值，详见《API参考》中的ohos.aafwk.content.Intent类。 字符串数组 可缺省，缺省值为空。 entities - 表示能够接收的Intent的Ability的类别（如视频、桌面应用等），可以包含一个或多个entity。取值通常为系统预定义的类别，详见《API参考》中的ohos.aafwk.content.Intent类，也可以自定义。 字符串数组 可缺省，缺省值为空。 uris - 表示能够接收的Intent的uri，可以包含一个或者多个uri。 对象数组 可缺省，缺省值为空。 scheme 表示uri的scheme值。 字符串 不可缺省。 host 表示uri的host值。 字符串 可缺省，缺省值为空。 port 表示uri的port值。 字符串 可缺省，缺省值为空。 path 表示uri的path值。 字符串 可缺省，缺省值为空。 type 表示uri的type值。 字符串 可缺省，缺省值为空。 skills示例： \"skills\": [ { \"actions\": [ \"action.system.home\" ], \"entities\": [ \"entity.system.home\" ], \"uris\": [ { \"scheme\": \"http\", \"host\": \"www.xxx.com\", \"port\": \"8080\", \"path\": \"query/student/name\", \"type\": \"text/*\" } ] }] 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示JS Component的名字。该标签不可缺省，默认值为default。 字符串 否 pages - 表示JS Component的页面用于列举JS Component中每个页面的路由信息[页面路径+页面名称]。该标签不可缺省，取值为数组，数组第一个元素代表JS FA首页。 数组 否 window - 用于定义与显示窗口相关的配置。该标签仅适用于手机、平板、智慧屏、车机、智能穿戴。 对象 可缺省。 designWidth 表示页面设计基准宽度。以此为基准，根据实际设备宽度来缩放元素大小。 数值 可缺省，缺省值为750px。 autoDesignWidth 表示页面设计基准宽度是否自动计算。当配置为true时，designWidth将会被忽略，设计基准宽度由设备宽度与屏幕密度计算得出。 布尔类型 可缺省，缺省值为“false”。 type - 表示JS应用的类型。取值范围如下：normal：标识该JS Component为应用实例。form：标识该JS Component为卡片实例。 字符串 可缺省，缺省值为“normal”。 js示例： \"js\": [ { \"name\": \"default\", \"pages\": [ \"pages/index/index\", \"pages/detail/detail\" ], \"window\": { \"designWidth\": 750, \"autoDesignWidth\": false }, \"type\": \"form\" }] 属性名称 子属性名称 含义 数据类型 是否可缺省 shortcutId - 表示快捷方式的ID。字符串的最大长度为63字节。 字符串 否 label - 表示快捷方式的标签信息，即快捷方式对外显示的文字描述信息。取值可以是描述性内容，也可以是标识label的资源索引。字符串最大长度为63字节。 字符串 可缺省，缺省为空。 intents - 表示快捷方式内定义的目标intent信息集合，每个intent可配置两个子标签，targetClass, targetBundle。 - 可缺省，缺省为空。 targetClass 表示快捷方式目标类名。 字符串 可缺省，缺省值为空。 targetBundle 表示快捷方式目标Ability所在应用的包名。 字符串 可缺省，缺省值为空。 shortcuts示例： \"shortcuts\": [ { \"shortcutId\": \"id\", \"label\": \"$string:shortcut\", \"intents\": [ { \"targetBundle\": \"com.huawei.hiworld.himusic\", \"targetClass\": \"com.huawei.hiworld.himusic.entry.MainAbility\" } ] }] 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示卡片的类名。字符串最大长度为127字节。 字符串 否 description - 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。 isDefault - 表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。true：默认卡片。false：非默认卡片。 布尔值 否 type - 表示卡片的类型。取值范围如下：Java：Java卡片。JS：JS卡片。 字符串 否 colorMode - 表示卡片的主题样式，取值范围如下：auto：自适应。dark：深色主题。light：浅色主题。 字符串 可缺省，缺省值为“auto”。 supportDimensions - 表示卡片支持的外观规格，取值范围：12：表示1行2列的二宫格。22：表示2行2列的四宫格。24：表示2行4列的八宫格。44：表示4行4列的十六宫格。 字符串数组 否 defaultDimension - 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否 landscapeLayouts - 表示卡片外观规格对应的横向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 portraitLayouts - 表示卡片外观规格对应的竖向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 updateEnabled - 表示卡片是否支持周期性刷新，取值范围：true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。false：表示不支持周期性刷新。 布尔类型 否 scheduledUpdateTime - 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 字符串 可缺省，缺省值为“0:0”。 updateDuration - 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。 数值 可缺省，缺省值为“0”。 formConfigAbility - 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。 jsComponentName - 表示JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。 字符串 否 metaData - 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。 customizeData - 表示自定义的卡片信息。 对象数组 可缺省，缺省值为空。 name 表示数据项的键名称。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 value 表示数据项的值。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 forms示例： \"forms\": [ { \"name\": \"Form_Js\", \"description\": \"It's Js Form\", \"type\": \"JS\", \"jsComponentName\": \"card\", \"colorMode\": \"auto\", \"isDefault\": true, \"updateEnabled\": true, \"scheduledUpdateTime\": \"11:00\", \"updateDuration\": 1, \"defaultDimension\": \"2*2\", \"supportDimensions\": [ \"2*2\", \"2*4\", \"4*4\" ] }, { \"name\": \"Form_Java\", \"description\": \"It's Java Form\", \"type\": \"Java\", \"colorMode\": \"auto\", \"isDefault\": false, \"updateEnabled\": true, \"scheduledUpdateTime\": \"21:05\", \"updateDuration\": 1, \"defaultDimension\": \"1*2\", \"supportDimensions\": [ \"1*2\" ], \"landscapeLayouts\": [ \"$layout:ability_form\" ], \"portraitLayouts\": [ \"$layout:ability_form\" ], \"formConfigAbility\": \"ability://com.example.myapplication.fa/.MainAbility\", \"metaData\": { \"customizeData\": [ { \"name\": \"originWidgetName\", \"value\": \"com.huawei.weather.testWidget\" } ] } }] HAP与HAR的配置文件的合并 如果应用模块中调用了HAR，在编译构建HAP时，需要将HAP的“config.json”文件与一个或多个HAR的“config.json”文件，合并为一个“config.json”文件。在合并过程中，不同文件的同一个标签的取值可能发生冲突，此时，需要通过配置mergeRule来解决冲突。 配置文件合并规则 HAP与HAR的“config.json”文件合并时，需要将HAR的配置信息全部合并到HAP的配置文件。合并规则参见表15。 HAP的优先级总是高于HAR。当HAP依赖于多个HAR时，先加载的HAR的优先级高于后加载的HAR，按照HAR的加载顺序依次合并到HAP文件。 序号 HAP HAR 合并结果 1 无标签值。 无标签值。 无标签值。 2 有标签值，取值为A。 无标签值。 有标签值，取值为A。 3 无标签值。 有标签值，取值为B。 有标签值，取值为B。 4 有标签值，取值为A。 有标签值，取值为A。 有标签值，取值为A。 5 有标签值，取值为A。 有标签值，取值为B。 冲突，需要添加mergeRule，详见mergeRule对象的使用。 mergeRule对象的使用 mergeRule通常在HAP的“config.json”文件中使用，可以在“abilities”、“defPermissions”、 “reqPermissions”、“js”等属性中添加。不同属性的合并策略，详见表16。 注意 HAR配置文件中不能包含“action.system.home”和“entity.system.home”配置项，否则会导致编译报错。 abilities对象中“name”字段的取值，必须为完整的类名，否则会导致合并出错。 属性名称 合并规则 一级 二级 三级 app - - 只保留HAP的“config.json”文件中的app对象。 deviceConfig - - 只保留HAP的“config.json”文件中的deviceConfig对象。 module package - 只保留HAP的“config.json”文件中的取值。 name - 只保留HAP的“config.json”文件中的取值。 description - 只保留HAP的“config.json”文件中的取值。 supportedModes - 只保留HAP的“config.json”文件中的取值。 deviceType - 只保留HAP的“config.json”文件中的取值。 distro - 只保留HAP的“config.json”文件中的取值。 shortcuts - 只保留HAP的“config.json”文件中的取值。 defPermissions - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 reqPermissions - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 js - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 abilities - 当“module”中的“name”取值不同时，取值为HAP与HAR的“config.json”文件的并集。当“module”中的“name”取值相同时，需要在HAP的“config.json”文件中的相应属性下添加mergeRule字段，以解决合并冲突。 permissions 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 skills 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 backgroundModes 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 configChanges 取值为HAP与HAR的“config.json”文件中相应属性值的并集。 targetAbility 如果“targetAbility”与“abilities”中的“name”冲突，则导致编译报错。 其他 “abilities”中的其他属性如果发生合并冲突，则需要添加“mergeRule”字段。 属性名称 含义 数据类型 是否可缺省 remove 表示HAP与HAR的“config.json”文件合并时，需要移除的标签。 字符串数组 是 replace 表示HAP与HAR的“config.json”文件合并冲突时，需要替换的标签，始终保留高优先级的值。 字符串数组 是 mergeRule的使用示例： 在下面的示例中，HAP与HAR中的Ability的“name”取值相同，需要对两者“config.json”文件中的Ability进行合并。由于两个文件中的部分字段（例如“launchType”）存在冲突，需要在HAP的“abilities”标签下添加“mergeRule”。 合并前HAP的 “config.json” 文件，如下所示： 其中，remove表示合并后需要移除的子标签，replace表示合并后需要替换的子标签（HAP替换HAR）。 \"abilities\": [ { \"mergeRule\": { \"remove\": [\"orientation\"], \"replace\": [\"launchType\"] } \"name\": \"com.harmony.myapplication.entry.MainAbility\", \"type\": \"page\", \"launchType\": \"standard\", \"visible\": false }], 合并前HAR的 “config.json” 文件，如下所示： \"abilities\": [ { \"name\": \"com.harmony.myapplication.entry.MainAbility\", \"type\": \"page\", \"launchType\": \"singleton\", \"orientation\": \"portrait\", \"visible\": false }], 将上述两个 “config.json” 文件按照mergeRule进行合并，处理完成后mergeRule字段也会被移除。合并后的结果文件，如下所示： \"abilities\": [ { \"name\": \"com.harmony.myapplication.entry.MainAbility\", \"type\": \"page\", \"launchType\": \"standard\", \"visible\": false }], bundleName占位符的使用 HAR的“config.json”文件中多处需要使用包名，例如自定义权限、自定义action等场景，但是包名只有当HAR编译到HAP时才能确定下来。在编译之前，HAR中的包名可以采用占位符来表示，采用{bundleName}形式。 支持bundleName占位符的标签有actions、entities、permissions、readPermission、writePermission、defPermissions.name、uri。 使用示例： HAR中自定义action时，使用{bundleName}来代替包名。如下所示： \"skills\": [ { \"actions\": [ \"{bundleName}.ACTION_PLAY\" ], \"entities\": [ \"{bundleName}.ENTITY_PLAY\" ], }], 将HAP编译到bundleName为 “com.huawei.hiworld” 的HAP包后，原来的{bundleName}将被替换为HAP的实际包名。替换后的结果如下所示： \"app\": { \"bundleName\": \"com.huawei.hiworld\", ……},\"module\": { \"abilities\": [ { \"skills\": [ { \"actions\": [ \"com.huawei.hiworld.ACTION_PLAY\" ], \"entities\": [ \"com.huawei.hiworld.ENTITY_PLAY\" ], } ], "},"pei-zhi-wen-jian-shi-li.html":{"url":"pei-zhi-wen-jian-shi-li.html","title":"配置文件示例","keywords":"","body":"配置文件示例 以JSON文件为config.json的一个简单示例，该示例的应用声明为三个Ability。 { \"app\": { \"bundleName\": \"com.huawei.hiworld.himusic\", \"vendor\": \"huawei\", \"version\": { \"code\": 2, \"name\": \"2.0\" }, \"apiVersion\": { \"compatible\": 3, \"target\": 3, \"releaseType\": \"Beta1\" } }, \"deviceConfig\": { \"default\": { } }, \"module\": { \"mainAbility\": \"MainAbility\", \"package\": \"com.huawei.hiworld.himusic.entry\", \"name\": \".MainApplication\", \"supportedModes\": [ \"drive\" ], \"distro\": { \"moduleType\": \"entry\", \"deliveryWithInstall\": true, \"moduleName\": \"hap-car\" }, \"deviceType\": [ \"car\" ], \"abilities\": [ { \"name\": \".MainAbility\", \"description\": \"himusic main ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"visible\": true, \"skills\": [ { \"actions\": [ \"action.system.home\" ], \"entities\": [ \"entity.system.home\" ] } ], \"type\": \"page\", \"formsEnabled\": false }, { \"name\": \".PlayService\", \"description\": \"himusic play ability\", \"icon\": \"$media:ic_launcher\", \"label\": \"HiMusic\", \"launchType\": \"standard\", \"orientation\": \"unspecified\", \"visible\": false, \"skills\": [ { \"actions\": [ \"action.play.music\", \"action.stop.music\" ], \"entities\": [ \"entity.audio\" ] } ], \"type\": \"service\", \"backgroundModes\": [ \"audioPlayback\" ] }, { \"name\": \".UserADataAbility\", \"type\": \"data\", \"uri\": \"dataability://com.huawei.hiworld.himusic.UserADataAbility\", \"visible\": true } ], \"reqPermissions\": [ { \"name\": \"ohos.permission.DISTRIBUTED_DATASYNC\", \"reason\": \"\", \"usedScene\": { \"ability\": [ \"com.huawei.hiworld.himusic.entry.MainAbility\", \"com.huawei.hiworld.himusic.entry.PlayService\" ], \"when\": \"inuse\" } } ] } } "},"zi-yuan-wen-jian-de-fen-lei.html":{"url":"zi-yuan-wen-jian-de-fen-lei.html","title":"资源文件的分类","keywords":"","body":"资源文件的分类 更新时间: 2021-06-02 21:03 resources目录 应用的资源文件（字符串、图片、音频等）统一存放于resources目录下，便于开发者使用和维护。resources目录包括两大类目录，一类为base目录与限定词目录，另一类为rawfile目录，详见表1。 资源目录示例： resources|---base // 默认存在的目录| |---element| | |---string.json| |---media| | |---icon.png|---en_GB-vertical-car-mdpi // 限定词目录示例，需要开发者自行创建 | |---element| | |---string.json| |---media| | |---icon.png|---rawfile // 默认存在的目录 分类 base目录与限定词目录 rawfile目录 组织形式 按照两级目录形式来组织，目录命名必须符合规范，以便根据设备状态去匹配相应目录下的资源文件。一级子目录为base目录和限定词目录。base目录是默认存在的目录。当应用的resources资源目录中没有与设备状态匹配的限定词目录时，会自动引用该目录中的资源文件。限定词目录需要开发者自行创建。目录名称由一个或多个表征应用场景或设备特征的限定词组合而成，具体要求参见限定词目录。二级子目录为资源目录，用于存放字符串、颜色、布尔值等基础元素，以及媒体、动画、布局等资源文件，具体要求参见资源组目录。 支持创建多层子目录，目录名称可以自定义，文件夹内可以自由放置各类资源文件。rawfile目录的文件不会根据设备状态去匹配不同的资源。 编译方式 目录中的资源文件会被编译成二进制文件，并赋予资源文件ID。 目录中的资源文件会被直接打包进应用，不经过编译，也不会被赋予资源文件ID。 引用方式 通过指定资源类型（type）和资源名称（name）来引用，详见资源文件的引用方法。 通过指定文件路径和文件名来引用，详见资源文件的引用方法。 限定词目录 限定词目录可以由一个或多个表征应用场景或设备特征的限定词组合而成，包括移动国家码和移动网络码、语言、文字、国家或地区、横竖屏、设备类型、颜色模式和屏幕密度等维度，限定词之间通过下划线（_）或者中划线（-）连接。开发者在创建限定词目录时，需要掌握限定词目录的命名要求以及与限定词目录与设备状态的匹配规则。 限定词目录的命名**要求** 限定词的组合顺序：移动国家码移动网络码-语言文字_国家或地区-横竖屏-设备类型-深色模式-屏幕密度。开发者可以根据应用的使用场景和设备特征，选择其中的一类或几类限定词组成目录名称。 限定词的连接方式：语言、文字、国家或地区之间采用下划线（）连接，移动国家码和移动网络码之间也采用下划线（）连接，除此之外的其他限定词之间均采用中划线（-）连接。例如：zh_Hant_CN、zh_CN-car-ldpi。 限定词的取值范围：每类限定词的取值必须符合 表2 中的条件，否则，将无法匹配目录中的资源文件。 限定词类型 含义与取值说明 移动国家码和移动网络码 移动国家码（MCC）和移动网络码（MNC）的值取自设备注册的网络。MCC后面可以跟随MNC，使用下划线（）连接，也可以单独使用。例如：mcc460表示中国，mcc460_mnc00表示中国中国移动。详细取值范围，请查阅ITU-T E.212（国际电联相关标准）。 语言 表示设备使用的语言类型，由2~3个小写字母组成。例如：zh表示中文，en表示英语，mai表示迈蒂利语。详细取值范围，请查阅ISO 639（ISO制定的语言编码标准）。 文字 表示设备使用的文字类型，由1个大写字母（首字母）和3个小写字母组成。例如：Hans表示简体中文，Hant表示繁体中文。详细取值范围，请查阅ISO 15924（ISO制定的文字编码标准）。 国家或地区 表示用户所在的国家或地区，由2~3个大写字母或者3个数字组成。例如：CN表示中国，GB表示英国。详细取值范围，请查阅ISO 3166-1（ISO制定的国家和地区编码标准）。 横竖屏 表示设备的屏幕方向，取值如下：vertical：竖屏horizontal：横屏 设备类型 表示设备的类型，取值如下：phone：手机tablet：平板car：车机tv：智慧屏wearable：智能穿戴 颜色模式 表示设备的颜色模式，取值如下：dark：深色模式light：浅色模式 屏幕密度 表示设备的屏幕密度（单位为dpi），取值如下：sdpi：表示小规模的屏幕密度（Small-scale Dots Per Inch），适用于dpi取值为(0, 120]的设备。mdpi：表示中规模的屏幕密度（Medium-scale Dots Per Inch），适用于dpi取值为(120, 160]的设备。ldpi：表示大规模的屏幕密度（Large-scale Dots Per Inch），适用于dpi取值为(160, 240]的设备。xldpi：表示特大规模的屏幕密度（Extra Large-scale Dots Per Inch），适用于dpi取值为(240, 320]的设备。xxldpi：表示超大规模的屏幕密度（Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(320, 480]的设备。xxxldpi：表示超特大规模的屏幕密度（Extra Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(480, 640]的设备。 限定词目录与设备状态的匹配规则 在为设备匹配对应的资源文件时，限定词目录匹配的优先级从高到低依次为：移动国家码和移动网络码 > 区域（语言文字国家或地区）> 横竖屏 > 设备类型 > 颜色模式 > 屏幕密度。 如果限定词目录中包含移动国家码和移动网络码、语言、文字、横竖屏、设备类型、颜色模式限定词，则对应限定词的取值必须与当前的设备状态完全一致，该目录才能够参与设备的资源匹配。例如，限定词目录“zh_CN-car-ldpi”不能参与“en_US”设备的资源匹配。 资源组目录 base目录与限定词目录下面可以创建资源组目录（包括element、media、animation、layout、graphic、profile），用于存放特定类型的资源文件，详见表3。 资源组目录 目录说明 资源文件 element 表示元素资源，以下每一类数据都采用相应的JSON文件来表征。boolean，布尔型color，颜色float，浮点型intarray，整型数组integer，整型pattern，样式plural，复数形式strarray，字符串数组string，字符串 element目录中的文件名称建议与下面的文件名保持一致。每个文件中只能包含同一类型的数据。boolean.jsoncolor.jsonfloat.jsonintarray.jsoninteger.jsonpattern.jsonplural.jsonstrarray.jsonstring.json media 表示媒体资源，包括图片、音频、视频等非文本格式的文件。 文件名可自定义，例如：icon.png。 animation 表示动画资源，采用XML文件格式。 文件名可自定义，例如：zoom_in.xml。 layout 表示布局资源，采用XML文件格式。 文件名可自定义，例如：home_layout.xml。 graphic 表示可绘制资源，采用XML文件格式。 文件名可自定义，例如：notifications_dark.xml。 profile 表示其他类型文件，以原始文件形式保存。 文件名可自定义。 创建资源文件 在resources目录下，可按照限定词目录和资源组目录的说明创建子目录和目录内的文件。 同时，DevEco Studio也提供了创建资源目录和资源文件的界面。 创建资源目录及资源文件 在resources目录右键菜单选择“New > Harmony Resource File”，此时可同时创建目录和文件。 文件默认创建在base目录的对应资源组下。如果选择了限定词，则会按照命名规范自动生成限定词+资源组目录，并将文件创建在目录中。 目录名自动生成，格式固定为“限定词.资源组”，例如创建一个限定词为横竖屏类别下的竖屏，资源组为绘制资源的目录，自动生成的目录名称为“vertical.graphic”。 创建资源目录 在resources目录右键菜单选择“New > Harmony Resource Directory”，此时可创建资源目录。 选择资源组类型，设置限定词，创建后自动生成目录名称。目录名称格式固定为“限定词.资源组”，例如创建一个限定词为横竖屏类别下的竖屏，资源组为绘制资源的目录，自动生成的目录名称为“vertical.graphic”。 创建资源文件 在资源目录的右键菜单选择“New > XXX Resource File”，即可创建对应资源组目录的资源文件。 例如，在element目录下可新建Element Resource File。 "},"zi-yuan-wen-jian-de-shi-yong.html":{"url":"zi-yuan-wen-jian-de-shi-yong.html","title":"资源文件的使用","keywords":"","body":"资源文件的使用 更新时间: 2021-06-02 21:03 资源文件的引用方法 base目录与限定词目录中的资源文件：通过指定资源类型（type）和资源名称（name）来引用。 Java文件引用资源文件的格式： ResourceTable.type_ name 。特别地，如果引用的是系统资源，则采用： ohos.global.systemres.ResourceTable.type_name 。 示例一：在Java文件中，引用 string.json 文件中类型为“String”、名称为“app_name”的资源。 ohos.global.resource.ResourceManager resManager = this.getResourceManager();String result = resManager.getElement(ResourceTable.String_app_name).getString(); 示例二：在Java文件中，引用 color.json 文件中类型为“Color”、名称为“red”的资源。 ohos.global.resource.ResourceManager resManager = this.getResourceManager();int color = resManager.getElement(ResourceTable.Color_red).getColor(); XML文件引用资源文件的格式： $type:name 。特别地，如果引用的是系统资源，则采用： $ohos:type:name 。 在XML文件中，引用string.json文件中类型为“String”、名称为“app_name”的资源，示例如下： rawfile目录中的资源文件：通过指定文件路径和文件名称来引用。 在Java文件中，引用一个路径为“resources/rawfile/”、名称为“example.js”的资源文件，示例如下： ohos.global.resource.ResourceManager resManager = this.getResourceManager();ohos.global.resource.RawFileEntry rawFileEntry = resManager.getRawFileEntry(\"resources/rawfile/example.js\"); 系统资源文件 目前支持的部分系统资源文件详见表1。 系统资源名称 含义 类型 ic_app 表示HarmonyOS应用的默认图标。 媒体 request_location_reminder_title 表示“请求使用设备定位功能”的提示标题。 字符串 request_location_reminder_content 表示“请求使用设备定位功能”的提示内容，即：请在下拉快捷栏打开\"位置信息\"开关。 字符串 颜色模式的定义 应用可以在config.json的module字段下定义“colorMode”字段，“colorMode”字段用来定义应用自身的颜色模式，值可以是“dark”，“light”，“auto”（默认值）。示例： \"colorMode\": \"light\" 当应用的颜色模式值是“dark”时，无论系统当前颜色模式是什么，应用始终会按照深色模式选取资源；同理，当应用的颜色模式值是“light”时，无论系统当前颜色模式是什么，应用始终会按照浅色模式选取资源；当应用的颜色模式值是“auto”时，应用会跟随系统的颜色模式值选取资源。应用可以在代码中通过如下方式获取应用当前的颜色模式： int colorMode = Configuration.colorMode; 为Element资源文件添加注释或特殊标识 Element目录下的不同种类元素的资源均采用JSON文件表示，资源的名称“name”和取值“value”是每一条资源的必备字段。 如果需要为某一条资源备注信息，以便于资源的理解和使用，可以通过comment字段添加注释。 如果value字段中的部分文本不需要被翻译人员处理，也不会被显示在应用界面上，可以通过特殊结构来标识无需翻译的内容。 通过comment字段添加注释 通过comment字段，可以为JSON文件的资源添加注释。示例如下： { \"string\":[ { \"name\":\"message_arrive\", \"value\":\"We will arrive at %s\", \"comment\":\"Transfer Arrival Time. %s is time,like 5:00 am\" } ]} 通过特殊结构来标识无需翻译的内容 在string、strarray、plural这三类资源中，可以通过特殊标识来处理无需被翻译的内容。例如，一个字符串资源的Value取值为“We will arrive at %s”，其中的变量“%s”在翻译过程中希望保持不变。有以下两种方式处理： 方式一：在value字段中添加{}。示例如下： { \"string\":[ { \"name\":\"message_arrive\", \"value\":[\"We will arrive at\",{ \"id\":\"time\", \"example\":\"5:00 am\", \"value\":\"%s\" } ] } ]} 方式二：添加标记对。示例如下： { \"string\":[ { \"name\":\"message_arrive\", \"value\":\"We will arrive at %s\" } ]} boolean.json示例 { \"boolean\":[ { \"name\":\"boolean_1\", \"value\":true }, { \"name\":\"boolean_ref\", \"value\":\"$boolean:boolean_1\" } ]} color.json示例 { \"color\":[ { \"name\":\"red\", \"value\":\"#ff0000\" }, { \"name\":\"red_ref\", \"value\":\"$color:red\" } ]} float.json示例 { \"float\":[ { \"name\":\"float_1\", \"value\":\"30.6\" }, { \"name\":\"float_ref\", \"value\":\"$float:float_1\" }, { \"name\":\"float_px\", \"value\":\"100px\" } ]} intarray.json示例 { \"intarray\":[ { \"name\":\"intarray_1\", \"value\":[ 100, 200, \"$integer:integer_1\" ] } ]} integer.json示例 { \"integer\":[ { \"name\":\"integer_1\", \"value\":100 }, { \"name\":\"integer_ref\", \"value\":\"$integer:integer_1\" } ]} pattern.json示例 { \"pattern\":[ { \"name\":\"base\", \"value\":[ { \"name\":\"width\", \"value\":\"100vp\" }, { \"name\":\"height\", \"value\":\"100vp\" }, { \"name\":\"size\", \"value\":\"25px\" } ] }, { \"name\":\"child\", \"parent\":\"base\", \"value\":[ { \"name\":\"noTitile\", \"value\":\"Yes\" } ] } ]} plural.json示例 { \"plural\":[ { \"name\":\"eat_apple\", \"value\":[ { \"quantity\":\"one\", \"value\":\"%d apple\" }, { \"quantity\":\"other\", \"value\":\"%d apples\" } ] } ]} strarray.json示例 { \"strarray\":[ { \"name\":\"size\", \"value\":[ { \"value\":\"small\" }, { \"value\":\"$string:hello\" }, { \"value\":\"large\" }, { \"value\":\"extra large\" } ] } ]} string.json示例 { \"string\":[ { \"name\":\"hello\", \"value\":\"hello base\" }, { \"name\":\"app_name\", \"value\":\"my application\" }, { \"name\":\"app_name_ref\", \"value\":\"$string:app_name\" }, { \"name\":\"app_sys_ref\", \"value\":\"$ohos:string:request_location_reminder_title\" } ]} "},"guo-ji-hua.html":{"url":"guo-ji-hua.html","title":"国际化","keywords":"","body":"国际化能力的支持 时间日期国际化 不同的区域具有不同的时间日期显示习惯。例如，英语（美国）区域short时间格式为“9:31 AM”；简体中文（中国）区域short时间格式为“上午9:31”；芬兰语（芬兰）区域short时间格式为“9.31”。因此为开发者提供了获取不同区域的时间日期规格的能力。 界面时间日期字串和时间类控件显示，应当遵循当地习惯的规则，当需要展示时间或日期时，建议获取当前地区的时间日期规格，并对显示的字串根据获取到的规格进行格式化后再使用。 示例1： Locale locale = new Locale(\"de\", \"CH\");String skeleton = \"MMMMd\";String bestPattern = DateFormatUtil.getBestPattern(skeleton, locale); // 返回值为\"d. MMMM\" 示例2： String languageTag = \"zh\";String out = DateFormatUtil.format(\"EEEEdMMMMy\", languageTag, \"Asia/Shanghai\", 0, 3600 * 1000); // 返回值为\"1970年1月1日星期四\" 电话号码国际化 不同的区域的电话号码有不同的格式化效果，当需要展示本地电话号码时，应遵循当地电话号码的格式化原则。因此为开发者提供了对不同地区电话号码格式化的能力，以便于在显示电话号码时正确的格式化。并提供了获取电话号码归属地的能力，开发者可以使用相关接口获取电话号码的归属地信息。 示例1： InputFormatter formatter = InputFormatter.getInstance(\"CN\");formatter.inputNumberAndRememberPosition('1'); // 返回值为\"1\"formatter.inputNumber('5'); // 返回值为\"15\"formatter.inputNumber('6'); // 返回值为\"156\"formatter.inputNumberAndRememberPosition('1');// 返回值为\"156 1\" 示例2： Locale.Builder builder = new Locale.Builder();builder.setLanguage(\"zh\");builder.setRegion(\"CN\");builder.setScript(\"Hant\");Locale locale = builder.build();String displayName = PhoneNumberAttribution.getAttribute(\"+8615611xxxxxx\", \"CN\", locale); // x为任意数字，返回值为\"北京市\" 文本识别 提供了对地址、时间日期与电话号码的文本识别能力，可以调用相关接口识别一段文本中包含的地址、时间日期与电话号码。 示例： // 当Locale.getDefault().getLanguage()为\"en\"时String source = \"it is 123 test St\";int[] re = TextRecognitionUtils.getAddress(source);if (re[0] == 1) { result = source.substring(re[1], re[2] + 1);// 返回值为\"123 main St\"} 度量衡格式化 提供了对度量衡国际化能力的支持，可支持度量衡体系和维度之间的转换，与不同国家度量衡体系的自动转换。在开发包含度量衡的功能时，可以调用此能力满足多语言和不同国家用户的需求。 示例1： Locale zhCN = Locale.CHINA;MeasureFormatter mes = MeasureFormatter.getInstance(zhCN);mes.format(MeasureOptions.Unit.AREA_UK_ACRE, 10000, MeasureOptions.Usage.AREA_LAND_AGRICULT, MeasureOptions.FormatStyle.WIDE, MeasureOptions.Style.AUTO_STYLE_ON));// 返回值为\"4,046.856公顷\" 示例2： Locale enUS = Locale.US;MeasureFormatter mes = MeasureFormatter.getInstance(enUS);mes.format(MeasureOptions.Unit.VOLUME_US_CUP, 1000, MeasureOptions.Unit.VOLUME_SI_LITER, MeasureOptions.FormatStyle.WIDE));// 返回值为\"236.588 liters\" 敏感禁忌 提供对政治敏感地区、城市、及语言的获取能力，以及对地区名称更正的能力。 示例： Locale locale = Locale.getDefault();ArrayList result = LocaleHelperUtils.getBlockedRegions(context, locale);//返回值包含\"EH\"与\"XK\"(西撒哈拉与科索沃），这两个地区为有政治争议的地区需谨慎使用 "},"ying-yong-shu-ju-guan-li.html":{"url":"ying-yong-shu-ju-guan-li.html","title":"应用数据管理","keywords":"","body":"应用数据管理 HarmonyOS应用数据管理支持单设备的各种结构化数据的持久化，以及跨设备之间数据的同步、共享以及搜索功能。开发者通过应用数据管理，能够方便地完成应用程序数据在不同终端设备间的无缝衔接，满足用户跨设备使用数据的一致性体验。 本地应用数据管理 提供单设备上结构化数据的存储和访问能力。使用SQLite作为持久化存储引擎，提供了多种类型的本地数据库，分别是关系型数据库（Relational Database）和对象关系映射数据库（Object Relational Mapping Database），此外还提供一种轻量级偏好数据库（Light Weight Preference Database），用以满足开发人员使用不同数据模型对应用数据进行持久化和访问的需求。 有关于本地应用数据管理的详细信息，请参阅关系型数据库、对象关系映射数据库和轻量级偏好数据库。 分布式数据服务 分布式数据库支持用户数据跨设备相互同步，为用户提供在多种终端设备上一致的数据访问体验。通过调用分布式数据接口，应用可以将数据保存到分布式数据库中。通过结合帐号、应用唯一标识和数据库三元组，分布式数据库对属于不同应用的数据进行隔离。 有关于分布式数据库的详细信息，请参阅分布式数据服务。 分布式文件服务 在多个终端设备间为单个设备上应用程序创建的文件提供多终端的分布式共享能力。每台设备上都存储一份全量的文件元数据，应用程序通过文件元数据中的路径，可以实现同一应用文件的跨设备访问。 有关于分布式文件的详细信息，请参阅分布式文件服务。 数据搜索服务 在单个设备上，为应用程序提供搜索引擎级的全文索引管理、建立索引和搜索功能。 有关于数据搜索的详细信息，请参阅融合搜索。 数据存储管理 为应用开发者提供系统存储路径、存储设备列表，存储设备属性的查询和管理功能。 有关于数据存储的详细信息，请参阅数据存储管理。 "},"ying-yong-quan-xian-guan-li.html":{"url":"ying-yong-quan-xian-guan-li.html","title":"应用权限管理","keywords":"","body":"应用权限管理 HarmonyOS中所有的应用均在应用沙盒内运行。默认情况下，应用只能访问有限的系统资源，系统负责管理应用对资源的访问权限。 应用权限管理是由接口提供方（Ability）、接口使用方（应用）、系统（包括云侧和端侧）以及用户等多方共同参与的整个流程，保证受限接口是在约定好的规则下被正常使用，避免接口被滥用而导致用户、应用和设备受损。 本节重点介绍应用权限管理的基本思想。有关权限使用的详细信息，请参阅权限。 权限声明 应用需要在config.json中使用“reqPermissions”属性对需要的权限逐个进行声明。 若使用到的三方库也涉及权限使用，也需统一在应用的config.json中逐个声明。 没有在config.json中声明的权限，应用就无法获得此权限的授权。 动态申请敏感权限 动态申请敏感权限基于用户可知可控的原则，需要应用在运行时主动调用系统动态申请权限的接口，系统弹框由用户授权，用户结合应用运行场景的上下文，识别出应用申请相应敏感权限的合理性，从而做出正确的选择。 即使用户向应用授予了请求的权限，应用在调用受此权限管控的接口前，也应该先检查自己有无此权限，而不能把之前授予的状态持久化，因为用户在动态授予后还可以通过设置取消应用的权限。 有关于应用动态申请敏感权限的详细信息，请参阅动态申请权限。 自定义权限 HarmonyOS为了保证应用对外提供的接口不被恶意调用，需要对调用接口的调用者进行鉴权。 大多情况下，系统已定义的权限满足了应用的基本需要，若有特殊的访问控制需要，应用可在config.json中以\"defPermissions\": []属性来定义新的权限，并通过“availableScope”和“grantMode”两个属性分别确定权限的开放范围和授权方式，使得权限定义更加灵活且易于理解。有关HarmonyOS权限开放范围和授权方式详细的描述，请参阅权限授予方式字段说明和权限限制范围字段说明。 为了避免应用自定义新权限出现重名的情况，建议应用对新权限的命名以包名的前两个字段开头，这样可以防止不同开发者的应用间出现自定义权限重名的情况。 权限保护方法 保护Ability：通过在config.json里对应的Ability中配置\"permissions\": [\"权限名\"]属性，即可实现保护整个Ability的目的，无指定权限的应用不能访问此Ability。 保护API：若Ability对外提供的数据或能力有多种，且开放范围或保护级别也不同，可以针对不同的数据或能力在接口代码实现中通过verifyPermission(String permissionName, int pid, int uid)来对uid标识的调用者进行鉴权。 权限使用原则 权限申请最小化。跟用户提供的功能无关的权限，不要申请；尽量采用其他无需权限的操作来实现相应功能（如：通过intent拉起系统UI界面由用户交互、应用自己生成uuid代替设备ID等）。 权限申请完整。应用所需权限（包括应用调用到的三方库依赖的权限）都要逐个在应用的config.json中按格式声明。 满足用户可知。应用申请的敏感权限的目的需要真实准确告知用户。 权限就近申请。应用在用户触发相关业务功能时，就近提示用户授予实现此功能所需的权限。 权限不扩散。在用户未授权的情况下，不允许提供给其他应用使用。 应用自定义权限防止重名。建议以包名为前缀来命名权限，防止跟系统定义的权限重名。 "},"ying-yong-yin-si-bao-hu.html":{"url":"ying-yong-yin-si-bao-hu.html","title":"应用隐私保护","keywords":"","body":"应用隐私保护 更新时间: 2021-06-04 15:12 随着移动终端及其相关业务（如移动支付、终端云等）的普及，用户隐私保护的重要性愈发突出。应用开发者在产品设计阶段就需要考虑用户隐私的保护，提高应用的安全性。HarmonyOS应用开发需要遵从其隐私保护规则，在应用上架应用市场时，应用市场会根据规则进行校验，如不满足条件则无法上架。 个人数据是指与一个身份已被识别或者身份可被识别的自然人相关的任何信息，包括但不限于个人身份信息、身份验证信息、财务和付款信息、联系方式、用户搜索、浏览记录、使用习惯、位置信息、短信和通话相关数据、麦克风数据、摄像头数据以及其他设备或应用使用情况数据等，其中敏感个人数据是个人数据的一个重要子集，指的是涉及数据主体的最私密领域的信息或者一旦泄露可能会给数据主体造成重大不利影响的数据，如导致个人名誉、身心健康受到损害或歧视性待遇等；敏感个人数据在各国家/地区相关法律法规中的定义有所不同，建议根据当地的法律法规要求处理。 数据收集及使用公开透明 应用采集个人数据时，应清晰、明确地告知用户，并确保告知用户的个人信息将被如何使用。 应用申请操作系统 敏感权限 时，需要明确告知用户权限申请的目的和用途，并获取用户的同意；敏感权限弹框参考示例如下。权限API使用方案请参考 权限 章节。详细的设计原则请参考 隐私设计 。 图1 敏感权限获取弹框示例 开发者应制定并遵从适当的隐私政策，在收集、使用留存和第三方分享用户数据时需要符合所有适用法律、政策和规定。如在收集个人数据前，需充分告知用户处理个人数据的种类、目的、处理方式、保留期限等，满足数据主体权利等要求。 应用向第三方披露任何个人信息须在隐私政策中说明披露内容、目的和披露对象。 根据以上要求，我们设计了示例以供参考。隐私通知/声明的参考示例如下： 图2 应用隐私通知与隐私声明示例图 个人数据应当基于具体、明确、合法的目的收集，不应与此目的不相符的方式作进一步处理。对于收集目的变更和用户撤销同意后再次使用的场景都需要用户重新同意。隐私声明变更与隐私声明撤销同意如图所示。 图3 隐私声明变更示例图 图4 隐私声明撤销同意示例图 应用需要提供用户查看隐私声明的入口。例如在应用的“关于”界面提供查看隐私声明的入口，如示例图所示： 图5 隐私声明的查看界面示例图 应用的隐私声明应覆盖本应用所有收集的个人数据。 在后台持续读取位置信息场景时，请申请ohos.permission.LOCATION_IN_BACKGROUND权限，详见敏感权限； 应用存在调用第三方的元能力（Particle Ability）或元服务（Feature Ability）场景时，需要在应用的隐私声明中明确第三方责任，如涉及个人数据收集则需要告知用户第三方的名称及收集的个人数据类型、目的和方式，申请的敏感权限、申请目的等。 数据收集及使用最小化 应用个人数据收集应与数据处理目的相关，且是适当、必要的。开发者应尽可能对个人数据进行匿名化或假名化处理，降低数据主体的风险。仅可收集和处理与特定目的相关且必需的个人数据，不能对数据做出与特定目的不相关的处理。 敏感权限申请的时候要满足权限最小化的要求，在进行权限申请时，只申请获取必需的信息或资源所需要的权限。如应用不需要相机权限就能够实现其功能时，则不应该向用户申请相机权限。 应用针对数据的收集要满足最小化要求，不收集与应用提供服务无关联的数据。如通信社交类应用，不应收集用户的网页浏览记录。 数据使用的功能要求能够使用户受益，收集的数据不能用于与用户正常使用无关的功能。如应用不得将“生物特征”、“健康数据”等敏感个人数据用于服务改进、投放广告或营销等非业务核心功能。 系统禁止应用在后台访问相机和麦克风的数据； 应用使用第三方支付交易过程中，如非适用法律要求或为提供第三方支付服务所必需，不得记录用户交易类鉴权信息，或向第三方批露与用户特定交易无关的用户个人信息。 应用不得仅出于广告投放或数据分析的目的而请求位置权限。 禁止在日志中打印敏感个人数据，如需要打印个人数据时，应对个人数据进行匿名化或假名化处理； 避免使用IMEI和序列号等永久性的标识符，尽量使用可以重置的标识符，如系统提供了NetworkID和DVID作为分布式场景下的设备标识符，广告业务场景下则建议使用OAID，基于应用的分析则建议使用ODID和AAID，其他需要唯一标识符的场景可以使用UUID接口生成； 不再需要使用的数据需要及时清除，降低数据泄露的风险。如分布式业务场景下设备断开分布式网络，临时缓存的数据需要及时删除。 数据处理选择和控制 对个人数据处理必须要征得用户的同意或遵守适用的法律法规，用户对其个人数据要有充分的控制权。 系统对于用户的敏感数据和系统关键资源的获取设置了对应的权限，应用访问这些数据时需要申请对应的权限。相关权限列表请参考应用权限列表章节。 应用申请使用敏感权限：应用弹窗提醒，向用户呈现应用需要获取的权限和权限使用目的、应用需要收集的数据和使用目的等，通过用户点击“同意”或“始终允许”的方式完成用户授权，让用户对应用权限的授予和个人数据的使用做到透明、可知、可控。 用户可以修改、取消授予应用的权限：当用户不同意某一权限或者数据收集时，应当允许用户使用与这部分权限和数据收集不相关的功能。如通信社交类应用，用户可以拒绝授予相机权限，不应该影响与相机无关的功能操作，如语音通话。 在进入应用的主界面之前不建议直接弹窗申请敏感权限，仅在用户使用功能时才请求对应的权限。如通信社交类应用，在没有启用位置相关的功能时，不建议在启动应用时就申请位置权限。 应用若使用个人数据用于个性化广告和精准营销，需提供独立的关闭选项。 需要向用户提供对个人数据的控制能力；如在云服务上存储了个人数据，需要提供删除数据的方法。 应用同时支持单设备和跨设备场景时，用户能够单独关闭跨设备应用场景。 数据安全 从技术上保证数据处理活动的安全性，包括个人数据的加密存储、安全传输等安全机制，应默认开启或采取安全保护措施。 数据存储 应用产生的密钥以及用户的敏感个人数据需要存储在应用的私有目录下。 应用可以调用系统提供的本地数据库RdbStore的加密接口对敏感个人数据进行加密存储。接口详见关系型数据库章节。 应用产生的分布式数据可以调用系统的分布式数据库进行存储，对于敏感个人数据需要采用分布式数据库提供的加密接口进行加密，接口详见分布式数据服务章节。 安全传输 需要分别针对本地传输和远程传输采取不同的安全保护措施。 本地传输： 应用通过intent跨应用传输数据时避免包含敏感个人数据，防止隐式调用导致intent劫持，导致个人数据泄露。 应用内组件调用应采用安全方式，避免通过隐式方式进行调用组件，防止组件劫持。 避免使用socket方式进行本地通信，如需使用，localhost端口号随机生成，并对端口连接对象进行身份认证和鉴权。 本地IPC通信安全：作为服务提供方需要校验服务使用方的身份和访问权限，防止服务使用方进行身份仿冒或者权限绕过。 远程传输： 使用https代替http进行通信，并对https证书进行严格校验。 避免进行远程端口进行通信，如需使用，需要对端口连接对象进行身份认证和鉴权。 应用进行跨设备通信时，需要校验被访问设备和应用的身份信息，防止被访问方的设备和应用进行身份仿冒。 应用进行跨设备通信时，作为服务提供方需要校验服务使用方的身份和权限，防止服务使用方进行身份仿冒或者权限绕过。 本地化处理 应用开发的数据优先在本地进行处理，对于本地无法处理的数据上传云服务要满足最小化的原则，不能默认选择上传云服务。 未成年人数据保护要求 如果应用是给未成年人设计的，或者应用通过收集的用户年龄数据识别出用户是未成年人，开发者应该结合目标市场国家的相关法律，专门分析未成年人个人数据保护的问题。收集未成年人数据前需要征得监护人的同意。 专为未成年人设计的应用不建议请求获取位置权限。 元服务（Feature Ability） 对于Visible=true的元服务，需要满足如下要求： 元服务启动时，需要在明显位置展示元服务的功能名称及开发者名称/logo。 元服务如涉及个人数据的收集，应提供独立的隐私声明，并在收集个人数据前向用户告知隐私声明。 元服务应按照法律法规要求收集个人数据，基于用户同意收集的个人数据，用户有权撤销同意。 元服务需要提供隐私声明的查看入口。 元服务隐私声明发生变更时，需要用户重新同意。 禁止在元服务免安装过程中捆绑安装与本服务不相关的功能，如扫描二维码的元服务不应该支持录音功能。 "},"san-fang-ying-yong-diao-yong-guan-kong-ji-zhi.html":{"url":"san-fang-ying-yong-diao-yong-guan-kong-ji-zhi.html","title":"三方应用调用管控机制","keywords":"","body":"三方应用调用管控机制 为什么要进行调用管控 后台进程启动过多，会消耗系统的内存、CPU等资源，造成用户设备耗电快、卡顿等现象。因此，为了保证用户体验，系统会对三方用户应用程序之间的PA调用进行管控，减少不必要的关联拉起。 相关概念 前台：用户应用程序有可见的FA正在显示，则认为用户应用程序在前台。 用户应用程序内调用：同一用户应用程序内的FA、PA之间的访问。 调用管控总体思路 用户应用程序内调用不管控。 三方用户应用程序间调用严格管控：禁止三方用户应用程序在后台调用其他三方应用的PA；严格管控三方用户应用程序在前台调用其他用户应用程序的PA。 管控规则 用户应用程序内调用 不管控。 三方用户应用程序间调用 三方应用程序A调用三方应用程序B的PA，具体限制如下： 禁止A在后台调用B的PA。 当B有进程存活时，允许A在前台调用B的PA；当B无进程存活时，禁止A的调用。 "},"kaifazhunbei.html":{"url":"kaifazhunbei.html","title":"开发准备","keywords":"","body":"开发准备 任务说明 本文档适用于HarmonyOS应用开发的初学者。通过构建一个简单的具有页面跳转功能的应用（如下图预览器运行效果所示），熟悉HarmonyOS应用开发流程。 为确保运行效果，请使用最新版本的DevEco Studio完成本任务，点击此处获取下载链接。 开发准备 开始前请参考下载与安装软件、配置开发环境，完成DevEco Studio的安装和开发环境的配置。 开发环境配置完成后，请参考创建和运行Hello World创建一个新工程，设备类型以“Phone”为例，使用Java语言开发，模板选择“Empty Feature Ability(Java)”。 工程创建完成后，使用预览器或Phone模拟器运行该工程。 完成上述操作后，请继续下一步的学习。 "},"diyigeyemian.html":{"url":"diyigeyemian.html","title":"编写第一个页面","keywords":"","body":"编写第一个页面 更新时间: 2021-06-02 21:03 在Java UI框架中，提供了两种编写布局的方式：在XML中声明UI布局和在代码中创建布局。这两种方式创建出的布局没有本质差别，为了熟悉两种方式，我们将通过XML的方式编写第一个页面，通过代码的方式编写第二个页面。 在“Project”窗口，点击“entry > src > main > resources > base > layout”，打开“ability_main.xml”文件。 第一个页面内有一个文本和一个按钮，使用DependentLayout布局，通过Text和Button组件来实现，其中vp和fp分别表示虚拟像素和字体像素。“ability_main.xml”的示例代码如下： 按钮的背景是蓝色胶囊样式，可以通过graphic目录下的XML文件来设置。 右键点击“graphic”文件夹，选择“New > File”，命名为“background_button.xml”，单击回车键。 “background_button.xml”的示例代码如下： 在layout目录下的“ability_main.xml”文件中，使用background_element=\"$graphic:background_button\"的方式引用“background_button.xml”文件： 在XML文件中添加组件后，需要在Java代码中加载XML布局。 在“Project”窗口，选择“entry > src > main > java > com.example.myapplication > slice” ，打开“MainAbilitySlice.java”文件，使用setUIContent方法加载“ability_main.xml”布局。 说明 HarmonyOS提供了Ability和AbilitySlice两个基础类，一个有界面的Ability可以由一个或多个AbilitySlice构成，AbilitySlice主要用于承载单个页面的具体逻辑实现和界面UI，是应用显示、运行和跳转的最小单元。 本文档以同一个Ability内的两个AbilitySlice之间的跳转为例，如果开发者希望实现两个Ability之间的跳转，请参考不同Page间导航。 “MainAbilitySlice.java”的示例代码如下： package com.example.myapplication.slice; import com.example.myapplication.ResourceTable;import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent; public class MainAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); // 加载XML布局 }} 使用预览器或模拟器运行项目，效果如下图所示。 "},"lingyigeyemian.html":{"url":"lingyigeyemian.html","title":"创建另一个页面","keywords":"","body":"创建另一个页面 在上一节中，我们用XML的方式编写了一个包含文本和按钮的页面。为了帮助开发者熟悉在代码中创建布局的方式，接下来我们使用代码的方式编写第二个页面。 在“Project”窗口，打开“entry > src > main > java > com.example.myapplication”，右键点击“slice”文件夹，选择“New > Java Class”，命名为“SecondAbilitySlice”，单击回车键。 第二个页面上有一个文本。在上一步创建的“SecondAbilitySlice”文件中，添加一个Text，示例代码如下： package com.example.myapplication.slice; import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.colors.RgbColor;import ohos.agp.components.DependentLayout;import ohos.agp.components.Text;import ohos.agp.components.element.ShapeElement;import ohos.agp.utils.Color;import ohos.agp.components.DependentLayout.LayoutConfig; public class SecondAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 声明布局 DependentLayout myLayout = new DependentLayout(this); // 设置布局宽高 myLayout.setWidth(LayoutConfig.MATCH_PARENT); myLayout.setHeight(LayoutConfig.MATCH_PARENT); // 设置布局背景为白色 ShapeElement background = new ShapeElement(); background.setRgbColor(new RgbColor(255, 255, 255)); myLayout.setBackground(background); // 创建一个文本 Text text = new Text(this); text.setText(\"Hi there\"); text.setWidth(LayoutConfig.MATCH_PARENT); text.setTextSize(100); text.setTextColor(Color.BLACK); // 设置文本的布局 DependentLayout.LayoutConfig textConfig = new DependentLayout.LayoutConfig(LayoutConfig.MATCH_CONTENT, LayoutConfig.MATCH_CONTENT); textConfig.addRule(LayoutConfig.CENTER_IN_PARENT); text.setLayoutConfig(textConfig); myLayout.addComponent(text); super.setUIContent(myLayout); }} "},"shi-xian-ye-mian-tiao-zhuan.html":{"url":"shi-xian-ye-mian-tiao-zhuan.html","title":"实现页面跳转","keywords":"","body":"实现页面跳转 打开第一个页面的“MainAbilitySlice.java”文件，添加按钮的响应逻辑，实现点击按钮跳转到下一页，示例代码如下： package com.example.myapplication.slice; import com.example.myapplication.ResourceTable; import ohos.aafwk.ability.AbilitySlice; import ohos.aafwk.content.Intent; import ohos.agp.components.Button; public class MainAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); Button button = (Button) findComponentById(ResourceTable.Id_button); // 点击按钮跳转至第二个页面 button.setClickedListener(listener -> present(new SecondAbilitySlice(), new Intent())); } } 再次运行项目，效果如下图所示。 恭喜你，至此已成功完成HarmonyOS快速入门。 "},"develop-overview.html":{"url":"develop-overview.html","title":"开发概述","keywords":"","body":"开发概述 通用开发历程 各类设备（手机/平板、智能穿戴、智慧屏等）通用的用户应用程序开发历程如下表所示。 任务 简介 相关资源 开发Ability Ability是HarmonyOS应用程序的重要组成部分，分为FA（Feature Ability）和PA（Particle Ability）两种类型：FA支持Page Ability：Page模板是FA唯一支持的模板，用于提供与用户交互的能力。PA支持Service Ability和Data Ability：Service模板用于提供后台运行任务的能力；Data模板用于对外部提供统一的数据访问抽象。进行HarmonyOS应用开发，首先要了解Ability如何使用。 Page AbilityService AbilityData Ability 开发UI FA需要提供UI用于与用户进行交互，HarmonyOS提供了Java UI和JS UI两种UI框架：Java UI提供了细粒度的UI编程接口，使应用开发更加灵活；JS UI提供了相对高层的UI描述，使应用开发更加简单。说明针对轻量级智能穿戴（Lite Wearable），现阶段只使用JS语言进行应用开发，详见轻量级智能穿戴开发。 Java UI框架Java API参考JS UI框架JS API参考 开发业务功能 媒体：视频、音频、图像、相机等功能的开发。安全：权限、生物特征识别等功能的开发。AI：图像超分、语音识别、码生成等功能的开发。网络连接：NFC、蓝牙、WLAN等功能的开发。设备管理：传感器、控制类小器件、位置等功能的开发。数据管理：数据库、分布式数据/文件服务、数据搜索等功能的开发。线程：线程管理、线程间通信等功能的开发。IDL：声明系统服务和Ability对外提供的服务接口，并生成相关代码。 媒体开发指南安全开发指南AI开发指南网络与连接开发指南设备管理开发指南数据管理开发指南线程开发指南IDL接口使用指南 原子化服务开发历程 HarmonyOS除支持传统方式的需要安装的应用外，还支持提供特定功能的免安装的应用（即原子化服务），供用户在合适的场景、合适的设备上便捷使用。 原子化服务相对于传统方式的需要安装的应用更加轻量，同时提供更丰富的入口、更精准的分发。原子化服务的详细介绍请参见“原子化服务”。 其基本开发历程如下表所示。 任务 开发历程 相关内容 了解HarmonyOS 了解HarmonyOS的系统定位、技术特性、应用开发的基本概念和基础知识，熟悉HarmonyOS应用开发通用流程。 HarmonyOS概述开发基础知识快速入门 设计原子化服务 在设计阶段，需要满足原子化服务的设计规范，包括图标、卡片、分布式等规范。 原子化服务设计 掌握原子化服务约束 了解原子化服务之间的调用管控机制。 三方应用调用管控机制 开发原子化服务基础体验 了解原子化服务总体开发规则、如何开发服务卡片等基础体验。 原子化服务总体开发要求服务卡片开发指南 开发原子化服务分布式体验 了解如何开发流转、分享等分布式体验。 流转开发指南华为分享接入指南 "},"ability-overview.html":{"url":"ability-overview.html","title":"Ability概述","keywords":"","body":"Ability概述 Ability是应用所具备能力的抽象，也是应用程序的重要组成部分。一个应用可以具备多种能力（即可以包含多个Ability），HarmonyOS支持应用以Ability为单位进行部署。Ability可以分为FA（Feature Ability）和PA（Particle Ability）两种类型，每种类型为开发者提供了不同的模板，以便实现不同的业务功能。 FA支持 Page Ability ： Page模板是FA唯一支持的模板，用于提供与用户交互的能力。一个Page实例可以包含一组相关页面，每个页面用一个AbilitySlice实例表示。 PA支持 Service Ability 和 Data Ability ： Service模板：用于提供后台运行任务的能力。 Data模板：用于对外部提供统一的数据访问抽象。 在配置文件（config.json）中注册Ability时，可以通过配置Ability元素中的“type”属性来指定Ability模板类型，示例如下。 其中，“type”的取值可以为“page”、“service”或“data”，分别代表Page模板、Service模板、Data模板。为了便于表述，后文中我们将基于Page模板、Service模板、Data模板实现的Ability分别简称为Page、Service、Data。 { \"module\": { ... \"abilities\": [ { ... \"type\": \"page\" ... } ] ... } ...} 相关实例 针对Ability开发，有以下Codelabs可供参考： 分布式亲子早教系统 基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。 分布式新闻客户端 基于HarmonyOS应用中Service Ability和Page Ability的使用，实现跨设备FA拉起。 跨设备视频播放 基于分布式能力和IDL跨进程通信，实现视频跨设备播放、控制。 分布式输入法 基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放。 分布式游戏手柄 基于分布式能力，将手机作为智慧屏的虚拟手柄终端，组成全新的多人娱乐场景。 "},"page-concept.html":{"url":"page-concept.html","title":"Page Ability基本概念","keywords":"","body":"Page Ability基本概念 Page与AbilitySlice Page模板（以下简称“Page”）是FA唯一支持的模板，用于提供与用户交互的能力。一个Page可以由一个或多个AbilitySlice构成，AbilitySlice是指应用的单个页面及其控制逻辑的总和。 当一个Page由多个AbilitySlice共同构成时，这些AbilitySlice页面提供的业务能力应具有高度相关性。例如，新闻浏览功能可以通过一个Page来实现，其中包含了两个AbilitySlice：一个AbilitySlice用于展示新闻列表，另一个AbilitySlice用于展示新闻详情。Page和AbilitySlice的关系如图1所示。 图1 Page与AbilitySlice 相比于桌面场景，移动场景下应用之间的交互更为频繁。通常，单个应用专注于某个方面的能力开发，当它需要其他能力辅助时，会调用其他应用提供的能力。例如，外卖应用提供了联系商家的业务功能入口，当用户在使用该功能时，会跳转到通话应用的拨号页面。与此类似，HarmonyOS支持不同Page之间的跳转，并可以指定跳转到目标Page中某个具体的AbilitySlice。 AbilitySlice路由配置 虽然一个Page可以包含多个AbilitySlice，但是Page进入前台时界面默认只展示一个AbilitySlice。默认展示的AbilitySlice是通过setMainRoute()方法来指定的。如果需要更改默认展示的AbilitySlice，可以通过addActionRoute()方法为此AbilitySlice配置一条路由规则。此时，当其他Page实例期望导航到此AbilitySlice时，可以在Intent中指定Action，详见不同Page间导航。 setMainRoute()方法与addActionRoute()方法的使用示例如下： public class MyAbility extends Ability { @Override public void onStart(Intent intent) { super.onStart(intent); // set the main route setMainRoute(MainSlice.class.getName()); // set the action route addActionRoute(\"action.pay\", PaySlice.class.getName()); addActionRoute(\"action.scan\", ScanSlice.class.getName()); }} addActionRoute()方法中使用的动作命名，需要在应用配置文件（config.json）中注册： { \"module\": { \"abilities\": [ { \"skills\":[ { \"actions\":[ \"action.pay\", \"action.scan\" ] } ] ... } ] ... } ...} "},"page-lifecycle.html":{"url":"page-lifecycle.html","title":"Page Ablity生命周期","keywords":"","body":"Page Ablity生命周期 系统管理或用户操作等行为均会引起Page实例在其生命周期的不同状态之间进行转换。Ability类提供的回调机制能够让Page及时感知外界变化，从而正确地应对状态变化（比如释放资源），这有助于提升应用的性能和稳健性。 Page生命周期回调 Page生命周期的不同状态转换及其对应的回调，如图1所示。 图1 Page生命周期 onStart() 当系统首次创建Page实例时，触发该回调。对于一个Page实例，该回调在其生命周期过程中仅触发一次，Page在该逻辑后将进入INACTIVE状态。开发者必须重写该方法，并在此配置默认展示的AbilitySlice。 @Override public void onStart(Intent intent) { super.onStart(intent); super.setMainRoute(FooSlice.class.getName()); } onActive() Page会在进入INACTIVE状态后来到前台，然后系统调用此回调。Page在此之后进入ACTIVE状态，该状态是应用与用户交互的状态。Page将保持在此状态，除非某类事件发生导致Page失去焦点，比如用户点击返回键或导航到其他Page。当此类事件发生时，会触发Page回到INACTIVE状态，系统将调用onInactive()回调。此后，Page可能重新回到ACTIVE状态，系统将再次调用onActive()回调。因此，开发者通常需要成对实现onActive()和onInactive()，并在onActive()中获取在onInactive()中被释放的资源。 onInactive() 当Page失去焦点时，系统将调用此回调，此后Page进入INACTIVE状态。开发者可以在此回调中实现Page失去焦点时应表现的恰当行为。 onBackground() 如果Page不再对用户可见，系统将调用此回调通知开发者用户进行相应的资源释放，此后Page进入BACKGROUND状态。开发者应该在此回调中释放Page不可见时无用的资源，或在此回调中执行较为耗时的状态保存操作。 onForeground() 处于BACKGROUND状态的Page仍然驻留在内存中，当重新回到前台时（比如用户重新导航到此Page），系统将先调用onForeground()回调通知开发者，而后Page的生命周期状态回到INACTIVE状态。开发者应当在此回调中重新申请在onBackground()中释放的资源，最后Page的生命周期状态进一步回到ACTIVE状态，系统将通过onActive()回调通知开发者用户。 onStop() 系统将要销毁Page时，将会触发此回调函数，通知用户进行系统资源的释放。销毁Page的可能原因包括以下几个方面： 用户通过系统管理能力关闭指定Page，例如使用任务管理器关闭Page。 用户行为触发Page的terminateAbility()方法调用，例如使用应用的退出功能。 配置变更导致系统暂时销毁Page并重建。 系统出于资源管理目的，自动触发对处于BACKGROUND状态Page的销毁。 AbilitySlice生命周期 AbilitySlice作为Page的组成单元，其生命周期是依托于其所属Page生命周期的。AbilitySlice和Page具有相同的生命周期状态和同名的回调，当Page生命周期发生变化时，它的AbilitySlice也会发生相同的生命周期变化。此外，AbilitySlice还具有独立于Page的生命周期变化，这发生在同一Page中的AbilitySlice之间导航时，此时Page的生命周期状态不会改变。 AbilitySlice生命周期回调与Page的相应回调类似，因此不再赘述。由于AbilitySlice承载具体的页面，开发者必须重写AbilitySlice的onStart()回调，并在此方法中通过setUIContent()方法设置页面，如下所示： @Override protected void onStart(Intent intent) { super.onStart(intent); setUIContent(ResourceTable.Layout_main_layout); } AbilitySlice实例创建和管理通常由应用负责，系统仅在特定情况下会创建AbilitySlice实例。例如，通过导航启动某个AbilitySlice时，是由系统负责实例化；但是在同一个Page中不同的AbilitySlice间导航时则由应用负责实例化。 Page与AbilitySlice生命周期关联 当AbilitySlice处于前台且具有焦点时，其生命周期状态随着所属Page的生命周期状态的变化而变化。当一个Page拥有多个AbilitySlice时，例如：MyAbility下有FooAbilitySlice和BarAbilitySlice，当前FooAbilitySlice处于前台并获得焦点，并即将导航到BarAbilitySlice，在此期间的生命周期状态变化顺序为： FooAbilitySlice从ACTIVE状态变为INACTIVE状态。 BarAbilitySlice则从INITIAL状态首先变为INACTIVE状态，然后变为ACTIVE状态（假定此前BarAbilitySlice未曾启动）。 FooAbilitySlice从INACTIVE状态变为BACKGROUND状态。 对应两个slice的生命周期方法回调顺序为： FooAbilitySlice.onInactive() --> BarAbilitySlice.onStart() --> BarAbilitySlice.onActive() --> FooAbilitySlice.onBackground() 在整个流程中，MyAbility始终处于ACTIVE状态。但是，当Page被系统销毁时，其所有已实例化的AbilitySlice将联动销毁，而不仅是处于前台的AbilitySlice。 "},"page-switching.html":{"url":"page-switching.html","title":"AbilitySlice间导航","keywords":"","body":"AbilitySlice间导航 同一Page内导航 当发起导航的AbilitySlice和导航目标的AbilitySlice处于同一个Page时，您可以通过present()方法实现导航。如下代码片段展示通过点击按钮导航到其他AbilitySlice的方法： @Overrideprotected void onStart(Intent intent) { ... Button button = ...; button.setClickedListener(listener -> present(new TargetSlice(), new Intent())); ... } 如果开发者希望在用户从导航目标AbilitySlice返回时，能够获得其返回结果，则应当使用presentForResult()实现导航。用户从导航目标AbilitySlice返回时，系统将回调onResult()来接收和处理返回结果，开发者需要重写该方法。返回结果由导航目标AbilitySlice在其生命周期内通过setResult()进行设置。 @Overrideprotected void onStart(Intent intent) { ... Button button = ...; button.setClickedListener(listener -> presentForResult(new TargetSlice(), new Intent(), 0)); ... } @Overrideprotected void onResult(int requestCode, Intent resultIntent) { if (requestCode == 0) { // Process resultIntent here. }} 系统为每个Page维护了一个AbilitySlice实例的栈，每个进入前台的AbilitySlice实例均会入栈。当开发者在调用present()或presentForResult()时指定的AbilitySlice实例已经在栈中存在时，则栈中位于此实例之上的AbilitySlice均会出栈并终止其生命周期。前面的示例代码中，导航时指定的AbilitySlice实例均是新建的，即便重复执行此代码（此时作为导航目标的这些实例是同一个类），也不会导致任何AbilitySlice出栈。 不同Page间导航 AbilitySlice作为Page的内部单元，以Action的形式对外暴露，因此可以通过配置Intent的Action导航到目标AbilitySlice。Page间的导航可以使用startAbility()或startAbilityForResult()方法，获得返回结果的回调为onAbilityResult()。在Ability中调用setResult()可以设置返回结果。详细用法可参考根据Operation的其他属性启动应用中的示例。 "},"cross-device.html":{"url":"cross-device.html","title":"跨设备迁移","keywords":"","body":"跨设备迁移 跨设备迁移（下文简称“迁移”）支持将Page在同一用户的不同设备间迁移，以便支持用户无缝切换的诉求。以Page从设备A迁移到设备B为例，迁移动作主要步骤如下： 设备A上的Page请求迁移。 HarmonyOS处理迁移任务，并回调设备A上Page的保存数据方法，用于保存迁移必须的数据。 HarmonyOS在设备B上启动同一个Page，并回调其恢复数据方法。 开发者可以参考以下详细步骤开发具有迁移功能的Page。 实现IAbilityContinuation接口 说明 一个应用可能包含多个Page，仅需要在支持迁移的Page中通过以下方法实现IAbilityContinuation接口。同时，此Page所包含的所有AbilitySlice也需要实现此接口。 onStartContinuation() Page请求迁移后，系统首先回调此方法，开发者可以在此回调中决策当前是否可以执行迁移，比如，弹框让用户确认是否开始迁移。 onSaveData() 如果onStartContinuation()返回true，则系统回调此方法，开发者在此回调中保存必须传递到另外设备上以便恢复Page状态的数据。 onRestoreData() 源侧设备上Page完成保存数据后，系统在目标侧设备上回调此方法，开发者在此回调中接受用于恢复Page状态的数据。注意，在目标侧设备上的Page会重新启动其生命周期，无论其启动模式如何配置。且系统回调此方法的时机在onStart()之前。 onCompleteContinuation() 目标侧设备上恢复数据一旦完成，系统就会在源侧设备上回调Page的此方法，以便通知应用迁移流程已结束。开发者可以在此检查迁移结果是否成功，并在此处理迁移结束的动作，例如，应用可以在迁移完成后终止自身生命周期。 onRemoteTerminated() 如果开发者使用continueAbilityReversibly()而不是continueAbility()，则此后可以在源侧设备上使用reverseContinueAbility()进行回迁。这种场景下，相当于同一个Page（的两个实例）同时在两个设备上运行，迁移完成后，如果目标侧设备上Page因任何原因终止，则源侧Page通过此回调接收终止通知。 请求迁移 实现IAbilityContinuation的Page可以在其生命周期内，调用continueAbility()或continueAbilityReversibly()请求迁移。两者的区别是，通过后者发起的迁移此后可以进行回迁。 try { continueAbility();} catch (IllegalStateException e) { // Maybe another continuation in progress. ...} 以Page从设备A迁移到设备B为例，详细的流程如下： 设备A上的Page请求迁移。 系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onStartContinuation()方法，以确认当前是否可以立即迁移。 如果可以立即迁移，则系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onSaveData()方法，以便保存迁移后恢复状态必须的数据。 如果保存数据成功，则系统在设备B上启动同一个Page，并恢复AbilitySlice栈，然后回调IAbilityContinuation.onRestoreData()方法，传递此前保存的数据；此后设备B上此Page从onStart()开始其生命周期回调。 系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onCompleteContinuation()方法，通知数据恢复成功与否。 请求回迁 使用continueAbilityReversibly()请求迁移并完成后，源侧设备上已迁移的Page可以发起回迁，以便使用户活动重新回到此设备。 try { reverseContinueAbility();} catch (IllegalStateException e) { // Maybe another continuation in progress. ...} 以Page从设备A迁移到设备B后并请求回迁为例，详细的流程如下： 设备A上的Page请求回迁。 系统回调设备B上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onStartContinuation()方法，以确认当前是否可以立即迁移。 如果可以立即迁移，则系统回调设备B上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onSaveData()方法，以便保存回迁后恢复状态必须的数据。 如果保存数据成功，则系统在设备A上Page恢复AbilitySlice栈，然后回调IAbilityContinuation.onRestoreData()方法，传递此前保存的数据。 如果数据恢复成功，则系统终止设备B上Page的生命周期。 相关实例 针对Page Ability开发，有以下示例工程可供参考： PageAbility 本示例演示了同一Page Ability内和不同Page间的AbilitySlice导航，以及Page Ability的跨端迁移。 针对跨设备迁移开发，有以下Codelabs可供参考： 分布式邮件编辑 基于跨设备迁移和分布式文件能力，实现邮件的跨设备编辑和附件的调用。 "},"service-concept.html":{"url":"service-concept.html","title":"Service Ability基本概念","keywords":"","body":"Service Ability基本概念 基于Service模板的Ability（以下简称“Service”）主要用于后台运行任务（如执行音乐播放、文件下载等），但不提供用户交互界面。Service可由其他应用或Ability启动，即使用户切换到其他应用，Service仍将在后台继续运行。 Service是单实例的。在一个设备上，相同的Service只会存在一个实例。如果多个Ability共用这个实例，只有当与Service绑定的所有Ability都退出后，Service才能够退出。由于Service是在主线程里执行的，因此，如果在Service里面的操作时间过长，开发者必须在Service里创建新的线程来处理（详见线程间通信），防止造成主线程阻塞，应用程序无响应。 "},"service-creating.html":{"url":"service-creating.html","title":"创建Service","keywords":"","body":"创建Service 介绍如何创建一个Service。 创建Ability的子类，实现Service相关的生命周期方法。Service也是一种Ability，Ability为Service提供了以下生命周期方法，用户可以重写这些方法，来添加其他Ability请求与Service Ability交互时的处理方法。 onStart() 该方法在创建Service的时候调用，用于Service的初始化。在Service的整个生命周期只会调用一次，调用时传入的Intent应为空。 onCommand() 在Service创建完成之后调用，该方法在客户端每次启动该Service时都会调用，用户可以在该方法中做一些调用统计、初始化类的操作。 onConnect() 在Ability和Service连接时调用，该方法返回IRemoteObject对象，用户可以在该回调函数中生成对应Service的IPC通信通道，以便Ability与Service交互。Ability可以多次连接同一个Service，系统会缓存该Service的IPC通信对象，只有第一个客户端连接Service时，系统才会调用Service的onConnect方法来生成IRemoteObject对象，而后系统会将同一个RemoteObject对象传递至其他连接同一个Service的所有客户端，而无需再次调用onConnect方法。 onDisconnect() 在Ability与绑定的Service断开连接时调用。 onStop() 在Service销毁时调用。Service应通过实现此方法来清理任何资源，如关闭线程、注册的侦听器等。 创建Service的代码示例如下： public class ServiceAbility extends Ability { @Override public void onStart(Intent intent) { super.onStart(intent); } @Override public void onCommand(Intent intent, boolean restart, int startId) { super.onCommand(intent, restart, startId); } @Override public IRemoteObject onConnect(Intent intent) { return super.onConnect(intent); } @Override public void onDisconnect(Intent intent) { super.onDisconnect(intent); } @Override public void onStop() { super.onStop(); }} 注册Service。 Service也需要在应用配置文件中进行注册，注册类型type需要设置为service。 { \"module\": { \"abilities\": [ { \"name\": \".ServiceAbility\", \"type\": \"service\", \"visible\": true ... } ] ... } ...} "},"service-starting.html":{"url":"service-starting.html","title":"启动Service","keywords":"","body":"启动Service 介绍通过startAbility()启动Service以及对应的停止方法。 启动Service Ability为开发者提供了startAbility()方法来启动另外一个Ability。因为Service也是Ability的一种，开发者同样可以通过将Intent传递给该方法来启动Service。不仅支持启动本地Service，还支持启动远程Service。 开发者可以通过构造包含DeviceId、BundleName与AbilityName的Operation对象来设置目标Service信息。这三个参数的含义如下： DeviceId：表示设备ID。如果是本地设备，则可以直接留空；如果是远程设备，可以通过ohos.distributedschedule.interwork.DeviceManager提供的getDeviceList获取设备列表，详见《API参考》。 BundleName：表示包名称。 AbilityName：表示待启动的Ability名称。 启动本地设备Service的代码示例如下： Intent intent = new Intent();Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.domainname.hiworld.himusic\") .withAbilityName(\"com.domainname.hiworld.himusic.ServiceAbility\") .build();intent.setOperation(operation);startAbility(intent); 启动远程设备Service的代码示例如下： Intent intent = new Intent();Operation operation = new Intent.OperationBuilder() .withDeviceId(\"deviceId\") .withBundleName(\"com.domainname.hiworld.himusic\") .withAbilityName(\"com.domainname.hiworld.himusic.ServiceAbility\") .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) // 设置支持分布式调度系统多设备启动的标识 .build();intent.setOperation(operation);startAbility(intent); 执行上述代码后，Ability将通过startAbility() 方法来启动Service。 如果Service尚未运行，则系统会先调用onStart()来初始化Service，再回调Service的onCommand()方法来启动Service。 如果Service正在运行，则系统会直接回调Service的onCommand()方法来启动Service。 停止Service Service一旦创建就会一直保持在后台运行，除非必须回收内存资源，否则系统不会停止或销毁Service。开发者可以在Service中通过terminateAbility()停止本Service或在其他Ability调用stopAbility()来停止Service。 停止Service同样支持停止本地设备Service和停止远程设备Service，使用方法与启动Service一样。一旦调用停止Service的方法，系统便会尽快销毁Service。 "},"service-connecting.html":{"url":"service-connecting.html","title":"连接Service","keywords":"","body":"连接Service 如果Service需要与Page Ability或其他应用的Service Ability进行交互，则须创建用于连接的Connection。Service支持其他Ability通过connectAbility()方法与其进行连接。 在使用connectAbility()处理回调时，需要传入目标Service的Intent与IAbilityConnection的实例。IAbilityConnection提供了两个方法供开发者实现：onAbilityConnectDone()是用来处理连接Service成功的回调，onAbilityDisconnectDone()是用来处理Service异常死亡的回调。 创建连接Service回调实例的代码示例如下： // 创建连接Service回调实例private IAbilityConnection connection = new IAbilityConnection() { // 连接到Service的回调 @Override public void onAbilityConnectDone(ElementName elementName, IRemoteObject iRemoteObject, int resultCode) { // Client侧需要定义与Service侧相同的IRemoteObject实现类。开发者获取服务端传过来IRemoteObject对象，并从中解析出服务端传过来的信息。 } // Service异常死亡的回调 @Override public void onAbilityDisconnectDone(ElementName elementName, int resultCode) { }}; 连接Service的代码示例如下： // 连接ServiceIntent intent = new Intent();Operation operation = new Intent.OperationBuilder() .withDeviceId(\"deviceId\") .withBundleName(\"com.domainname.hiworld.himusic\") .withAbilityName(\"com.domainname.hiworld.himusic.ServiceAbility\") .build();intent.setOperation(operation);connectAbility(intent, connection); 同时，Service侧也需要在onConnect()时返回IRemoteObject，从而定义与Service进行通信的接口。onConnect()需要返回一个IRemoteObject对象，HarmonyOS提供了IRemoteObject的默认实现，用户可以通过继承LocalRemoteObject来创建自定义的实现类。Service侧把自身的实例返回给调用侧的代码示例如下： // 创建自定义IRemoteObject实现类private class MyRemoteObject extends LocalRemoteObject { MyRemoteObject(){ }} // 把IRemoteObject返回给客户端@Overrideprotected IRemoteObject onConnect(Intent intent) { return new MyRemoteObject();} 相关实例 针对Service Ability开发，有以下示例工程可供参考： ServiceAbility 本示例演示了Service Ability的启动、停止、连接、断开连接等操作，支持对跨设备的Service Ability进行操作。 "},"service-lifecycle.html":{"url":"service-lifecycle.html","title":"Service Ability生命周期","keywords":"","body":"Service Ability生命周期 与Page类似，Service也拥有生命周期，如图1所示。根据调用方法的不同，其生命周期有以下两种路径： 启动 Service 该Service在其他Ability调用startAbility()时创建，然后保持运行。其他Ability通过调用stopAbility()来停止Service，Service停止后，系统会将其销毁。 连接 Service 该Service在其他Ability调用connectAbility()时创建，客户端可通过调用disconnectAbility()断开连接。多个客户端可以绑定到相同Service，而且当所有绑定全部取消后，系统即会销毁该Service。 图1 Service生命周期 "},"service-foreground.html":{"url":"service-foreground.html","title":"前台Service","keywords":"","body":"前台Service 一般情况下，Service都是在后台运行的，后台Service的优先级都是比较低的，当资源不足时，系统有可能回收正在运行的后台Service。 在一些场景下（如播放音乐），用户希望应用能够一直保持运行，此时就需要使用前台Service。前台Service会始终保持正在运行的图标在系统状态栏显示。 使用前台Service并不复杂，开发者只需在Service创建的方法里，调用keepBackgroundRunning()将Service与通知绑定。调用keepBackgroundRunning()方法前需要在配置文件中声明ohos.permission.KEEP_BACKGROUND_RUNNING权限，同时还需要在配置文件中添加对应的backgroundModes参数。在onStop()方法中调用cancelBackgroundRunning()方法可停止前台Service。 使用前台Service的onStart()代码示例如下： // 创建通知，其中1005为notificationIdNotificationRequest request = new NotificationRequest(1005);NotificationRequest.NotificationNormalContent content = new NotificationRequest.NotificationNormalContent();content.setTitle(\"title\").setText(\"text\");NotificationRequest.NotificationContent notificationContent = new NotificationRequest.NotificationContent(content);request.setContent(notificationContent); // 绑定通知，1005为创建通知时传入的notificationIdkeepBackgroundRunning(1005, request); 在配置文件中，“module > abilities”字段下对当前Service做如下配置： { \"name\": \".ServiceAbility\", \"type\": \"service\", \"visible\": true, \"backgroundModes\": [\"dataTransfer\", \"location\"]} "},"data-concept.html":{"url":"data-concept.html","title":"Data Ability基本概念","keywords":"","body":"Data Ability基本概念 使用Data模板的Ability（以下简称“Data”）有助于应用管理其自身和其他应用存储数据的访问，并提供与其他应用共享数据的方法。Data既可用于同设备不同应用的数据共享，也支持跨设备不同应用的数据共享。 数据的存放形式多样，可以是数据库，也可以是磁盘上的文件。Data对外提供对数据的增、删、改、查，以及打开文件等接口，这些接口的具体实现由开发者提供。 URI介绍 Data的提供方和使用方都通过URI（Uniform Resource Identifier）来标识一个具体的数据，例如数据库中的某个表或磁盘上的某个文件。HarmonyOS的URI仍基于URI通用标准，格式如下： scheme：协议方案名，固定为“dataability”，代表Data Ability所使用的协议类型。 authority：设备ID。如果为跨设备场景，则为目标设备的ID；如果为本地设备场景，则不需要填写。 path：资源的路径信息，代表特定资源的位置信息。 query：查询参数。 fragment：可以用于指示要访问的子资源。 URI示例： 跨设备场景：dataability://device_id/com.domainname.dataability.persondata/person/10 本地设备：dataability:///com.domainname.dataability.persondata/person/10 "},"data-creating.html":{"url":"data-creating.html","title":"创建Data","keywords":"","body":"创建Data 使用Data模板的Ability形式仍然是Ability，因此，开发者需要为应用添加一个或多个Ability的子类，来提供程序与其他应用之间的接口。Data为结构化数据和文件提供了不同API接口供用户使用，因此，开发者需要首先确定好使用何种类型的数据。本章节主要讲述了创建Data的基本步骤和需要使用的接口。 Data提供方可以自定义数据的增、删、改、查，以及文件打开等功能，并对外提供这些接口。 确定数据存储方式 确定数据的存储方式，Data支持以下两种数据形式： 文件数据：如文本、图片、音乐等。 结构化数据：如数据库等。 实现UserDataAbility UserDataAbility用于接收其他应用发送的请求，提供外部程序访问的入口，从而实现应用间的数据访问。 实现UserDataAbility，需要在“Project”窗口当前工程的主目录（“entry > src > main > java > com.xxx.xxx”）选择“File > New > Ability > Empty Data Ability”，设置“Data Name”后完成UserDataAbility的创建。 Data提供了文件存储和数据库存储两组接口供用户使用。 文件存储 开发者需要在Data中重写FileDescriptor openFile(Uri uri, String mode)方法来操作文件：uri为客户端传入的请求目标路径；mode为开发者对文件的操作选项，可选方式包含“r”(读), “w”(写), “rw”(读写)等。 ohos.rpc.MessageParcel类提供了一个静态方法，用于获取MessageParcel实例。开发者可通过获取到的MessageParcel实例，使用dupFileDescriptor()函数复制待操作文件流的文件描述符，并将其返回，供远端应用访问文件。 示例：根据传入的uri打开对应的文件 private static final HiLogLabel LABEL_LOG = new HiLogLabel(HiLog.LOG_APP, 0xD00201, \"Data_Log\"); @Overridepublic FileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException { // 创建messageParcel MessageParcel messageParcel = MessageParcel.obtain(); File file = new File(uri.getDecodedPathList().get(0)); //get(0)是获取URI完整字段中查询参数字段。 if (mode == null || !\"rw\".equals(mode)) { file.setReadOnly(); } FileInputStream fileIs = new FileInputStream(file); FileDescriptor fd = null; try { fd = fileIs.getFD(); } catch (IOException e) { HiLog.info(LABEL_LOG, \"failed to getFD\"); } // 绑定文件描述符 return messageParcel.dupFileDescriptor(fd);} 数据库存储 初始化数据库连接。 系统会在应用启动时调用onStart()方法创建Data实例。在此方法中，开发者应该创建数据库连接，并获取连接对象，以便后续和数据库进行操作。为了避免影响应用启动速度，开发者应当尽可能将非必要的耗时任务推迟到使用时执行，而不是在此方法中执行所有初始化。 示例：初始化的时候连接数据库 private static final String DATABASE_NAME = \"UserDataAbility.db\";private static final String DATABASE_NAME_ALIAS = \"UserDataAbility\";private static final HiLogLabel LABEL_LOG = new HiLogLabel(HiLog.LOG_APP, 0xD00201, \"Data_Log\");private OrmContext ormContext = null; @Overridepublic void onStart(Intent intent) { super.onStart(intent); DatabaseHelper manager = new DatabaseHelper(this); ormContext = manager.getOrmContext(DATABASE_NAME_ALIAS, DATABASE_NAME, BookStore.class);} 编写数据库操作方法。 Ability定义了6个方法供用户处理对数据库表数据的增删改查。这6个方法在Ability中已默认实现，开发者可按需重写。 | 方法 | 描述 | | ------------------------------------------------------------ | ---------------------- | | ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates) | 查询数据库 | | int insert(Uri uri, ValuesBucket value) | 向数据库中插入单条数据 | | int batchInsert(Uri uri, ValuesBucket[] values) | 向数据库中插入多条数据 | | int delete(Uri uri, DataAbilityPredicates predicates) | 删除一条或多条数据 | | int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates) | 更新数据库 | | DataAbilityResult[] executeBatch(ArrayList operations) | 批量操作数据库 | 这些方法的使用说明如下： query() 该方法接收三个参数，分别是查询的目标路径，查询的列名，以及查询条件，查询条件由类DataAbilityPredicates构建。根据传入的列名和查询条件查询用户表的代码示例如下： public ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates) { if (ormContext == null) { HiLog.error(LABEL_LOG, \"failed to query, ormContext is null\"); return null; } // 查询数据库 OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class); ResultSet resultSet = ormContext.query(ormPredicates, columns); if (resultSet == null) { HiLog.info(LABEL_LOG, \"resultSet is null\"); } // 返回结果 return resultSet;} insert() 该方法接收两个参数，分别是插入的目标路径和插入的数据值。其中，插入的数据由ValuesBucket封装，服务端可以从该参数中解析出对应的属性，然后插入到数据库中。此方法返回一个int类型的值用于标识结果。接收到传过来的用户信息并把它保存到数据库中的代码示例如下： public int insert(Uri uri, ValuesBucket value) { // 参数校验 if (ormContext == null) { HiLog.error(LABEL_LOG, \"failed to insert, ormContext is null\"); return -1; } // 构造插入数据 User user = new User(); user.setUserId(value.getInteger(\"userId\")); user.setFirstName(value.getString(\"firstName\")); user.setLastName(value.getString(\"lastName\")); user.setAge(value.getInteger(\"age\")); user.setBalance(value.getDouble(\"balance\")); // 插入数据库 boolean isSuccessful = ormContext.insert(user); if (!isSuccessful) { HiLog.error(LABEL_LOG, \"failed to insert\"); return -1; } isSuccessful = ormContext.flush(); if (!isSuccessful) { HiLog.error(LABEL_LOG, \"failed to insert flush\"); return -1; } DataAbilityHelper.creator(this, uri).notifyChange(uri); int id = Math.toIntExact(user.getRowId()); return id;} batchInsert() 该方法为批量插入方法，接收一个ValuesBucket数组用于单次插入一组对象。它的作用是提高插入多条重复数据的效率。该方法系统已实现，开发者可以直接调用。 delete() 该方法用来执行删除操作。删除条件由类DataAbilityPredicates构建，服务端在接收到该参数之后可以从中解析出要删除的数据，然后到数据库中执行。根据传入的条件删除用户表数据的代码示例如下： public int delete(Uri uri, DataAbilityPredicates predicates) { if (ormContext == null) { HiLog.error(LABEL_LOG, \"failed to delete, ormContext is null\"); return -1; } OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class); int value = ormContext.delete(ormPredicates); DataAbilityHelper.creator(this, uri).notifyChange(uri); return value;} update() 此方法用来执行更新操作。用户可以在ValuesBucket参数中指定要更新的数据，在DataAbilityPredicates中构建更新的条件等。更新用户表的数据的代码示例如下： public int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates) { if (ormContext == null) { HiLog.error(LABEL_LOG, \"failed to update, ormContext is null\"); return -1; } OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class); int index = ormContext.update(ormPredicates, value); HiLog.info(LABEL_LOG, \"UserDataAbility update value:\" + index); DataAbilityHelper.creator(this, uri).notifyChange(uri); return index;} executeBatch() 此方法用来批量执行操作。DataAbilityOperation中提供了设置操作类型、数据和操作条件的方法，用户可自行设置自己要执行的数据库操作。该方法系统已实现，开发者可以直接调用。 说明 上述代码示例中，初始化了数据库类BookStore.class，并通过实体类User.class对该数据库的表User进行增删改查操作。 关于对象关系映射数据库的具体逻辑，以及示例中BookStore.class与User.class的逻辑关系，可参考“对象关系映射数据库开发指导”。 注册UserDataAbility 和Service类似，开发者必须在配置文件中注册Data。 配置文件中该字段在创建Data Ability时会自动创建，name与创建的Data Ability一致。 需要关注以下属性： type: 类型设置为data uri: 对外提供的访问路径，全局唯一 permissions: 访问该data ability时需要申请的访问权限 说明 如果权限非系统权限，需要在配置文件中进行自定义。请参考权限开发指导中关于“自定义权限”的相关说明。 { \"name\": \".UserDataAbility\", \"type\": \"data\", \"visible\": true, \"uri\": \"dataability://com.example.myapplication5.DataAbilityTest\", \"permissions\": [ \"com.example.myapplication5.DataAbility.DATA\" ]} "},"data-accessing.html":{"url":"data-accessing.html","title":"访问Data","keywords":"","body":"访问Data 开发者可以通过DataAbilityHelper类来访问当前应用或其他应用提供的共享数据。DataAbilityHelper作为客户端，与提供方的Data进行通信。Data接收到请求后，执行相应的处理，并返回结果。DataAbilityHelper提供了一系列与Data Ability对应的方法。 下面介绍DataAbilityHelper具体的使用步骤。 声明使用权限 如果待访问的Data声明了访问需要权限，则访问此Data需要在配置文件中声明需要此权限。声明请参考权限申请字段说明。 \"reqPermissions\": [ { \"name\": \"com.example.myapplication5.DataAbility.DATA\" }, // 访问文件还需要添加访问存储读写权限 { \"name\": \"ohos.permission.READ_USER_STORAGE\" }, { \"name\": \"ohos.permission.WRITE_USER_STORAGE\" }] 创建DataAbilityHelper DataAbilityHelper为开发者提供了creator()方法来创建DataAbilityHelper实例。该方法为静态方法，有多个重载。最常见的方法是通过传入一个context对象来创建DataAbilityHelper对象。 获取helper对象示例： DataAbilityHelper helper = DataAbilityHelper.creator(this); 访问Data Ability DataAbilityHelper为开发者提供了一系列的接口来访问不同类型的数据（文件、数据库等）。 访问文件 DataAbilityHelper为开发者提供了FileDescriptor openFile(Uri uri, String mode)方法来操作文件。此方法需要传入两个参数，其中uri用来确定目标资源路径，mode用来指定打开文件的方式，可选方式包含“r”(读), “w”(写), “rw”(读写)，“wt”(覆盖写)，“wa”(追加写)，“rwt”(覆盖写且可读)。 该方法返回一个目标文件的FD（文件描述符），把文件描述符封装成流，开发者就可以对文件流进行自定义处理。 访问文件示例： // 读取文件描述符FileDescriptor fd = helper.openFile(uri, \"r\");FileInputStream fis = new FileInputStream(fd); // 使用文件描述符封装成的文件流，进行文件操作 访问数据库 DataAbilityHelper为开发者提供了增、删、改、查以及批量处理等方法来操作数据库。 说明 对数据库的操作方法，详见数据管理中各数据库类型的开发指南。 | 方法 | 描述 | | ------------------------------------------------------------ | ---------------------- | | ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates) | 查询数据库 | | int insert(Uri uri, ValuesBucket value) | 向数据库中插入单条数据 | | int batchInsert(Uri uri, ValuesBucket[] values) | 向数据库中插入多条数据 | | int delete(Uri uri, DataAbilityPredicates predicates) | 删除一条或多条数据 | | int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates) | 更新数据库 | | DataAbilityResult[] executeBatch(ArrayList operations) | 批量操作数据库 | 这些方法的使用说明如下： query() 查询方法，其中uri为目标资源路径，columns为想要查询的字段。开发者的查询条件可以通过DataAbilityPredicates来构建。查询用户表中id在101-103之间的用户，并把结果打印出来，代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(this); // 构造查询条件DataAbilityPredicates predicates = new DataAbilityPredicates();predicates.between(\"userId\", 101, 103); // 进行查询ResultSet resultSet = helper.query(uri, columns, predicates); // 处理结果resultSet.goToFirstRow();do { // 在此处理ResultSet中的记录;} while(resultSet.goToNextRow()); insert() 新增方法，其中uri为目标资源路径，ValuesBucket为要新增的对象。插入一条用户信息的代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(this); // 构造插入数据ValuesBucket valuesBucket = new ValuesBucket();valuesBucket.putString(\"name\", \"Tom\");valuesBucket.putInteger(\"age\", 12);helper.insert(uri, valuesBucket); batchInsert(） 批量插入方法，和insert()类似。批量插入用户信息的代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(this); // 构造插入数据ValuesBucket[] values = new ValuesBucket[2];values[0] = new ValuesBucket();values[0].putString(\"name\", \"Tom\");values[0].putInteger(\"age\", 12);values[1] = new ValuesBucket();values[1].putString(\"name\", \"Tom1\");values[1].putInteger(\"age\", 16);helper.batchInsert(uri, values); delete() 删除方法，其中删除条件可以通过DataAbilityPredicates来构建。删除用户表中id在101-103之间的用户，代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(this); // 构造删除条件DataAbilityPredicates predicates = new DataAbilityPredicates();predicates.between(\"userId\", 101, 103);helper.delete(uri, predicates); update() 更新方法，更新数据由ValuesBucket传入，更新条件由DataAbilityPredicates来构建。更新id为102的用户，代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(this); // 构造更新条件DataAbilityPredicates predicates = new DataAbilityPredicates();predicates.equalTo(\"userId\", 102); // 构造更新数据ValuesBucket valuesBucket = new ValuesBucket();valuesBucket.putString(\"name\", \"Tom\");valuesBucket.putInteger(\"age\", 12);helper.update(uri, valuesBucket, predicates); executeBatch() 此方法用来执行批量操作。DataAbilityOperation中提供了设置操作类型、数据和操作条件的方法，开发者可自行设置自己要执行的数据库操作。插入多条数据的代码示例如下： DataAbilityHelper helper = DataAbilityHelper.creator(abilityObj, insertUri); // 构造批量操作ValuesBucket value1 = initSingleValue();DataAbilityOperation opt1 = DataAbilityOperation.newInsertBuilder(insertUri).withValuesBucket(value1).build();ValuesBucket value2 = initSingleValue2();DataAbilityOperation opt2 = DataAbilityOperation.newInsertBuilder(insertUri).withValuesBucket(value2).build();ArrayList operations = new ArrayList();operations.add(opt1);operations.add(opt2);DataAbilityResult[] result = helper.executeBatch(insertUri, operations); 相关实例 针对Data Ability开发，有以下示例工程可供参考： DataAbility 本示例演示了如何使用Data Ability对数据库进行增、删、改、查，以及读取文本文件。 针对Data Ability开发，有以下Codelabs可供参考： 关系型数据库 基于Data Ability的关系型数据库和数据管理能力，实现数据库相关应用服务的快速开发。 "},"intent.html":{"url":"intent.html","title":"Intent","keywords":"","body":"Intent 基本概念 Intent是对象之间传递信息的载体。例如，当一个Ability需要启动另一个Ability时，或者一个AbilitySlice需要导航到另一个AbilitySlice时，可以通过Intent指定启动的目标同时携带相关数据。Intent的构成元素包括Operation与Parameters，具体描述参见表1。 属性 子属性 描述 Operation Action 表示动作，通常使用系统预置Action，应用也可以自定义Action。例如IntentConstants.ACTION_HOME表示返回桌面动作。 Entity 表示类别，通常使用系统预置Entity，应用也可以自定义Entity。例如Intent.ENTITY_HOME表示在桌面显示图标。 Uri 表示Uri描述。如果在Intent中指定了Uri，则Intent将匹配指定的Uri信息，包括scheme, schemeSpecificPart, authority和path信息。 Flags 表示处理Intent的方式。例如Intent.FLAG_ABILITY_CONTINUATION标记在本地的一个Ability是否可以迁移到远端设备继续运行。 BundleName 表示包描述。如果在Intent中同时指定了BundleName和AbilityName，则Intent可以直接匹配到指定的Ability。 AbilityName 表示待启动的Ability名称。如果在Intent中同时指定了BundleName和AbilityName，则Intent可以直接匹配到指定的Ability。 DeviceId 表示运行指定Ability的设备ID。 Parameters - Parameters是一种支持自定义的数据结构，开发者可以通过Parameters传递某些请求所需的额外信息。 当Intent用于发起请求时，根据指定元素的不同，分为两种类型： 如果同时指定了BundleName与AbilityName，则根据Ability的全称（例如“com.demoapp.FooAbility”）来直接启动应用。 如果未同时指定BundleName和AbilityName，则根据Operation中的其他属性来启动应用。 说明 Intent设置属性时，必须先使用Operation来设置属性。如果需要新增或修改属性，必须在设置Operation后再执行操作。 关于Intent最简单的使用方法，可参见快速入门的示例代码。其中“实现页面跳转”重点描述了使用Intent实现两个页面跳转关系的操作。 根据Ability的全称启动应用 通过构造包含BundleName与AbilityName的Operation对象，可以启动一个Ability、并导航到该Ability。示例代码如下： Intent intent = new Intent(); // 通过Intent中的OperationBuilder类构造operation对象，指定设备标识（空串表示当前设备）、应用包名、Ability名称Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.demoapp\") .withAbilityName(\"com.demoapp.FooAbility\") .build(); // 把operation设置到intent中intent.setOperation(operation);startAbility(intent); 作为处理请求的对象，会在相应的回调方法中接收请求方传递的Intent对象。以导航到另一个Ability为例，导航的目标Ability可以在其onStart()回调的参数中获得Intent对象。 根据Operation的其他属性启动应用 有些场景下，开发者需要在应用中使用其他应用提供的某种能力，而不感知提供该能力的具体是哪一个应用。例如开发者需要通过浏览器打开一个链接，而不关心用户最终选择哪一个浏览器应用，则可以通过Operation的其他属性（除BundleName与AbilityName之外的属性）描述需要的能力。如果设备上存在多个应用提供同种能力，系统则弹出候选列表，由用户选择由哪个应用处理请求。以下示例展示使用Intent跨Ability查询天气信息。 请求方 在Ability中构造Intent以及包含Action的Operation对象，并调用startAbilityForResult()方法发起请求。然后重写onAbilityResult()回调方法，对请求结果进行处理。 private void queryWeather() { Intent intent = new Intent(); Operation operation = new Intent.OperationBuilder() .withAction(Intent.ACTION_QUERY_WEATHER) .build(); intent.setOperation(operation); startAbilityForResult(intent, REQ_CODE_QUERY_WEATHER);} @Overrideprotected void onAbilityResult(int requestCode, int resultCode, Intent resultData) { switch (requestCode) { case REQ_CODE_QUERY_WEATHER: // Do something with result. ... return; default: ... }} 处理方 作为处理请求的对象，首先需要在配置文件中声明对外提供的能力，以便系统据此找到自身并作为候选的请求处理者。 { \"module\": { ... \"abilities\": [ { ... \"skills\":[ { \"actions\":[ \"ability.intent.QUERY_WEATHER\" ] } ] ... } ] ... } ...} 在Ability中配置路由以便支持以此action导航到对应的AbilitySlice。 @Overrideprotected void onStart(Intent intent) { ... addActionRoute(Intent.ACTION_QUERY_WEATHER, DemoSlice.class.getName()); ...} 在Ability中处理请求，并调用setResult()方法暂存返回结果。 @Overrideprotected void onActive() { ... Intent resultIntent = new Intent(); setResult(0, resultIntent); //0为当前Ability销毁后返回的resultCode。 ...} 相关实例 针对Intent开发，有以下示例工程可供参考： Intent 本示例演示了如何根据Ability的全称启动应用和根据Operation的其他属性启动应用。 AbilityIntent 本示例通过Ability的全称和Operation的其他属性两种方式实现界面跳转以及数据传递。 "},"distributed-overview.html":{"url":"distributed-overview.html","title":"分布式任务调度开发概述","keywords":"","body":"分布式任务调度开发概述 在HarmonyOS中，分布式任务调度平台对搭载HarmonyOS的多设备构筑的“超级虚拟终端”提供统一的组件管理能力，为应用定义统一的能力基线、接口形式、数据结构、服务描述语言，屏蔽硬件差异；支持远程启动、远程调用、业务无缝迁移等分布式任务。 分布式任务调度平台在底层实现Ability（分布式任务调度的基本组件）跨设备的启动/关闭、连接及断开连接以及迁移等能力，实现跨设备的组件管理： 启动和关闭：向开发者提供管理远程Ability的能力，即支持启动Page模板的Ability，以及启动、关闭Service和Data模板的Ability。 连接和断开连接：向开发者提供跨设备控制服务（Service和Data模板的Ability）的能力，开发者可以通过与远程服务连接及断开连接实现获取或注销跨设备管理服务的对象，达到和本地一致的服务调度。 迁移能力：向开发者提供跨设备业务的无缝迁移能力，开发者可以通过调用Page模板Ability的迁移接口，将本地业务无缝迁移到指定设备中，打通设备间壁垒。 约束与限制 开发者需要在Intent中设置支持分布式的标记（例如：Intent.FLAG_ABILITYSLICE_MULTI_DEVICE表示该应用支持分布式调度），否则将无法获得分布式能力。 开发者通过在config.json中的reqPermissions字段里添加多设备协同访问的权限申请：三方应用使用{\"name\": \"ohos.permission.DISTRIBUTED_DATASYNC\"}。 PA（Particle Ability，Service和Data模板的Ability）的调用支持连接及断开连接、启动及关闭这四类行为，在进行调度时： 开发者必须在Intent中指定PA对应的bundleName和abilityName。 当开发者需要跨设备启动、关闭或连接PA时，需要在Intent中指定对端设备的deviceId。开发者可通过如设备管理类DeviceManager提供的getDeviceList获取指定条件下匿名化处理的设备列表，实现对指定设备PA的启动/关闭以及连接管理。 FA（Feature Ability，Page模板的Ability）的调用支持启动和迁移行为，在进行调度时： 当启动FA时，需要开发者在Intent中指定对端设备的deviceId、bundleName和abilityName。 FA的迁移实现相同bundleName和abilityName的FA跨设备迁移，因此需要指定迁移设备的deviceId。 DevEco Studio远程模拟设备的功能无法调测分布式任务调度，需要在真机环境下进行测试。 "},"distributed-guidelines.html":{"url":"distributed-guidelines.html","title":"分布式任务调度开发指导","keywords":"","body":"分布式任务调度开发指导 场景介绍 开发者在应用中集成分布式调度能力，通过调用指定能力的分布式接口，实现跨设备能力调度。根据Ability模板及意图的不同，分布式任务调度向开发者提供以下六种能力：启动远程FA、启动远程PA、关闭远程PA、连接远程PA、断开连接远程PA和FA跨设备迁移。下面以设备A（本地设备）和设备B（远端设备）为例，进行场景介绍： 设备A启动设备B的FA：在设备A上通过本地应用提供的启动按钮，启动设备B上对应的FA。例如：设备A控制设备B打开相册，只需开发者在启动FA时指定打开相册的意图即可。 设备A启动设备B的PA：在设备A上通过本地应用提供的启动按钮，启动设备B上指定的PA。例如：开发者在启动远程服务时通过意图指定音乐播放服务，即可实现设备A启动设备B音乐播放的能力。 设备A关闭设备B的PA：在设备A上通过本地应用提供的关闭按钮，关闭设备B上指定的PA。类似启动的过程，开发者在关闭远程服务时通过意图指定音乐播放服务，即可实现关闭设备B上该服务的能力。 设备A连接设备B的PA：在设备A上通过本地应用提供的连接按钮，连接设备B上指定的PA。连接后，通过其他功能相关按钮实现控制对端PA的能力。通过连接关系，开发者可以实现跨设备的同步服务调度，实现如大型计算任务互助等价值场景。 设备A与设备B的PA断开连接：在设备A上通过本地应用提供断开连接的按钮，将之前已连接的PA断开连接。 设备A的FA迁移至设备B：设备A上通过本地应用提供的迁移按钮，将设备A的业务无缝迁移到设备B中。通过业务迁移能力，打通设备A和设备B间的壁垒，实现如文档跨设备编辑、视频从客厅到房间跨设备接续播放等场景。 接口说明 分布式调度平台提供的连接和断开连接PA、启动远程FA、启动和关闭PA以及迁移FA的能力，是实现更多价值性场景的基础。 连接远程PA connectAbility(Intent intent, IAbilityConnection conn)接口提供连接指定设备上PA的能力，Intent中指定待连接PA的设备deviceId、bundleName和abilityName。当连接成功后，通过在conn定义的onAbilityConnectDone回调中获取对端PA的服务代理，两者的连接关系则由conn维护。具体的参数定义如下表所示： 参数名 类型 说明 intent ohos.aafwk.content.Intent 开发者需在intent对应的Operation中指定待连接PA的设备deviceId、bundleName和abilityName。 conn ohos.aafwk.ability.IAbilityConnection 当连接成功或失败时，作为连接关系的回调接口。该接口提供连接完成和断开连接完成时的处理逻辑，开发者可根据具体的场景进行定义。 启动远程FA/PA startAbility(Intent intent)接口提供启动指定设备上FA和PA的能力，Intent中指定待启动FA/PA的设备deviceId、bundleName和abilityName。具体参数定义如下表所示： 参数名 类型 说明 intent ohos.aafwk.content.Intent 当开发者需要调用该接口启动远程PA时，需要指定待启动PA的设备deviceId、bundleName和abilityName。若不指定设备deviceId，则无法跨设备调用PA。类似地，在启动FA时，也需要开发者指定启动FA的设备deviceId、bundleName和abilityName。 分布式调度平台还会提供与上述功能相对应的断开远程PA的连接和关闭远程PA的接口，相关的参数与连接、启动的接口类似。 断开远程PA连接：disconnectAbility(IAbilityConnection conn)。 关闭远程PA：stopAbility(Intent intent)。 迁移FA continueAbility(String deviceId)接口提供将本地FA迁移到指定设备上的能力，需要开发者在调用时指定目标设备的deviceId。具体参数定义如下表所示： 说明 Ability和AbilitySlice类均需要实现IAbilityContinuation及其方法，才可以实现FA迁移。 参数名 类型 说明 deviceId String 当开发者需要调用该接口将本地FA迁移时，需要指定目标设备的deviceId。 开发步骤 导入功能依赖的包。 // 以下依赖包含分布式调度平台开放的接口// 用于：连接/断开连接远程PA、启动远程FA、通过连接关系实现对PA的控制import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.ability.IAbilityConnection;import ohos.aafwk.content.Intent;import ohos.aafwk.content.Operation;import ohos.bundle.ElementName;// 为了实现迁移能力，需要引入传递迁移所需数据的包以及实现迁移能力的接口import ohos.aafwk.ability.IAbilityContinuation;import ohos.aafwk.content.IntentParams;// 为了实现跨设备指令及数据通信，需要使用RPC接口import ohos.rpc.IRemoteObject;import ohos.rpc.IRemoteBroker;import ohos.rpc.MessageParcel;import ohos.rpc.MessageOption;import ohos.rpc.RemoteException;import ohos.rpc.RemoteObject;//（可选）多设备场景下涉及设备选择，为此需要引入组网设备发现的能力import ohos.distributedschedule.interwork.DeviceInfo;import ohos.distributedschedule.interwork.DeviceManager;// (可选）设计界面相关的包函数，对FA界面及按钮进行绘制import ohos.agp.components.Button;import ohos.agp.components.Component;import ohos.agp.components.Component.ClickedListener;import ohos.agp.components.ComponentContainer.LayoutConfig;import ohos.agp.components.element.ShapeElement;import ohos.agp.components.PositionLayout; （可选）编写一个基本的FA用于使用分布式能力。 // 调用AbilitySlice模板实现一个用于控制基础功能的FA，AbilitySlice的代码示例如下：public class SampleSlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 开发者可以自行进行界面设计 // 为按钮设置统一的背景色 // 例如通过PositionLayout可以实现简单界面 PositionLayout layout = new PositionLayout(this); LayoutConfig config = new LayoutConfig(LayoutConfig.MATCH_PARENT, LayoutConfig.MATCH_PARENT); layout.setLayoutConfig(config); ShapeElement buttonBg = new ShapeElement(); buttonBg.setRgbColor(new RgbColor(0, 125, 255)); addComponents(layout, buttonBg, config); super.setUIContent(layout); } @Override public void onInactive() { super.onInactive(); } @Override public void onActive() { super.onActive(); } @Override public void onBackground() { super.onBackground(); } @Override public void onForeground(Intent intent) { super.onForeground(intent); } @Override public void onStop() { super.onStop(); }} 说明 此步骤展示了一个简单FA的实现过程，实际开发中请开发者根据需要进行设计。 使用分布式能力要求开发者在Ability对应的config.json中声明多设备协同访问的权限：三方应用使用{\"name\": \"ohos.permission.DISTRIBUTED_DATASYNC\"}。 一个三方应用部署的示例如下： { \"reqPermissions\": [ { \"name\": \"ohos.permission.DISTRIBUTED_DATASYNC\" } ]} 此外，对于三方应用还要求在实现Ability的代码中显式声明需要使用的权限，如下所示： public class SampleSlice extends AbilitySlice { @Override public void onStart(Intent intent) { // 开发者显示声明需要使用的权限 requestPermissionsFromUser(new String[]{\"ohos.permission.DISTRIBUTED_DATASYNC\"}, 0); super.onStart(intent); }} （可选）为不同的能力设置相应的控制按钮。 // 建议开发者按照自己的界面进行按钮设计 // 开发者可以自行实现如下createButton的方法，新建一个显示文字text，背景色为buttonBg以及大小尺寸位置符合config设置的按钮，用来与用户交互// private Button createButton(String text, ShapeElement buttonBg, LayoutConfig config)// 按照顺序在PositionLayout中依次添加按钮的示例private void addComponents(PositionLayout linear, ShapeElement buttonBg, LayoutConfig config) { // 构建远程启动FA的按钮 btnStartRemoteFA = createButton(\"StartRemoteFA\", buttonBg, config); btnStartRemoteFA.setClickedListener(mStartRemoteFAListener); linear.addComponent(btnStartRemoteFA); // 构建远程启动PA的按钮 btnStartRemotePA = createButton(\"StartRemotePA\", buttonBg, config); btnStartRemotePA.setClickedListener(mStartRemotePAListener); linear.addComponent(btnStartRemotePA); // 构建远程关闭PA的按钮 btnStopRemotePA = createButton(\"StopRemotePA\", buttonBg, config); btnStopRemotePA.setClickedListener(mStopRemotePAListener); linear.addComponent(btnStopRemotePA); // 构建连接远程PA的按钮 btnConnectRemotePA = createButton(\"ConnectRemotePA\", buttonBg, config); btnConnectRemotePA.setClickedListener(mConnectRemotePAListener); linear.addComponent(btnConnectRemotePA); // 构建控制连接PA的按钮 btnControlRemotePA = createButton(\"ControlRemotePA\", buttonBg, config); btnControlRemotePA.setClickedListener(mControlPAListener); linear.addComponent(btnControlRemotePA); // 构建与远程PA断开连接的按钮 btnDisconnectRemotePA = createButton(\"DisconnectRemotePA\", buttonBg, config); btnDisconnectRemotePA.setClickedListener(mDisconnectRemotePAListener); linear.addComponent(btnDisconnectRemotePA); // 构建迁移FA的按钮 btnContinueRemoteFA = createButton(\"ContinueRemoteFA\", buttonBg, config); btnContinueRemoteFA.setClickedListener(mContinueAbilityListener); linear.addComponent(btnContinueRemoteFA);} 说明 此处只展示了基于按钮控制的能力调度方法，实际开发中请开发者根据需要选择能力调度方式。代码示例中未体现按钮如位置、样式等具体的设置方法，详请参考JAVA UI框架。 通过设备管理DeviceManager提供的getDeviceList接口获取设备列表，用于指定目标设备。 // ISelectResult是一个自定义接口，用来处理指定设备deviceId后执行的行为 interface ISelectResult { void onSelectResult(String deviceId); } // 获得设备列表，开发者可在得到的在线设备列表中选择目标设备执行操作private void scheduleRemoteAbility(ISelectResult listener) { // 调用DeviceManager的getDeviceList接口，通过FLAG_GET_ONLINE_DEVICE标记获得在线设备列表 List onlineDevices = DeviceManager.getDeviceList(DeviceInfo.FLAG_GET_ONLINE_DEVICE); // 判断组网设备是否为空 if (onlineDevices.isEmpty()) { listener.onSelectResult(null); return; } int numDevices = onlineDevices.size(); List deviceIds = new ArrayList<>(numDevices); onlineDevices.forEach((device) -> { deviceIds.add(device.getDeviceId()); }); // 以选择首个设备作为目标设备为例 // 开发者也可按照具体场景，通过别的方式进行设备选择 String selectDeviceId = deviceIds.get(0); listener.onSelectResult(selectDeviceId); } 上述实例中涉及对在线组网设备的查询，该项能力需要开发者在对应的config.json中声明获取设备列表及设备信息的权限，如下所示： { \"reqPermissions\": [ { \"name\": \"ohos.permission.DISTRIBUTED_DEVICE_STATE_CHANGE\" }, { \"name\": \"ohos.permission.GET_DISTRIBUTED_DEVICE_INFO\" }, { \"name\": \"ohos.permission.GET_BUNDLE_INFO\" } ]} 为启动远程FA的按钮设置点击回调，实现启动远程FA的能力。 // 启动一个指定bundleName和abilityName的FAprivate ClickedListener mStartRemoteFAListener = new ClickedListener() { @Override public void onClick(Component arg0) { // 启动远程PA scheduleRemoteAbility(new ISelectResult() { @Override void onSelectResult(String deviceId) { if (deviceId != null) { // 通过scheduleRemoteAbility指定目标设备deviceId // 指定待启动FA的bundleName和abilityName // 例如：bundleName = \"com.helloworld\" // abilityName = \"com.helloworld.SampleFeatureAbility\" // 设置分布式标记，表明当前涉及分布式能力 Operation operation = new Intent.OperationBuilder() .withDeviceId(deviceId) .withBundleName(bundleName) .withAbilityName(abilityName) .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) .build(); Intent intent = new Intent(); intent.setOperation(operation); // 通过AbilitySlice包含的startAbility接口实现跨设备启动FA startAbility(intent); } } }); }}; 为启动和关闭PA定义回调，实现启动和关闭PA的能力。 对于PA的启动、关闭、连接等操作都需要开发者提供目标设备的deviceId。开发者可以通过DeviceManager相关接口得到当前组网下的设备列表，并以弹窗的形式供用户选择，也可以按照实际需要实现其他个性化的处理方式。在点击事件回调函数中，需要开发者指定得到deviceId后的处理逻辑，即实现类似上例中listener.onSelectResult(String deviceId)的方法，代码示例如下： // 启动远程PAprivate ClickedListener mStartRemotePAListener = new ClickedListener() { @Override public void onClick(Component arg0) { // 启动远程PA scheduleRemoteAbility(new ISelectResult() { @Override void onSelectResult(String deviceId) { if (deviceId != null) { // bundleName和abilityName与待启动PA对应 // 例如：bundleName = \"com.helloworld\" // abilityName = \"com.helloworld.SampleParticleAbility\" Operation operation = new Intent.OperationBuilder() .withDeviceId(deviceId) .withBundleName(bundleName) .withAbilityName(abilityName) .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) .build(); Intent intentToStartPA = new Intent(); intentToStartPA.setOperation(operation); startAbility(intentToStartPA); } } }); }}; // 关闭远程PA，和启动类似开发者需要指定待关闭PA对应的bundleName和abilityNameprivate ClickedListener mStopRemotePAListener = new ClickedListener() { @Override public void onClick(Component arg0) { scheduleRemoteAbility(new ISelectResult() { @Override void onSelectResult(String deviceId) { if (deviceId != null) { // bundleName和abilityName与待关闭PA对应 // 例如：bundleName = \"com.helloworld\" // abilityName = \"com.helloworld.SampleParticleAbility\" Operation operation = new Intent.OperationBuilder() .withDeviceId(deviceId) .withBundleName(bundleName) .withAbilityName(abilityName) .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) .build(); Intent intentToStopPA = new Intent(); intentToStopPA.setOperation(operation); stopAbility(intentToStopPA); } } }); }}; 说明 启动和关闭的行为类似，开发者只需在Intent中指定待调度PA的deviceId、bundleName和abilityName，并以operation的形式封装到Intent内。通过AbilitySlice（Ability）包含的startAbility()和stopAbility()接口即可实现相应功能。 设备A连接设备B侧的PA，利用连接关系调用该PA执行特定任务，以及断开连接。 // 当连接完成时，用来提供管理已连接PA的能力private MyRemoteProxy mProxy = null;// 用于管理连接关系private IAbilityConnection mConn = new IAbilityConnection() { @Override public void onAbilityConnectDone(ElementName element, IRemoteObject remote, int resultCode) { // 跨设备PA连接完成后，会返回一个序列化的IRemoteObject对象 // 通过该对象得到控制远端服务的代理 mProxy = new MyRemoteProxy(remote); btnConnectRemotePA.setText(\"connectRemoteAbility done\"); } @Override public void onAbilityDisconnectDone(ElementName element, int resultCode) { // 当已连接的远端PA关闭时，会触发该回调 // 支持开发者按照返回的错误信息进行PA生命周期管理 disconnectAbility(mConn); }}; 仅通过启动/关闭两种方式对PA进行调度无法应对需长期交互的场景，因此，分布式任务调度平台向开发者提供了跨设备PA连接及断开连接的能力。为了对已连接PA进行管理，开发者需要实现一个满足IAbilityConnection接口的连接状态检测实例，通过该实例可以对连接及断开连接完成时设置具体的处理逻辑，例如：获取控制对端PA的代理等。进一步为了使用该代理跨设备调度PA，开发者需要在本地及对端分别实现对外接口一致的代理。一个具备加法能力的代理示例如下： // 以连接提供加法计算能力的PA为例。为了提供跨设备连接能力，需要在本地发起连接侧和对端被连接侧分别实现代理// 发起连接侧的代理示例如下：public class MyRemoteProxy implements IRemoteBroker { private static final int ERR_OK = 0; private static final int COMMAND_PLUS = IRemoteObject.MIN_TRANSACTION_ID; private final IRemoteObject remote; public MyRemoteProxy(IRemoteObject remote) { this.remote = remote; } @Override public IRemoteObject asObject() { return remote; } public int plus(int a, int b) throws RemoteException { MessageParcel data = MessageParcel.obtain(); MessageParcel reply = MessageParcel.obtain(); // option不同的取值，决定采用同步或异步方式跨设备控制PA // 本例需要同步获取对端PA执行加法的结果，因此采用同步的方式，即MessageOption.TF_SYNC // 具体MessageOption的设置，可参考相关API文档 MessageOption option = new MessageOption(MessageOption.TF_SYNC); data.writeInt(a); data.writeInt(b); try { remote.sendRequest(COMMAND_PLUS, data, reply, option); int errCode = reply.readInt(); if (errCode != ERR_OK) { throw new RemoteException(); } int result = reply.readInt(); return result; }finally { data.reclaim(); reply.reclaim(); } }} 此外，对端待连接的PA需要实现对应的客户端，代码示例如下所示： // 以计算加法为例，对端实现的客户端如下public class MyRemote extends RemoteObject implements IRemoteBroker{ private static final int ERR_OK = 0; private static final int ERROR = -1; private static final int COMMAND_PLUS = IRemoteObject.MIN_TRANSACTION_ID; public MyRemote() { super(\"MyService_Remote\"); } @Override public IRemoteObject asObject() { return this; } @Override public boolean onRemoteRequest(int code, MessageParcel data, MessageParcel reply, MessageOption option) { if (code != COMMAND_PLUS) { reply.writeInt(ERROR); return false; } int value1 = data.readInt(); int value2 = data.readInt(); int sum = value1 + value2; reply.writeInt(ERR_OK); reply.writeInt(sum); return true; }} 对端除了要实现如上所述的客户端外，待连接的PA还需要作如下修改： // 为了返回给连接方可调用的代理，需要在该PA中实例化客户端，例如作为该PA的成员变量private MyRemote remote = new MyRemote();// 当该PA接收到连接请求时，即将该客户端转化为代理返回给连接发起侧@Overrideprotected IRemoteObject onConnect(Intent intent) { super.onConnect(intent); return remote.asObject();} 完成上述步骤后，可以通过点击事件实现连接、利用连接关系控制PA以及断开连接等行为，代码示例如下： // 连接远程PAprivate ClickedListener mConnectRemotePAListener = new ClickedListener() { @Override public void onClick(Component arg0) { scheduleRemoteAbility(new ISelectResult() { @Override void onSelectResult(String deviceId) { if (deviceId != null) { Intent connectPAIntent = new Intent(); // bundleName和abilityName与待连接的PA一一对应 // 例如：bundleName = \"com.helloworld\" // abilityName = \"com.helloworld.SampleParticleAbility\" Operation operation = new Intent.OperationBuilder() .withDeviceId(deviceId) .withBundleName(bundleName) .withAbilityName(abilityName) .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) .build(); connectPAIntent.setOperation(operation); connectAbility(connectPAIntent, mConn); } } }); }};// 控制已连接PA执行加法private ClickedListener mControlPAListener = new ClickedListener() { @Override public void onClick(Component arg0) { if (mProxy != null) { int ret = -1; try { ret = mProxy.plus(10, 20); } catch (RemoteException e) { HiLog.error(LABEL, \"ControlRemotePA error\"); } btnControlRemotePA.setText(\"ControlRemotePA result = \" + ret); } }};// 与远程PA断开连接private ClickedListener mDisconnectRemotePAListener = new ClickedListener() { @Override public void onClick(Component arg0) { // 按钮复位 btnConnectRemotePA.setText(\"ConnectRemotePA\"); btnControlRemotePA.setText(\"ControlRemotePA\"); disconnectAbility(mConn); }}; 说明 通过连接/断开连接远程PA，与跨设备PA建立长期的管理关系。例如在本例中，通过连接关系得到远程PA的控制代理后，实现跨设备计算加法并将结果返回到本地显示。在实际开发中，开发者可以根据需要实现多种分布式场景，例如：跨设备位置/电量等信息的采集、跨设备计算资源互助等。 设备A将运行时的FA迁移到设备B，实现业务在设备间无缝迁移。 // 跨设备迁移FA// 本地FA设置当前运行任务private ClickedListener mContinueAbilityListener = new ClickedListener() { @Override public void onClick(Component arg0) { // 用户选择设备后实现业务迁移 scheduleRemoteAbility(new ISelectResult() { @Override public void onSelectResult(String deviceId) { continueAbility(deviceId); } }); }}; FA的迁移还涉及到状态数据的传递，需要继承IAbilityContinuation接口，供开发者实现迁移过程中特定事件的管理能力，代码示例如下： public class SampleSlice extends AbilitySlice implements IAbilityContinuation { @Override public boolean onSaveData(IntentParams saveData) { String exampleData = String.valueOf(System.currentTimeMillis()); saveData.setParam(\"continueParam\", exampleData); return true; } @Override public boolean onRestoreData(IntentParams restoreData) { // 远端FA迁移传来的状态数据，开发者可以按照特定的场景对这些数据进行处理 Object data = restoreData.getParam(\"continueParam\"); return true; } @Override public void onCompleteContinuation(int result) { btnContinueRemoteFA.setText(\"ContinueAbility Done\"); }} 通过自定义迁移事件相关的行为，最终实现对Ability的迁移。具体的定义可以参考相关的API文档，此处主要以较为常用的两个事件，包括迁移发起端完成迁移的回调onCompleteContinuation(int result)以及接收到远端迁移行为传递数据的回调onRestoreData(IntentParams restoreData)。其他还包括迁移到远端设备的FA关闭的回调onRemoteTerminated()、用于本地迁移发起时保存状态数据的回调onSaveData(IntentParams saveData)和本地发起迁移的回调onStartContinuation()。按照实际应用自定义特定场景对应的回调，可以完成多种场景下FA的迁移任务。 说明 FA迁移可以打通设备间的壁垒，有助于不同能力的设备进行互助。前文以一个简单的例子介绍如何通过分布式任务调度提供的能力，实现FA跨设备的迁移（包括FA启动及状态数据的同步）。 FA迁移过程中，远端FA首先接收到发起端FA传输的数据，再执行启动，即onRestoreData()发生在onStart()之前，详见API参考。 相关实例 针对分布式任务调度，有以下示例工程可供参考： DistributedScheduler 本示例演示了分布式任务调度的六种场景：启动远程FA，启动远程PA，关闭远程PA，连接远程PA，断开连接远程PA， 和FA跨端迁移。 针对分布式任务调度，有以下Codelabs可供参考： 分布式调度启动远程FA 基于分布式调度的能力，实现远程FA的启动。 分布式亲子早教系统 基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。 分布式输入法 基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放。 分布式地图导航 基于分布式能力，实现地图导航信息在手机-车机-智能穿戴设备之间流转。 "},"notification-fwk-overview.html":{"url":"notification-fwk-overview.html","title":"公共事件与通知概述","keywords":"","body":"公共事件与通知概述 HarmonyOS通过CES（Common Event Service，公共事件服务）为应用程序提供订阅、发布、退订公共事件的能力，通过ANS（Advanced Notification Service，即通知增强服务）系统服务来为应用程序提供发布通知的能力。 公共事件可分为系统公共事件和自定义公共事件。 系统公共事件：系统将收集到的事件信息，根据系统策略发送给订阅该事件的用户程序。 例如：用户可感知亮灭屏事件，系统关键服务发布的系统事件（例如：USB插拔，网络连接，系统升级等）。 自定义公共事件：应用自定义一些公共事件用来处理业务逻辑。 通知提供应用的即时消息或通信消息，用户可以直接删除或点击通知触发进一步的操作。 IntentAgent封装了一个指定行为的Intent，可以通过IntentAgent启动Ability和发布公共事件。 应用如果需要接收公共事件，需要订阅相应的事件。 约束与限制 公共事件的约束与限制 目前公共事件仅支持动态订阅。部分系统事件需要具有指定的权限，具体的权限见API参考。 目前公共事件订阅不支持多用户。 ThreadMode表示线程模型，目前仅支持HANDLER模式，即在当前UI线程上执行回调函数。 deviceId用来指定订阅本地公共事件还是远端公共事件。deviceId为null、空字符串或本地设备deviceId时，表示订阅本地公共事件，否则表示订阅远端公共事件。 通知的约束与限制 通知目前支持六种样式：普通文本、长文本、图片、社交、多行文本和媒体样式。创建通知时必须包含一种样式。 通知支持快捷回复。 IntentAgent的限制 使用IntentAgent启动Ability时，Intent必须指定Ability的包名和类名。 "},"notification-fwk-common-event.html":{"url":"notification-fwk-common-event.html","title":"公共事件开发指导","keywords":"","body":"公共事件开发指导 场景介绍 每个应用都可以订阅自己感兴趣的公共事件，订阅成功后且公共事件发布后，系统会把其发送给应用。这些公共事件可能来自系统、其他应用和应用自身。HarmonyOS提供了一套完整的API，支持用户订阅、发布和接收公共事件。发布公共事件需要借助CommonEventData对象，接收公共事件需要继承CommonEventSubscriber类并实现onReceiveEvent回调函数。 接口说明 公共事件相关基础类包含CommonEventData、CommonEventPublishInfo、CommonEventSubscribeInfo、CommonEventSubscriber和CommonEventManager。基础类之间的关系如下图所示： 图1 公共事件基础类关系图 CommonEventData CommonEventData封装公共事件相关信息。用于在发布、分发和接收时处理数据。在构造CommonEventData对象时，相关参数需要注意以下事项： code为有序公共事件的结果码，data为有序公共事件的结果数据，仅用于有序公共事件场景。 intent不允许为空，否则发布公共事件失败。 | 接口名 | 描述 | | ----------------------------------------------------- | ------------------------------------------ | | CommonEventData() | 创建公共事件数据。 | | CommonEventData(Intent intent) | 创建公共事件数据指定Intent。 | | CommonEventData(Intent intent, int code, String data) | 创建公共事件数据，指定Intent、code和data。 | | getIntent() | 获取公共事件Intent。 | | setCode(int code) | 设置有序公共事件的结果码。 | | getCode() | 获取有序公共事件的结果码。 | | setData(String data) | 设置有序公共事件的详细结果数据。 | | getData() | 获取有序公共事件的详细结果数据。 | CommonEventPublishInfo CommonEventPublishInfo封装公共事件发布相关属性、限制等信息，包括公共事件类型（有序或粘性）、接收者权限等。 有序公共事件：主要场景是多个订阅者有依赖关系或者对处理顺序有要求，例如：高优先级订阅者可修改公共事件内容或处理结果，包括终止公共事件处理；或者低优先级订阅者依赖高优先级的处理结果等。 有序公共事件的订阅者可以通过[CommonEventSubscribeInfo](https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li1490625910238).setPriority()方法指定优先级，缺省为0，优先级范围[-1000, 1000]，值越大优先级越高。 粘性公共事件：指公共事件的订阅动作是在公共事件发布之后进行，订阅者也能收到的公共事件类型。主要场景是由公共事件服务记录某些系统状态，如蓝牙、WLAN、充电等事件和状态。不使用粘性公共事件机制时，应用可以通过直接访问系统服务获取该状态；在状态变化时，系统服务、硬件需要提供类似observer等方式通知应用。 发布粘性公共事件可以通过setSticky()方法设置， 发布粘性公共事件需要申请如下权限。声明请参考权限开发指导表1 reqPermissions权限申请字段说明。 \"reqPermissions\": [ { \"name\": \"ohos.permission.COMMONEVENT_STICKY\", \"reason\": \"Obtain the required permission\", \"usedScene\": { \"ability\": [ \".MainAbility\" ], \"when\": \"inuse\" } }, { ... }] | 接口名 | 描述 | | ---------------------------------------------------------- | ---------------------------------------------- | | CommonEventPublishInfo() | 创建公共事件信息。 | | CommonEventPublishInfo(CommonEventPublishInfo publishInfo) | 拷贝一个公共事件信息。 | | setSticky(boolean sticky） | 设置公共事件的粘性属性。 | | setOrdered(boolean ordered) | 设置公共事件的有序属性。 | | setSubscriberPermissions(String[] subscriberPermissions) | 设置公共事件订阅者的权限，多参数仅第一个生效。 | CommonEventSubscribeInfo CommonEventSubscribeInfo封装公共事件订阅相关信息，比如优先级、线程模式、事件范围等。 线程模式（ThreadMode）：设置订阅者的回调方法执行的线程模式。ThreadMode有HANDLER，POST，ASYNC，BACKGROUND四种模式，目前只支持HANDLER模式。 HANDLER：在Ability的主线程上执行。 POST：在事件分发线程执行。 ASYNC：在一个新创建的异步线程执行。 BACKGROUND：在后台线程执行。 | 接口名 | 描述 | | ------------------------------------------------------- | -------------------------------------- | | CommonEventSubscribeInfo(MatchingSkills matchingSkills) | 创建公共事件订阅器指定matchingSkills。 | | CommonEventSubscribeInfo(CommonEventSubscribeInfo) | 拷贝公共事件订阅器对象。 | | setPriority(int priority) | 设置优先级，用于有序公共事件。 | | setThreadMode(ThreadMode threadMode) | 指定订阅者的回调函数运行在哪个线程上。 | | setPermission(String permission) | 设置发布者必须具备的权限。 | | setDeviceId(String deviceId) | 指定订阅哪台设备的公共事件。 | CommonEventSubscriber CommonEventSubscriber封装公共事件订阅者及相关参数。 CommonEventSubscriber.AsyncCommonEventResult类处理有序公共事件异步执行，详见API参考。 目前只能通过调用CommonEventManager的subscribeCommonEvent()进行订阅。 | 接口名 | 描述 | | ------------------------------------------------------------ | ------------------------------------------------------------ | | CommonEventSubscriber(CommonEventSubscribeInfo subscribeInfo) | 构造公共事件订阅者实例。 | | onReceiveEvent(CommonEventData data) | 由开发者实现, 在接收到公共事件时被调用。 | | AsyncCommonEventResult goAsyncCommonEvent() | 设置有序公共事件异步执行。 | | setCodeAndData(int code, String data) | 设置有序公共事件的异步结果。 | | setData(String data) | 设置有序公共事件的异步结果数据。 | | setCode(int code) | 设置有序公共事件的异步结果码。 | | getData() | 获取有序公共事件的异步结果数据。 | | getCode() | 获取有序公共事件的异步结果码。 | | abortCommonEvent() | 取消当前的公共事件，仅对有序公共事件有效，取消后，公共事件不再向下一个订阅者传递。 | | getAbortCommonEvent() | 获取当前有序公共事件是否取消的状态。 | | clearAbortCommonEvent() | 清除当前有序公共事件abort状态。 | | isOrderedCommonEvent() | 查询当前公共事件的是否为有序公共事件。 | | isStickyCommonEvent() | 查询当前公共事件是否为粘性公共事件。 | CommonEventManager CommonEventManager是为应用提供订阅、退订和发布公共事件的静态接口类。 方法 描述 publishCommonEvent(CommonEventData eventData) 发布公共事件。 publishCommonEvent(CommonEventData event, CommonEventPublishInfo publishInfo) 发布公共事件指定发布信息。 publishCommonEvent(CommonEventData event, CommonEventPublishInfo publishInfo, CommonEventSubscriber resultSubscriber) 发布有序公共事件，指定发布信息和最后一个接收者。 subscribeCommonEvent(CommonEventSubscriber subscriber) 订阅公共事件。 unsubscribeCommonEvent(CommonEventSubscriber subscriber) 退订公共事件。 发布公共事件 开发者可以发布四种公共事件：无序的公共事件、带权限的公共事件、有序的公共事件、粘性的公共事件。 发布无序的公共事件：构造CommonEventData对象，设置Intent，通过构造operation对象把需要发布的公共事件信息传入intent对象。然后调用 CommonEventManager.publishCommonEvent(CommonEventData) 接口发布公共事件。 try { Intent intent = new Intent(); Operation operation = new Intent.OperationBuilder() .withAction(\"com.my.test\") .build(); intent.setOperation(operation); CommonEventData eventData = new CommonEventData(intent); CommonEventManager.publishCommonEvent(eventData); HiLog.info(LABEL_LOG, \"Publish succeeded\"); } catch (RemoteException e) { HiLog.error(LABEL_LOG, \"Exception occurred during publishCommonEvent invocation.\"); } 发布携带权限的公共事件：构造CommonEventPublishInfo对象，设置订阅者的权限。 订阅者在config.json中申请所需的权限，各字段含义详见 权限申请字段说明 。 说明 非系统已定义的权限，需要先在config.json中自定义，才可以申请使用。详见权限定义字段说明 \"reqPermissions\": [ { \"name\": \"com.example.MyApplication.permission\", \"reason\": \"Obtain the required permission\", \"usedScene\": { \"ability\": [ \".MainAbility\" ], \"when\": \"inuse\" } }, { ... }] 发布带权限的公共事件示例代码如下： Intent intent = new Intent();Operation operation = new Intent.OperationBuilder() .withAction(\"com.my.test\") .build();intent.setOperation(operation);CommonEventData eventData = new CommonEventData(intent);CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();String[] permissions = {\"com.example.MyApplication.permission\"};publishInfo.setSubscriberPermissions(permissions); // 设置权限try { CommonEventManager.publishCommonEvent(eventData, publishInfo); HiLog.info(LABEL_LOG, \"Publish succeeded\"); } catch (RemoteException e) { HiLog.error(LABEL_LOG, \"Exception occurred during publishCommonEvent invocation.\"); } 发布有序的公共事件：构造CommonEventPublishInfo对象，通过setOrdered(true)指定公共事件属性为有序公共事件，也可以指定一个最后的公共事件接收者。 CommonEventSubscriber resultSubscriber = new MyCommonEventSubscriber();CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();publishInfo.setOrdered(true); // 设置属性为有序公共事件try { CommonEventManager.publishCommonEvent(eventData, publishInfo, resultSubscriber); // 指定resultSubscriber为有序公共事件最后一个接收者。} catch (RemoteException e) { HiLog.error(LABEL_LOG, \"Exception occurred during publishCommonEvent invocation.\"); } 发布粘性公共事件：构造CommonEventPublishInfo对象，通过setSticky(true)指定公共事件属性为粘性公共事件。 发布者首先在config.json中申请发布粘性公共事件所需的权限，各字段含义详见权限申请字段说明。 { \"reqPermissions\": [{ \"name\": \"ohos.permission.COMMONEVENT_STICKY\", \"reason\": \"Obtain the required permission\", \"usedScene\": { \"ability\": [ \".MainAbility\" ], \"when\": \"inuse\" } }, { ... }]} 发布粘性公共事件。 CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();publishInfo.setSticky(true); // 设置属性为粘性公共事件try { CommonEventManager.publishCommonEvent(eventData, publishInfo); } catch (RemoteException e) { HiLog.error(LABEL, \"Exception occurred during publishCommonEvent invocation.\"); } 订阅公共事件 创建CommonEventSubscriber派生类，在onReceiveEvent()回调函数中处理公共事件。 说明 此处不能执行耗时操作，否则会阻塞UI线程，产生用户点击没有反应等异常。 class MyCommonEventSubscriber extends CommonEventSubscriber { MyCommonEventSubscriber(CommonEventSubscribeInfo info) { super(info); } @Override public void onReceiveEvent(CommonEventData commonEventData) { } } 构造MyCommonEventSubscriber对象，调用CommonEventManager.subscribeCommonEvent()接口进行订阅。 String event = \"com.my.test\";MatchingSkills matchingSkills = new MatchingSkills();matchingSkills.addEvent(event); // 自定义事件matchingSkills.addEvent(CommonEventSupport.COMMON_EVENT_SCREEN_ON); // 亮屏事件CommonEventSubscribeInfo subscribeInfo = new CommonEventSubscribeInfo(matchingSkills);MyCommonEventSubscriber subscriber = new MyCommonEventSubscriber(subscribeInfo);try { CommonEventManager.subscribeCommonEvent(subscriber); } catch (RemoteException e) { HiLog.error(LABEL, \"Exception occurred during subscribeCommonEvent invocation.\"); } 如果订阅拥有指定权限应用发布的公共事件，发布者需要在config.json中申请权限，各字段含义详见权限申请字段说明。 \"reqPermissions\": [ { \"name\": \"ohos.abilitydemo.permission.PROVIDER\", \"reason\": \"Obtain the required permission\", \"usedScene\": { \"ability\": [\"com.hmi.ivi.systemsetting.MainAbility\"], \"when\": \"inuse\" } }] 如果订阅的公共事件是有序的，可以调用setPriority(）指定优先级。 String event = \"com.my.test\";MatchingSkills matchingSkills = new MatchingSkills();matchingSkills.addEvent(event); // 自定义事件 CommonEventSubscribeInfo subscribeInfo = new CommonEventSubscribeInfo(matchingSkills);subscribeInfo.setPriority(100); // 设置优先级，优先级取值范围[-1000，1000]，值默认为0。MyCommonEventSubscriber subscriber = new MyCommonEventSubscriber(subscribeInfo);try { CommonEventManager.subscribeCommonEvent(subscriber); } catch (RemoteException e) { HiLog.error(LABEL, \"Exception occurred during subscribeCommonEvent invocation.\"); } 针对在onReceiveEvent中不能执行耗时操作的限制，可以使用CommonEventSubscriber的goAsyncCommonEvent()来实现异步操作，函数返回后仍保持该公共事件活跃，且执行完成后必须调用AsyncCommonEventResult .finishCommonEvent()来结束。 EventRunner runner = EventRunner.create(); // EventRunner创建新线程，将耗时的操作放到新的线程上执行MyEventHandler myHandler = new MyEventHandler(runner); // MyEventHandler为EventHandler的派生类，在不同线程间分发和处理事件和Runnable任务@Overridepublic void onReceiveEvent(CommonEventData commonEventData){ final AsyncCommonEventResult result = goAsyncCommonEvent(); Runnable task = new Runnable() { @Override public void run() { ........ // 待执行的操作，由开发者定义 result.finishCommonEvent(); // 调用finish结束异步操作 } }; myHandler.postTask(task);} 退订公共事件 在Ability的onStop()中调用CommonEventManager.unsubscribeCommonEvent()方法来退订公共事件。调用后，之前订阅的所有公共事件均被退订。 try { CommonEventManager.unsubscribeCommonEvent(subscriber); } catch (RemoteException e) { HiLog.error(LABEL, \"Exception occurred during unsubscribeCommonEvent invocation.\"); } 相关实例 针对公共事件开发，有以下示例工程可供参考： CommonEvent 本示例演示了公共事件的订阅、发布和退订。 针对公共事件，有以下Codelabs可供参考： 分布式亲子早教系统 基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。 分布式输入法 基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放。 "},"notification-fwk-notification.html":{"url":"notification-fwk-notification.html","title":"通知开发指导","keywords":"","body":"通知开发指导 场景介绍 HarmonyOS提供了通知功能，即在一个应用的UI界面之外显示的消息，主要用来提醒用户有来自该应用中的信息。当应用向系统发出通知时，它将先以图标的形式显示在通知栏中，用户可以下拉通知栏查看通知的详细信息。常见的使用场景： 显示接收到短消息、即时消息等。 显示应用的推送消息，如广告、版本更新等。 显示当前正在进行的事件，如播放音乐、导航、下载等。 接口说明 通知相关基础类包含NotificationSlot、NotificationRequest和NotificationHelper。基础类之间的关系如下所示： 图1 通知基础类关系图 NotificationSlot NotificationSlot可以对提示音、振动、锁屏显示和重要级别等进行设置。一个应用可以创建一个或多个NotificationSlot，在发布通知时，通过绑定不同的NotificationSlot，实现不同用途。 说明 NotificationSlot需要先通过NotificationHelper的addNotificationSlot(NotificationSlot)方法发布后，通知才能绑定使用；所有绑定该NotificationSlot的通知在发布后都具备相应的特性，对象在创建后，将无法更改这些设置，对于是否启动相应设置，用户有最终控制权。 不指定NotificationSlot时，当前通知会使用默认的NotificationSlot，默认的NotificationSlot优先级为LEVEL_DEFAULT。 接口名 描述 NotificationSlot(String id, String name, int level) 构造NotificationSlot。 setLevel(int level) 设置NotificationSlot的级别。 setName(String name) 设置NotificationSlot的命名。 setDescription(String description) 设置NotificationSlot的描述信息。 enableBypassDnd(boolean bypassDnd) 设置是否绕过系统的免打扰模式。 setEnableVibration(boolean vibration) 设置收到通知时是否使能振动。 setLockscreenVisibleness(int visibleness) 设置在锁屏场景下，收到通知后是否显示，以及显示的效果。 setEnableLight(boolean isLightEnabled) 设置收到通知时是否开启呼吸灯，前提是当前硬件支持呼吸灯。 setLedLightColor(int color) 设置收到通知时的呼吸灯颜色。 setSlotGroup(String groupId) 绑定当前NotificationSlot到一个NotificationSlot组。 NotificationSlot的级别目前支持如下几种， 由低到高： LEVEL_NONE： 表示通知不发布。 LEVEL_MIN：表示通知可以发布，但是不显示在通知栏，不自动弹出，无提示音；该级别不适用于前台服务的场景。 LEVEL_LOW：表示通知可以发布且显示在通知栏，不自动弹出，无提示音。 LEVEL_DEFAULT：表示通知发布后可在通知栏显示，不自动弹出，触发提示音。 LEVEL_HIGH：表示通知发布后可在通知栏显示，自动弹出，触发提示音。 NotificationRequest NotificationRequest用于设置具体的通知对象，包括设置通知的属性，如：通知的分发时间、小图标、大图标、自动删除等参数，以及设置具体的通知类型，如普通文本、长文本等。 接口名 描述 NotificationRequest() 构建一个通知。 NotificationRequest(int notificationId) 构建一个通知，指定通知的id。通知的Id在应用内容具有唯一性，如果不指定，默认为0。 setNotificationId(int notificationId) 设置当前通知id。 setAutoDeletedTime(long time) 设置通知自动取消的时间戳。 setContent(NotificationRequest.NotificationContent content) 设置通知的具体类型。 setDeliveryTime(long deliveryTime) 设置通知分发的时间戳。 setSlotId(String slotId) 设置通知的NotificationSlot id。 setTapDismissed(boolean tapDismissed) 设置通知在用户点击后是否自动取消。 setLittleIcon(PixelMap smallIcon) 设置通知的小图标，在通知左上角显示。 setBigIcon(PixelMap bigIcon) 设置通知的大图标，在通知的右边显示。 setGroupValue(String groupValue) 设置分组通知，相同分组的通知在通知栏显示时，将会折叠在一组应用中显示。 addActionButton(NotificationActionButton actionButton) 设置通知添加通知ActionButton。 setIntentAgent(IntentAgent agent) 设置通知承载指定的IntentAgent，在通知中实现即将触发的事件。 具体的通知类型：目前支持六种类型，包括普通文本NotificationNormalContent、长文本NotificationLongTextContent、图片NotificationPictureContent、多行NotificationMultiLineContent、社交NotificationConversationalContent、媒体NotificationMediaContent。 类名 接口名 描述 NotificationNormalContent setTitle(String title) 设置通知标题。 NotificationNormalContent setText(String text) 设置通知内容。 NotificationNormalContent setAdditionalText(String additionalText) 设置通知次要内容，是对通知内容的补充。 NotificationPictureContent setBriefText(String briefText) 设置通知概要内容，是对通知内容的总结。 NotificationPictureContent setExpandedTitle(String expandedTitle) 设置附加图片的通知展开时的标题。 NotificationPictureContent setBigPicture(PixelMap bigPicture) 设置通知的图片内容，附加在setText(String text)下方。 NotificationLongTextContent setLongText(String longText) 设置通知的长文本。 NotificationConversationalContent setConversationTitle(String conversationTitle) 设置社交通知的标题。 NotificationConversationalContent addConversationalMessage(ConversationalMessage message) 通知添加一条消息。 NotificationMultiLineContent addSingleLine(String line) 在当前通知中添加一行文本。 NotificationMediaContent setAVToken(AVToken avToken) 将媒体通知绑定指定的AVToken。 NotificationMediaContent setShownActions(int[] actions) 设置媒体通知待展示的按钮。 说明 通知发布后，通知的设置不可修改。如果下次发布通知使用相同的id，就会更新之前发布的通知。 NotificationHelper NotificationHelper封装了发布、更新、删除通知等静态方法。 接口名 描述 publishNotification(NotificationRequest request) 发布一条通知。 publishNotification(String tag, NotificationRequest request) 发布一条带TAG的通知。 cancelNotification(int notificationId) 取消指定的通知。 cancelNotification(String tag, int notificationId) 取消指定的带TAG的通知。 cancelAllNotifications() 取消之前发布的所有通知。 addNotificationSlot(NotificationSlot slot) 创建一个NotificationSlot。 getNotificationSlot(String slotId) 获取NotificationSlot。 removeNotificationSlot(String slotId) 删除一个NotificationSlot。 getActiveNotifications() 获取当前应用发的活跃通知。 getActiveNotificationNums() 获取系统中当前应用发的活跃通知的数量。 setNotificationBadgeNum(int num) 设置通知的角标。 setNotificationBadgeNum() 设置当前应用中活跃状态通知的数量在角标显示。 开发步骤 通知的开发指导分为创建NotificationSlot、发布通知和取消通知等开发场景。 创建NotificationSlot NotificationSlot可以设置公共通知的震动，锁屏模式，重要级别等，并通过调用NotificationHelper.addNotificationSlot()发布NotificationSlot对象。 NotificationSlot slot = new NotificationSlot(\"slot_001\", \"slot_default\", NotificationSlot.LEVEL_MIN); // 创建notificationSlot对象slot.setDescription(\"NotificationSlotDescription\");slot.setEnableVibration(true); // 设置振动提醒slot.setLockscreenVisibleness(NotificationRequest.VISIBLENESS_TYPE_PUBLIC);// 设置锁屏模式slot.setEnableLight(true); // 设置开启呼吸灯提醒slot.setLedLightColor(Color.RED.getValue());// 设置呼吸灯的提醒颜色try { NotificationHelper.addNotificationSlot(slot);} catch (RemoteException ex) { HiLog.error(LABEL, \"Exception occurred during addNotificationSlot invocation.\");} 发布通知 构建NotificationRequest对象，应用发布通知前，通过NotificationRequest的setSlotId()方法与NotificationSlot绑定，使该通知在发布后都具备该对象的特征。 int notificationId = 1;NotificationRequest request = new NotificationRequest(notificationId);request.setSlotId(slot.getId()); 调用setContent()设置通知的内容。 String title = \"title\";String text = \"There is a normal notification content.\";NotificationNormalContent content = new NotificationNormalContent();content.setTitle(title) .setText(text);NotificationRequest.NotificationContent notificationContent = new NotificationRequest.NotificationContent(content);request.setContent(notificationContent); // 设置通知的内容 调用publishNotification()发布通知。 try { NotificationHelper.publishNotification(request);} catch (RemoteException ex) { HiLog.error(LABEL, \"Exception occurred during publishNotification invocation.\");} 取消通知 取消通知分为取消指定单条通知和取消所有通知，应用只能取消自己发布的通知。 调用cancelNotification()取消指定的单条通知。 int notificationId = 1;try { NotificationHelper.cancelNotification(notificationId);} catch (RemoteException ex) { HiLog.error(LABEL, \"Exception occurred during cancelNotification invocation.\");} 调用cancelAllNotifications()取消所有通知。 try { NotificationHelper.cancelAllNotifications();} catch (RemoteException ex) { HiLog.error(LABEL, \"Exception occurred during cancelAllNotifications invocation.\");} 相关实例 针对通知开发，有以下示例工程可供参考： Notification 通知功能，即在一个应用的UI界面之外显示的消息，主要用来提醒用户有来自该应用中的信息。本示例演示了如何发布通知和取消通知。 "},"notification-fwk-intentagent.html":{"url":"notification-fwk-intentagent.html","title":"IntentAgent开发指导","keywords":"","body":"IntentAgent开发指导 场景介绍 IntentAgent封装了一个指定行为的Intent，可以通过triggerIntentAgent接口主动触发，也可以与通知绑定被动触发。具体的行为包括：启动Ability和发布公共事件。例如：收到通知后，在点击通知后跳转到一个新的Ability，不点击则不会触发。 接口说明 IntentAgent相关基础类包括IntentAgentHelper、IntentAgentInfo、IntentAgentConstant和TriggerInfo，基础类之间的关系如下图所示： 图1 IntentAgent基础类关系图 IntentAgentHelper IntentAgentHelper封装了获取、激发、取消IntentAgent等静态方法。 接口名 描述 getIntentAgent(Context context, IntentAgentInfo paramsInfo) 获取一个IntentAgent实例。 triggerIntentAgent(Context context, IntentAgent agent, IntentAgent.Oncompleted onCompleted, EventHandler handler, TriggerInfo paramsInfo) 主动激发一个IntentAgent实例。 cancel(IntentAgent agent) 取消一个IntentAgent实例。 judgeEquality(IntentAgent agent, IntentAgent otherAgent) 判断两个IntentAgent实例是否相等。 getHashCode(IntentAgent agent) 获取一个IntentAgent实例的哈希码。 getBundleName(IntentAgent agent) 获取一个IntentAgent实例的包名。 getUid(IntentAgent agent) 获取一个IntentAgent实例的用户ID。 IntentAgentInfo IntentAgentInfo类封装了获取一个IntentAgent实例所需的数据。使用构造函数IntentAgentInfo(int requestCode, OperationType operationType, List flags, List intents, IntentParams extraInfo)获取IntentAgentInfo对象。 requestCode：使用者定义的一个私有值。 operationType：为IntentAgentConstant.OperationType枚举中的值。 flags：为IntentAgentConstant.Flags枚举中的值。 intents：将被执行的意图列表。operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时，intents列表只允许包含一个Intent；operationType的值为START_ABILITIES时，intents列表允许包含多个Intent extraInfo：表明如何启动一个有页面的ability，可以为null，只在operationType的值为START_ABILITY和START_ABILITIES时有意义。 IntentAgentConstant IntentAgentConstant类中包含OperationType和Flags两个枚举类： 类名 枚举值 IntentAgentConstant.OperationType UNKNOWN_TYPE：不识别的类型。START_ABILITY：开启一个有页面的Ability。START_ABILITIES：开启多个有页面的Ability。START_SERVICE：开启一个无页面的ability。SEND_COMMON_EVENT：发送一个公共事件。 IntentAgentConstant.Flags ONE_TIME_FLAG：IntentAgent仅能使用一次。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。NO_BUILD_FLAG：如果描述IntentAgent对象不存在，则不创建它，直接返回null。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。CANCEL_PRESENT_FLAG：在生成一个新的IntentAgent对象前取消已存在的一个IntentAgent对象。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。UPDATE_PRESENT_FLAG：使用新的IntentAgent的额外数据替换已存在的IntentAgent中的额外数据。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。CONSTANT_FLAG：IntentAgent是不可变的。REPLACE_ELEMENT：当前Intent中的element属性可被IntentAgentHelper.triggerIntentAgent()中Intent的element属性取代。REPLACE_ACTION: 当前Intent中的action属性可被IntentAgentHelper.triggerIntentAgent()中Intent的action属性取代。REPLACE_URI：当前Intent中的uri属性可被IntentAgentHelper.triggerIntentAgent()中Intent的uri属性取代。REPLACE_ENTITIES：当前Intent中的entities属性可被IntentAgentHelper.triggerIntentAgent()中Intent的entities属性取代。REPLACE_BUNDLE：当前Intent中的bundleName属性可被IntentAgentHelper.triggerIntentAgent()中Intent的bundleName属性取代。 TriggerInfo TriggerInfo类封装了主动激发一个IntentAgent实例所需的数据，使用构造函数TriggerInfo(String permission, IntentParams extraInfo, Intent intent, int code)获取TriggerInfo对象。 permission：IntentAgent的接收者的权限名称，只在operationType的值为SEND_COMMON_EVENT时，该参数才有意义。 extraInfo：激发IntentAgent时用户自定义的额外数据。 intent：额外的Intent。如果IntentAgentInfo成员变量flags包含CONSTANT_FLAG，则忽略该参数；如果flags包含REPLACE_ELEMENT，REPLACE_ACTION，REPLACE_URI，REPLACE_ENTITIES或REPLACE_BUNDLE，则使用额外Intent的element，action，uri，entities或bundleName属性替换原始Intent中对应的属性。如果intent是空，则不替换原始Intent的属性。 code：提供给IntentAgent目标的结果码。 开发步骤 获取IntentAgent的代码示例如下： // 指定要启动的Ability的BundleName和AbilityName字段// 将Operation对象设置到Intent中Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.testintentagent\") .withAbilityName(\"com.testintentagent.entry.IntentAgentAbility\") .build();intent.setOperation(operation);List intentList = new ArrayList<>();intentList.add(intent);// 定义请求码int requestCode = 200;// 设置flagsList flags = new ArrayList<>();flags.add(IntentAgentConstant.Flags.UPDATE_PRESENT_FLAG);// 指定启动一个有页面的AbilityIntentAgentInfo paramsInfo = new IntentAgentInfo(requestCode, IntentAgentConstant.OperationType.START_ABILITY, flags, intentList, null);// 获取IntentAgent实例IntentAgent agent = IntentAgentHelper.getIntentAgent(this, paramsInfo); 通知中添加IntentAgent的代码示例如下: int notificationId = 1;NotificationRequest request = new NotificationRequest(notificationId);String title = \"title\";String text = \"There is a normal notification content.\";NotificationRequest.NotificationNormalContent content = new NotificationRequest.NotificationNormalContent();content.setTitle(title) .setText(text);NotificationContent notificationContent = new NotificationContent(content);request.setContent(notificationContent); // 设置通知的内容request.setIntentAgent(agent); // 设置通知的IntentAgent 主动激发IntentAgent的代码示例如下： int code = 100;IntentAgentHelper.triggerIntentAgent(this, agent, null, null, new TriggerInfo(null, null, null, code)); 相关实例 针对IntentAgent开发指导，有以下示例工程可供参考： IntentAgent 本示例演示了如何通过IntentAgent启动Ability和发布公共事件。 "},"service-widget-overview.html":{"url":"service-widget-overview.html","title":"概述","keywords":"","body":"概述 服务卡片（以下简称“卡片”）是FA的一种界面展示形式，将FA的重要信息或操作前置到卡片，以达到服务直达，减少体验层级目的。 卡片常用于嵌入到其他应用（当前只支持系统应用）中作为其界面的一部分显示，并支持拉起页面，发送消息等基础的交互功能。卡片使用方负责显示卡片。 示例如下图所示。 基本概念 卡片使用方 显示卡片内容的宿主应用，控制卡片在宿主中展示的位置。 卡片管理服务 用于管理系统中所添加卡片的常驻代理服务，包括卡片对象的管理与使用，以及卡片周期性刷新等。 卡片提供方 提供卡片显示内容的HarmonyOS应用或原子化服务，控制卡片的显示内容、控件布局以及控件点击事件。 说明 卡片使用方和提供方不要求常驻运行，在需要添加/删除/请求更新卡片时，卡片管理服务会拉起卡片提供方获取卡片信息。 运作机制 卡片管理服务包含以下模块： 周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。 卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。 卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。 卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。 通信适配层：负责与卡片使用方和提供方进行RPC通信。 卡片提供方包含以下模块： 卡片服务：由卡片提供方开发者实现，开发者实现onCreateForm、onUpdateForm和onDeleteForm处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。 卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务。 "},"widget-provider-intro.html":{"url":"widget-provider-intro.html","title":"卡片开发说明","keywords":"","body":"卡片开发说明 场景介绍 卡片提供方控制卡片实际显示的内容、控件布局以及控件点击事件。开发者可以通过集成以下接口来提供卡片服务。 接口说明 HarmonyOS中的服务卡片为卡片提供方开发者提供以下接口能力。 类名 接口名 描述 Ability ProviderFormInfo onCreateForm(Intent intent) 卡片提供方接收创建卡片通知接口。 void onUpdateForm(long formId) 卡片提供方接收更新卡片通知接口。 void onDeleteForm(long formId) 卡片提供方接收删除卡片通知接口。 void onTriggerFormEvent(long formId, String message) 卡片提供方处理卡片事件接口（JS卡片使用）。 boolean updateForm(long formId, ComponentProvider component) 卡片提供方主动更新卡片（Java卡片使用）。 boolean updateForm(long formId, FormBindingData formBindingData) 卡片提供方主动更新卡片（JS卡片使用），仅更新formBindingData中携带的信息，卡片中其余信息保持不变。 void onCastTempForm(long formId) 卡片提供方接收临时卡片转常态卡片通知。 void onEventNotify(Map formEvents) 卡片提供方接收到事件通知，其中Ability.FORM_VISIBLE表示卡片可见通知，Ability.FORM_INVISIBLE表示卡片不可见通知。 ProviderFormInfo ProviderFormInfo(int resId, Context context) Java卡片返回对象构造函数。 ProviderFormInfo() JS卡片返回对象构造函数。 void mergeActions(ComponentProvider componentProviderActions) 在提供方侧调用该接口，将开发者在ComponentProvider中设置的actions配置数据合并到当前对象中。 void setJsBindingData(FormBindingData data) 设置JS卡片的内容信息(JS卡片使用)。 其中，onEventNotify仅系统应用才会回调，其他接口回调时机如下图： 说明 卡片管理服务不负责保持卡片的活跃状态（设置了定时更新的除外），当使用方作出相应的请求时，管理服务会拉起提供方并回调相应接口。 Java卡片与JS卡片选型指导 Java/JS卡片场景能力差异如下表所示： 场景 Java卡片 JS卡片 支持的版本 实时刷新（类似时钟） Java使用ComponentProvider做实时刷新代价比较大 JS可以做到端侧刷新，但是需要定制化组件 HarmonyOS 2.0及以上 开发方式 Java UI在卡片提供方需要同时对数据和组件进行处理，生成ComponentProvider远端渲染 JS卡片在使用方加载渲染，提供方只要处理数据、组件和逻辑分离 HarmonyOS 2.0及以上 组件支持 Text、Image、DirectionalLayout、PositionLayout、DependentLayout div、list、list-item、swiper、stack、image、text、span、progress、button（定制：chart 、clock、calendar） HarmonyOS 2.0及以上 卡片内动效 不支持 暂不开放 HarmonyOS 2.0及以上 阴影模糊 不支持 支持 HarmonyOS 2.0及以上 动态适应布局 不支持 支持 HarmonyOS 2.0及以上 自定义卡片跳转页面 不支持 支持 HarmonyOS 2.0及以上 综上所述，JS卡片比JAVA卡片支持的控件和能力都更丰富： Java卡片：适合作为一个直达入口，没有复杂的页面和事件。 JS卡片：适合有复杂界面的卡片。 约束与限制 对于同一个Page ability，在config.json中最多支持配置16张卡片。 "},"widget-provider-js.html":{"url":"widget-provider-js.html","title":"JS卡片开发步骤","keywords":"","body":"JS卡片开发步骤 使用hml+css+js开发JS卡片页面，支持的语法详见JS API参考中“服务卡片开发”部分。 使用DevEco Studio创建卡片工程。 创建成功后，在config.json的module中会生成js模块，用于对应卡片的js相关资源，配置示例如下： \"js\": [ { \"name\": \"card\", \"pages\": [ \"pages/index/index\" ], \"window\": { \"designWidth\": 720, \"autoDesignWidth\": true }, \"type\": \"form\" }] config.json文件“abilities”配置forms模块细节如下，各属性详情可见表1。 \"forms\": [ { \"name\": \"Form_Js\", \"description\": \"form_description\", \"type\": \"JS\", \"jsComponentName\": \"card\", \"formConfigAbility\": \"ability://com.huawei.demo.SecondFormAbility\", \"colorMode\": \"auto\", \"isDefault\": true, \"updateEnabled\": true, \"scheduledUpateTime\": \"10:30\", \"updateDuration\": 1, \"defaultDimension\": \"2*2\", \"supportDimensions\": [ \"2*2\", \"2*4\", \"4*4\" ], \"metaData\": { \"customizeData\": [ { \"name\": \"originWidgetName\", \"value\": \"com.huawei.weather.testWidget\" } ] } }] 说明 配置文件中，应注意如下配置： “js”模块中的name字段要与“forms”模块中的jsComponentName字段的值一致，为js资源的实例名。 “forms”模块中的name为卡片名，即在onCreateForm中根据AbilitySlice.PARAM_FORM_NAME_KEY可取到的值。 除此之外，卡片的Ability中还需要配置\"visible\": true和\"formsEnabled\": true。 定时刷新和定点刷新都配置的情况下，定时刷新优先。 defaultDimension是默认规格，必须设置。 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示卡片的类名。字符串最大长度为127字节。 字符串 否 description - 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。 isDefault - 表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。true：默认卡片。false：非默认卡片。 布尔值 否 type - 表示卡片的类型。取值范围如下：Java：Java卡片。JS：JS卡片。 字符串 否 colorMode - 表示卡片的主题样式，取值范围如下：auto：自适应。dark：深色主题。light：浅色主题。 字符串 可缺省，缺省值为“auto”。 supportDimensions - 表示卡片支持的外观规格，取值范围：12：表示1行2列的二宫格。22：表示2行2列的四宫格。24：表示2行4列的八宫格。44：表示4行4列的十六宫格。 字符串数组 否 defaultDimension - 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否 landscapeLayouts - 表示卡片外观规格对应的横向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 portraitLayouts - 表示卡片外观规格对应的竖向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 updateEnabled - 表示卡片是否支持周期性刷新，取值范围：true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。false：表示不支持周期性刷新。 布尔类型 否 scheduledUpdateTime - 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 字符串 可缺省，缺省值为“0:0”。 updateDuration - 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。 数值 可缺省，缺省值为“0”。 formConfigAbility - 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。 jsComponentName - 表示JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。 字符串 否 metaData - 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。 customizeData - 表示自定义的卡片信息。 对象数组 可缺省，缺省值为空。 name 表示数据项的键名称。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 value 表示数据项的值。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 创建一个FormAbility，覆写卡片相关回调函数。 onCreateForm(Intent intent) onUpdateForm(long formId) onDeleteForm(long formId) onCastTempForm(long formId) onEventNotify(Map formEvents) onTriggerFormEvent(long formId, String message) 当卡片使用方请求获取卡片时，卡片提供方会被拉起并调用onCreateForm(Intent intent)回调，intent中会带有卡片ID，卡片名称和卡片外观规格信息，可按需获取使用。 开发Js卡片时，FormAbility可以继承AceAbility或Ability，继承Ability时，需在onStart()方法中额外设置路由信息。示例分别如下： FormAbility继承AceAbility的代码示例 public class FormAbility extends AceAbility { ...... public static long formId = -1; @Override public void onStart(Intent intent) { super.onStart(intent); } @Override protected ProviderFormInfo onCreateForm(Intent intent) { IntentParams params = intent.getParams(); if (params == null) { return null; } // 卡片ID formId = (long) params.getParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY); // 卡片名称 String formName = (String) params.getParam(AbilitySlice.PARAM_FORM_NAME_KEY); // 卡片规格信息 int specificationId = (int) params.getParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); FormBindingData formBindingData = new FormBindingData(\"{\\\"temperature\\\": \\\"60°\\\"}\"); ProviderFormInfo formInfo = new ProviderFormInfo(); formInfo.setJsBindingData(formBindingData); return formInfo; } @Override protected void onDeleteForm(long formId) { // 删除卡片实例数据 super.onDeleteForm(formId); ...... } @Override protected void onUpdateForm(long formId) { // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要覆写该方法以支持数据更新 super.onUpdateForm(formId); ...... } @Override protected void onTriggerFormEvent(long formId, String message) { // 若卡片支持触发事件，则需要覆写该方法并实现对事件的触发 super.onTriggerFormEvent(formId, message); ...... } @Override protected void onCastTempForm(long formId) { //使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理 super.onCastTempForm (formId); ...... } @Override protected void onEventNotify(Map formEvents) { //使用方发起可见或者不可见通知触发，提供方需要做相应的处理 super.onEventNotify(formEvents); ...... }} FormAbility继承Ability的代码示例 public class FormAbility extends Ability { ...... public static long formId = -1; @Override public void onStart(Intent intent) { super.onStart(intent); super.setMainRoute(FormAbilitySlice.class.getName()); //设置路由 } @Override protected ProviderFormInfo onCreateForm(Intent intent) { IntentParams params = intent.getParams(); if (params == null) { return null; } // 卡片ID formId = (long) params.getParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY); // 卡片名称 String formName = (String) params.getParam(AbilitySlice.PARAM_FORM_NAME_KEY); // 卡片规格信息 int specificationId = (int) params.getParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); FormBindingData formBindingData = new FormBindingData(\"{\\\"temperature\\\": \\\"60°\\\"}\"); ProviderFormInfo formInfo = new ProviderFormInfo(); formInfo.setJsBindingData(formBindingData); return formInfo; } @Override protected void onDeleteForm(long formId) { // 删除卡片实例数据 super.onDeleteForm(formId); ...... } @Override protected void onUpdateForm(long formId) { // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要覆写该方法以支持数据更新 super.onUpdateForm(formId); ...... } @Override protected void onTriggerFormEvent(long formId, String message) { // 若卡片支持触发事件，则需要覆写该方法并实现对事件的触发 super.onTriggerFormEvent(formId, message); ...... } @Override protected void onCastTempForm(long formId) { //使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理 super.onCastTempForm (formId); ...... } @Override protected void onEventNotify(Map formEvents) { //使用方发起可见或者不可见通知触发，提供方需要做相应的处理 super.onEventNotify(formEvents); ...... }} 卡片信息持久化。 因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息，且卡片框架支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。且需要适配onDeleteForm(long formId)卡片删除通知接口，在其中实现卡片实例数据的删除。 常态卡片：卡片使用方会持久化的卡片； 暂态卡片：卡片使用方不会持久化的卡片； 需要注意的是，卡片使用方在请求卡片时传递给提供方应用的Intent数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片，由于临时卡片的数据不会持久化的特殊性，某些场景比如卡片服务框架死亡重启，此时临时卡片数据在卡片服务框架中已经删除，且对应的卡片id不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片id进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。 @Overrideprotected ProviderFormInfo onCreateForm(Intent intent) {long formId = intent.getIntParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY, -1L); String formName = params.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY); int specificationId = params.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0); boolean tempFlag = params.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); ....... // 由开发人员自行实现，将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用 storeFormInfo(formId, formName, specificationId, formData); ...... HiLog.info(LABEL_LOG, \"onCreateForm finish.......\"); return formInfo;}@Overrideprotected void onDeleteForm(long formId) { super.onDeleteForm(formId); // 由开发人员自行实现，删除卡片实例数据 deleteFormInfo(formId); ......}@Overrideprotected void onCastTempForm(long formId) { // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理 super.onCastTempForm (formId); ......} 卡片数据交互。 当卡片应用需要更新数据时（如触发了定时更新或定点更新），卡片应用获取最新数据，并调用updateForm接口更新卡片。示例如下： @Overrideprotected void onUpdateForm(long formId) { super.onUpdateForm(formId); ZSONObject zsonObject = new ZSONObject(); zsonObject.put(\"temperature\", \"90°\"); FormBindingData formBindingData = new FormBindingData(zsonObject); // 调用updateForm接口去更新对应的卡片，仅更新入参中携带的数据信息，其他信息保持不变 if (!updateForm(formId, formBindingData)) { // err process }} 开发JS卡片页面。 JS卡片页面与普通FA类似通过hml+css+js开发，但不支持复杂js语法。详情请参考JS API参考。 示例如下： hml： css：.container { flex-direction: column; justify-content: center; align-items: center;} .stack_container { width: 100%; height: 100%; background-image: url(\"/common/weather-background-day.png\"); background-size: cover;}... js：export default { data: { temperature: \"35°\", city: \"hangzhou\" }, actions: { routerEvent: { action: \"router\", bundleName: \"com.example.myapplication\", abilityName: \"com.example.myapplication.FormAbility\", params: { message: \"weather\" } }, messageEvent: { action: \"message\", params: { message: \"weather update\" } } }} 开发JS卡片事件和Action。 JS卡片支持为组件设置action，包括router事件和message事件，其中router事件用于应用跳转，message事件用于卡片开发人员自定义点击事件。关键步骤说明如下： 在hml中为组件设置onclick属性，其值对应到js文件的actions属性中。 若设置router事件，则 action属性值为\"router\"； abilityName为卡片提供方应用的跳转目标Ability名； params中的值按需填写，其值在使用时通过intent.getStringParam(\"params\")获取即可； 若设置message事件，则action属性值为\"message\"，params为json格式的值。 示例如下： hml： js：export default { actions: { routerEvent: { action: \"router\", abilityName: \"com.example.myapplication.FormAbility\", params: { message: \"weather\" } }, messageEvent: { action: \"message\", params: { message: \"test date\", } } }} 当点击组件触发message事件时，卡片应用的onTriggerFormEvent方法被触发，params属性的值将作为参数被传入，解析使用即可。 说明 message事件由于是自定义，也可以在message事件中实现跳转到其他Ability的能力。但是，在这种情况下，宿主侧定义的动效是不生效的。宿主侧定义的动效仅在router事件的跳转中生效。 如果想要保证动效，使用routerEvent。 routerEvent配置跳转链接时，只能配置到卡片提供方自己的ability中。 "},"widget-provider-java.html":{"url":"widget-provider-java.html","title":"Java卡片开发指导","keywords":"","body":"Java卡片开发指导 使用DevEco Studio创建卡片工程。 卡片应用是一款特殊的元能力服务，其配置文件config.json中声明以下几项，系统能够识别该应用为一款卡片应用，并与系统进行绑定。 config.json文件\"abilities\"配置forms模块细节如下，各属性详情可见表1。 \"forms\": [ { \"name\": \"Form_Java\", \"description\": \"form_description\", \"type\": \"Java\", \"colorMode\": \"auto\", \"isDefault\": true, \"updateEnabled\": true, \"scheduledUpateTime\": \"10:30\", \"updateDuration\": 1, \"defaultDimension\": \"2*2\", \"formVisibleNotify\": true, \"supportDimensions\": [ \"1*2\", \"2*2\", \"2*4\", \"4*4\" ], \"landscapeLayouts\": [ \"$layout:form_ability_layout_1_2\", \"$layout:form_ability_layout_2_2\", \"$layout:form_ability_layout_2_4\", \"$layout:form_ability_layout_4_4\" ], \"portraitLayouts\": [ \"$layout:form_ability_layout_1_2\", \"$layout:form_ability_layout_2_2\", \"$layout:form_ability_layout_2_4\", \"$layout:form_ability_layout_4_4\" ], \"formConfigAbility\": \"ability://SecondFormAbility\", \"metaData\": { \"customizeData\": [ { \"name\": \"originWidgetName\", \"value\": \"com.huawei.weather.testWidget\" } ] } }] 说明 \"forms\"模块中的name为卡片名，即在onCreateForm中根据AbilitySlice.PARAM_FORM_NAME_KEY可取到的值。 除此之外，在卡片所在的\"abilities\"中还需要配置\"visible\": true和\"formsEnabled\": true。 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示卡片的类名。字符串最大长度为127字节。 字符串 否 description - 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。 isDefault - 表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。true：默认卡片。false：非默认卡片。 布尔值 否 type - 表示卡片的类型。取值范围如下：Java：Java卡片。JS：JS卡片。 字符串 否 colorMode - 表示卡片的主题样式，取值范围如下：auto：自适应。dark：深色主题。light：浅色主题。 字符串 可缺省，缺省值为“auto”。 supportDimensions - 表示卡片支持的外观规格，取值范围：12：表示1行2列的二宫格。22：表示2行2列的四宫格。24：表示2行4列的八宫格。44：表示4行4列的十六宫格。 字符串数组 否 defaultDimension - 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否 landscapeLayouts - 表示卡片外观规格对应的横向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 portraitLayouts - 表示卡片外观规格对应的竖向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 updateEnabled - 表示卡片是否支持周期性刷新，取值范围：true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。false：表示不支持周期性刷新。 布尔类型 否 scheduledUpdateTime - 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 字符串 可缺省，缺省值为“0:0”。 updateDuration - 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。 数值 可缺省，缺省值为“0”。 formConfigAbility - 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。 jsComponentName - 表示JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。 字符串 否 metaData - 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。 customizeData - 表示自定义的卡片信息。 对象数组 可缺省，缺省值为空。 name 表示数据项的键名称。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 value 表示数据项的值。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 创建一个FormAbility，覆写卡片相关回调函数。 onCreateForm(Intent intent) onUpdateForm(long formId) onDeleteForm(long formId) onCastTempForm(long formId) onEventNotify(Map formEvents) 在onCreateForm(Intent intent)中，当卡片使用方请求获取卡片时，卡片提供方会被拉起并调用onCreateForm(Intent intent)回调，intent中会带有卡片ID，卡片名称，临时卡片标记和卡片外观规格信息，分别通过AbilitySlice.PARAM_FORM_IDENTITY_KEY、AbilitySlice.PARAM_FORM_NAME_KEY、AbilitySlice.PARAM_FORM_TEMORARY_KEY和AbilitySlice.PARAM_FORM_DIMENSION_KEY按需获取。 提供方可以通过AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY获取卡片使用方设置的自定义数据。 public class FormAbility extends Ability { ...... @Override public void onStart(Intent intent) { super.onStart(intent); ...... } @Override protected ProviderFormInfo onCreateForm(Intent intent) { long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY, 0); String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY); int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0); boolean tempFlag = intent.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false); // 获取自定义数据 IntentParams intentParams = intent.getParam(AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); // 开发者需要根据卡片的名称以及外观规格获取对应的xml布局并构造卡片对象，此处ResourceTable.Layout_form_ability_layout_2_2仅为示例 ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this); // 获取卡片信息 String formData = getInitFormData(formName, specificationId); ComponentProvider componentProvider = new ComponentProvider(); componentProvider.setText(ResourceTable.Id_title, \"formData-\" + formData); formInfo.mergeActions(componentProvider); ...... HiLog.info(LABEL_LOG, \"onCreateForm finish.......\"); return formInfo; } @Override protected void onDeleteForm(long formId) { super.onDeleteForm(formId); // 删除卡片实例数据，需要由开发者实现 deleteFormInfo(formId); ...... } @Override // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要覆写该方法以支持数据更新 protected void onUpdateForm(long formId) { super.onUpdateForm(formId); // 更新卡片信息，由开发者实现 ...... } @Override protected void onCastTempForm(long formId) { // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理，将数据持久化。 super.onCastTempForm (formId); ...... } @Override protected void onEventNotify(Map formEvents) { // 使用方发起可见或者不可见通知触发，提供方需要做相应的处理，比如卡片可见时刷新卡片，仅系统应用能收到该回调。 super.onEventNotify(formEvents); ...... }} 卡片信息持久化。 因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息。且卡片框架支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要提供方对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。 同时，需要适配onDeleteForm(int formId)卡片删除通知接口，在其中实现卡片实例数据的删除。和JS卡片相同，需要注意卡片使用方在请求卡片时传递给提供方应用的Intent数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片，由于临时卡片的数据不会持久化的特殊性，某些场景比如卡片服务框架死亡重启，此时临时卡片数据在卡片服务框架中已经删除，且对应的卡片ID不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片ID进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。 @Overrideprotected ProviderFormInfo onCreateForm(Intent intent) { long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_ID_KEY, -1L); String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY); int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0); boolean tempFlag = params.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); ....... // 将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用，该方法需要由开发者实现。 storeFormInfo(formId, formName, specificationId, formData); ...... HiLog.info(LABEL_LOG, \"onCreateForm finish.......\"); return formInfo;}@Overrideprotected void onDeleteForm(long formId) { super.onDeleteForm(formId); // 由开发人员自行实现，删除卡片实例数据 deleteFormInfo(formId); ......}@Overrideprotected void onCastTempForm(long formId) { // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理 super.onCastTempForm (formId); ......} 卡片数据更新。 当需要卡片提供方更新数据时（如触发了定时更新，定点更新，或者卡片使用方主动请求更新），卡片提供方获取最新数据，并调用updateForm接口更新卡片。示例如下： @Overrideprotected void onUpdateForm(long formId) { super.onUpdateForm(formId); ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, this); // 获取卡片实例需要更新的卡片数据，需要由开发者实现 String formData = getUpdateFormData(formId); componentProvider.setText(ResourceTable.Id_title, \"update formData-\" + formData); updateForm(formId, componentProvider); ......} 卡片使用方点击拉起卡片页面，会在onStart(Intent intent)中携带formId（通过AbilitySlice.PARAM_FORM_IDENTITY_KEY获取），若需要在AbilitySlice中更新，也可以使用updateForm接口进行更新，示例如下： public class FormAbilitySlice extends AbilitySlice { ...... @Override public void onStart(Intent intent) { super.onStart(intent); ...... Button button = new Button(this); button.setText(\"Update form data\"); button.setClickedListener(component -> { ...... if (intent.hasParameter(AbilitySlice.PARAM_FORM_IDENTITY_KEY)) { int formId = intent.getIntParam(AbilitySlice.PARAM_FORM_ID_KEY, -1); ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, context); String formData = getUpdateFormData(formId); componentProvider.setText(ResourceTable.Id_modifylayout, \"update formData-\" + formData); getAbility().updateForm(formId, componentProvider); } }); ...... }} Java卡片控制事件。 Java卡片当前通过IntentAgent能力支持对卡片控制设置事件，例如可以使用START_ABILITY、START_SERVICE这两类能力，在点击整张卡片时，跳转到提供卡片的ability。 示例如下： @Overrideprotected ProviderFormInfo onCreateForm(Intent intent) { ...... ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this); ComponentProvider componentProvider = new ComponentProvider(); // 针对title控件设置事件 componentProvider.setIntentAgent(ResourceTable.Id_title, startAbilityIntentAgent()); formInfo.mergeActions(componentProvider); ...... return formInfo;} // 设置触发的事件为系统预置的HarmonyOS betaApp应用private IntentAgent startAbilityIntentAgent() { Intent intent = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.huawei.ohos.betaapp.link\") .withAbilityName(\"com.huawei.ohos.betaapp.link.MainAbility\") .build(); intent.setOperation(operation); List intentList = new ArrayList<>(); intentList.add(intent); List flags = new ArrayList<>(); flags.add(Flags.UPDATE_PRESENT_FLAG); IntentAgentInfo paramsInfo = new IntentAgentInfo(200, IntentAgentConstant.OperationType.START_ABILITY, flags, intentList, null); IntentAgent intentAgent = IntentAgentHelper.getIntentAgent(this, paramsInfo); return intentAgent;} 开发Java卡片布局。 在使用DevEco Studio创建模块时会生成对应的Java UI xml布局文件，具体规则请参考《XML创建布局》，需要注意设置ohos:remote=\"true\"。 以下是天气卡片xml布局示例，供参考： "},"widget-provider-optional.html":{"url":"widget-provider-optional.html","title":"其他可选功能开发指引","keywords":"","body":"其他可选功能开发指引 使用DevEco Studio创建卡片工程。 卡片应用是一款特殊的元能力服务，其配置文件config.json中声明以下几项，系统能够识别该应用为一款卡片应用，并与系统进行绑定。 config.json文件\"abilities\"配置forms模块细节如下，各属性详情可见表1。 \"forms\": [ { \"name\": \"Form_Java\", \"description\": \"form_description\", \"type\": \"Java\", \"colorMode\": \"auto\", \"isDefault\": true, \"updateEnabled\": true, \"scheduledUpateTime\": \"10:30\", \"updateDuration\": 1, \"defaultDimension\": \"2*2\", \"formVisibleNotify\": true, \"supportDimensions\": [ \"1*2\", \"2*2\", \"2*4\", \"4*4\" ], \"landscapeLayouts\": [ \"$layout:form_ability_layout_1_2\", \"$layout:form_ability_layout_2_2\", \"$layout:form_ability_layout_2_4\", \"$layout:form_ability_layout_4_4\" ], \"portraitLayouts\": [ \"$layout:form_ability_layout_1_2\", \"$layout:form_ability_layout_2_2\", \"$layout:form_ability_layout_2_4\", \"$layout:form_ability_layout_4_4\" ], \"formConfigAbility\": \"ability://SecondFormAbility\", \"metaData\": { \"customizeData\": [ { \"name\": \"originWidgetName\", \"value\": \"com.huawei.weather.testWidget\" } ] } }] 说明 \"forms\"模块中的name为卡片名，即在onCreateForm中根据AbilitySlice.PARAM_FORM_NAME_KEY可取到的值。 除此之外，在卡片所在的\"abilities\"中还需要配置\"visible\": true和\"formsEnabled\": true。 属性名称 子属性名称 含义 数据类型 是否可缺省 name - 表示卡片的类名。字符串最大长度为127字节。 字符串 否 description - 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。 isDefault - 表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。true：默认卡片。false：非默认卡片。 布尔值 否 type - 表示卡片的类型。取值范围如下：Java：Java卡片。JS：JS卡片。 字符串 否 colorMode - 表示卡片的主题样式，取值范围如下：auto：自适应。dark：深色主题。light：浅色主题。 字符串 可缺省，缺省值为“auto”。 supportDimensions - 表示卡片支持的外观规格，取值范围：12：表示1行2列的二宫格。22：表示2行2列的四宫格。24：表示2行4列的八宫格。44：表示4行4列的十六宫格。 字符串数组 否 defaultDimension - 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否 landscapeLayouts - 表示卡片外观规格对应的横向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 portraitLayouts - 表示卡片外观规格对应的竖向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。 字符串数组 否 updateEnabled - 表示卡片是否支持周期性刷新，取值范围：true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。false：表示不支持周期性刷新。 布尔类型 否 scheduledUpdateTime - 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 字符串 可缺省，缺省值为“0:0”。 updateDuration - 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。 数值 可缺省，缺省值为“0”。 formConfigAbility - 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。 jsComponentName - 表示JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。 字符串 否 metaData - 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。 customizeData - 表示自定义的卡片信息。 对象数组 可缺省，缺省值为空。 name 表示数据项的键名称。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 value 表示数据项的值。字符串最大长度为255字节。 字符串 可缺省，缺省值为空。 创建一个FormAbility，覆写卡片相关回调函数。 onCreateForm(Intent intent) onUpdateForm(long formId) onDeleteForm(long formId) onCastTempForm(long formId) onEventNotify(Map formEvents) 在onCreateForm(Intent intent)中，当卡片使用方请求获取卡片时，卡片提供方会被拉起并调用onCreateForm(Intent intent)回调，intent中会带有卡片ID，卡片名称，临时卡片标记和卡片外观规格信息，分别通过AbilitySlice.PARAM_FORM_IDENTITY_KEY、AbilitySlice.PARAM_FORM_NAME_KEY、AbilitySlice.PARAM_FORM_TEMORARY_KEY和AbilitySlice.PARAM_FORM_DIMENSION_KEY按需获取。 提供方可以通过AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY获取卡片使用方设置的自定义数据。 public class FormAbility extends Ability { ...... @Override public void onStart(Intent intent) { super.onStart(intent); ...... } @Override protected ProviderFormInfo onCreateForm(Intent intent) { long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY, 0); String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY); int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0); boolean tempFlag = intent.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false); // 获取自定义数据 IntentParams intentParams = intent.getParam(AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); // 开发者需要根据卡片的名称以及外观规格获取对应的xml布局并构造卡片对象，此处ResourceTable.Layout_form_ability_layout_2_2仅为示例 ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this); // 获取卡片信息 String formData = getInitFormData(formName, specificationId); ComponentProvider componentProvider = new ComponentProvider(); componentProvider.setText(ResourceTable.Id_title, \"formData-\" + formData); formInfo.mergeActions(componentProvider); ...... HiLog.info(LABEL_LOG, \"onCreateForm finish.......\"); return formInfo; } @Override protected void onDeleteForm(long formId) { super.onDeleteForm(formId); // 删除卡片实例数据，需要由开发者实现 deleteFormInfo(formId); ...... } @Override // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要覆写该方法以支持数据更新 protected void onUpdateForm(long formId) { super.onUpdateForm(formId); // 更新卡片信息，由开发者实现 ...... } @Override protected void onCastTempForm(long formId) { // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理，将数据持久化。 super.onCastTempForm (formId); ...... } @Override protected void onEventNotify(Map formEvents) { // 使用方发起可见或者不可见通知触发，提供方需要做相应的处理，比如卡片可见时刷新卡片，仅系统应用能收到该回调。 super.onEventNotify(formEvents); ...... }} 卡片信息持久化。 因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息。且卡片框架支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要提供方对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。 同时，需要适配onDeleteForm(int formId)卡片删除通知接口，在其中实现卡片实例数据的删除。和JS卡片相同，需要注意卡片使用方在请求卡片时传递给提供方应用的Intent数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片，由于临时卡片的数据不会持久化的特殊性，某些场景比如卡片服务框架死亡重启，此时临时卡片数据在卡片服务框架中已经删除，且对应的卡片ID不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片ID进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。 @Overrideprotected ProviderFormInfo onCreateForm(Intent intent) { long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_ID_KEY, -1L); String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY); int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0); boolean tempFlag = params.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false); HiLog.info(LABEL_LOG, \"onCreateForm: \" + formId + \" \" + formName + \" \" + specificationId); ....... // 将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用，该方法需要由开发者实现。 storeFormInfo(formId, formName, specificationId, formData); ...... HiLog.info(LABEL_LOG, \"onCreateForm finish.......\"); return formInfo;}@Overrideprotected void onDeleteForm(long formId) { super.onDeleteForm(formId); // 由开发人员自行实现，删除卡片实例数据 deleteFormInfo(formId); ......}@Overrideprotected void onCastTempForm(long formId) { // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理 super.onCastTempForm (formId); ......} 卡片数据更新。 当需要卡片提供方更新数据时（如触发了定时更新，定点更新，或者卡片使用方主动请求更新），卡片提供方获取最新数据，并调用updateForm接口更新卡片。示例如下： @Overrideprotected void onUpdateForm(long formId) { super.onUpdateForm(formId); ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, this); // 获取卡片实例需要更新的卡片数据，需要由开发者实现 String formData = getUpdateFormData(formId); componentProvider.setText(ResourceTable.Id_title, \"update formData-\" + formData); updateForm(formId, componentProvider); ......} 卡片使用方点击拉起卡片页面，会在onStart(Intent intent)中携带formId（通过AbilitySlice.PARAM_FORM_IDENTITY_KEY获取），若需要在AbilitySlice中更新，也可以使用updateForm接口进行更新，示例如下： public class FormAbilitySlice extends AbilitySlice { ...... @Override public void onStart(Intent intent) { super.onStart(intent); ...... Button button = new Button(this); button.setText(\"Update form data\"); button.setClickedListener(component -> { ...... if (intent.hasParameter(AbilitySlice.PARAM_FORM_IDENTITY_KEY)) { int formId = intent.getIntParam(AbilitySlice.PARAM_FORM_ID_KEY, -1); ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, context); String formData = getUpdateFormData(formId); componentProvider.setText(ResourceTable.Id_modifylayout, \"update formData-\" + formData); getAbility().updateForm(formId, componentProvider); } }); ...... }} Java卡片控制事件。 Java卡片当前通过IntentAgent能力支持对卡片控制设置事件，例如可以使用START_ABILITY、START_SERVICE这两类能力，在点击整张卡片时，跳转到提供卡片的ability。 示例如下： @Overrideprotected ProviderFormInfo onCreateForm(Intent intent) { ...... ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this); ComponentProvider componentProvider = new ComponentProvider(); // 针对title控件设置事件 componentProvider.setIntentAgent(ResourceTable.Id_title, startAbilityIntentAgent()); formInfo.mergeActions(componentProvider); ...... return formInfo;} // 设置触发的事件为系统预置的HarmonyOS betaApp应用private IntentAgent startAbilityIntentAgent() { Intent intent = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.huawei.ohos.betaapp.link\") .withAbilityName(\"com.huawei.ohos.betaapp.link.MainAbility\") .build(); intent.setOperation(operation); List intentList = new ArrayList<>(); intentList.add(intent); List flags = new ArrayList<>(); flags.add(Flags.UPDATE_PRESENT_FLAG); IntentAgentInfo paramsInfo = new IntentAgentInfo(200, IntentAgentConstant.OperationType.START_ABILITY, flags, intentList, null); IntentAgent intentAgent = IntentAgentHelper.getIntentAgent(this, paramsInfo); return intentAgent;} 开发Java卡片布局。 在使用DevEco Studio创建模块时会生成对应的Java UI xml布局文件，具体规则请参考《XML创建布局》，需要注意设置ohos:remote=\"true\"。 以下是天气卡片xml布局示例，供参考： "},"pasteboard-overview.html":{"url":"pasteboard-overview.html","title":"剪贴板开发概述","keywords":"","body":"剪贴板开发概述 用户通过系统剪贴板服务，可实现应用之间的简单数据传递。例如：在应用A中复制的数据，可以在应用B中粘贴，反之亦可。 HarmonyOS提供系统剪贴板服务的操作接口，支持用户程序从系统剪贴板中读取、写入和查询剪贴板数据，以及添加、移除系统剪贴板数据变化的回调。 HarmonyOS提供剪贴板数据的对象定义，包含内容对象和属性对象。 "},"pasteboard-guidelines.html":{"url":"pasteboard-guidelines.html","title":"剪贴板开发指导","keywords":"","body":"剪贴板开发指导 场景介绍 同一设备的应用程序A、B之间可以借助系统剪贴板服务完成简单数据的传递，即应用程序A向剪贴板服务写入数据后，应用程序B可以从中读取出数据。 图1 剪贴板服务示意图 在使用剪贴板服务时，需要注意以下几点： 只有在前台获取到焦点的应用才有读取系统剪贴板的权限（系统默认输入法应用除外）。 写入到剪贴板服务中的剪贴板数据不会随应用程序结束而销毁。 对同一用户而言，写入剪贴板服务的数据会被下一次写入的剪贴板数据所覆盖。 在同一设备内，剪贴板单次传递内容不应超过500KB。 接口说明 SystemPasteboard提供系统剪贴板操作的相关接口，比如复制、粘贴、配置回调等。PasteData是剪贴板服务操作的数据对象，一个PasteData由若干个内容节点（PasteData.Record）和一个属性集合对象（PasteData.DataProperty）组成。Record是存放剪贴板数据内容信息的最小单位，每个Record都有其特定的MIME类型，如纯文本、HTML、URI、Intent。剪贴板数据的属性信息存在放PasteData.DataProperty中，包括标签、时间戳等。 SystemPasteboard SystemPasteboard提供系统剪贴板服务的操作接口，比如复制、粘贴、配置回调等。 接口名 描述 getSystemPasteboard(Context context) 获取系统剪切板服务的对象实例。 getPasteData() 读取当前系统剪贴板中的数据。 hasPasteData() 判断当前系统剪贴板中是否有内容。 setPasteData(PasteData data) 将剪贴板数据写入到系统剪贴板。 clear() 清空系统剪贴板数据。 addPasteDataChangedListener(IPasteDataChangedListener listener) 用户程序添加系统剪贴板数据变化的回调，当系统剪贴板数据发生变化时，会触发用户程序的回调实现。 removePasteDataChangedListener(IPasteDataChangedListener listener) 用户程序移除系统剪贴板数据变化的回调。 PasteData PasteData是剪贴板服务操作的数据对象，其中内容节点定义为PasteData.Record，属性集合定义为PasteData.DataProperty。 接口名 描述 PasteData() 构造器，创建一个空内容数据对象。 creatPlainTextData(CharSequence text) 构建一个包含纯文本内容节点的数据对象。 creatHtmlData(String htmlText) 构建一个包含HTML内容节点的数据对象。 creatUriData(Uri uri) 构建一个包含URI内容节点的数据对象。 creatIntentData(Intent intent) 构建一个包含Intent内容节点的数据对象。 getPrimaryMimeType() 获取数据对象中首个内容节点的MIME类型，如果没有查询到内容，将返回一个空字符串。 getPrimaryText() 获取数据对象中首个内容节点的纯文本内容，如果没有查询到内容，将返回一个空对象。 addTextRecord(CharSequence text) 向数据对象中添加一个纯文本内容节点，该方法会自动更新数据属性中的MIME类型集合，最多只能添加128个内容节点。 addRecord(Record record) 向数据对象中添加一个内容节点，该方法会自动更新数据属性中的MIME类型集合，最多只能添加128个内容节点。 getRecordCount() 获取数据对象中内容节点的数量。 getRecordAt(int index) 获取数据对象在指定下标处的内容节点，如果操作失败会返回空对象。 removeRecordAt(int index) 移除数据对象在指定下标处的内容节点，如果操作成功会返回true，操作失败会返回false。 getMimeTypes() 获取数据对象中上所有内容节点的MIME类型列表，当内容节点为空时，返回列表为空对象。 getProperty() 获取该数据对象的属性集合成员。 常量名 描述 MIMETYPE_TEXT_PLAIN= \"text/plain\" 纯文本的MIME类型定义。 MIMETYPE_TEXT_HTML= \"text/html\" HTML的MIME类型定义。 MIMETYPE_TEXT_URI= \"text/uri\" URI的MIME类型定义。 MIMETYPE_TEXT_INTENT= \"text/ohos.intent\" Intent的MIME类型定义。 MAX_RECORD_NUM=128 单个PasteData中所能包含的Record的数量上限。 PasteData.Record 一个PasteData中包含若干个特定MIME类型的PasteData.Record，每个Record是存放剪贴板数据内容信息的最小单位。 接口名 描述 createPlainTextRecord(CharSequence text) 构造一个MIME类型为纯文本的内容节点。 createHtmlTextRecord(String htmlText) 构造一个MIME类型为HTML的内容节点。 createUriRecord(Uri uri) 构造一个MIME类型为URI的内容节点。 createIntentRecord(Intent intent) 构造一个MIME类型为Intent的内容节点。 getPlainText() 获取该内容节点中的文本内容，如果没有内容将返回空对象。 getHtmlText() 获取该内容节点中的HTML内容，如果没有内容将返回空对象。 getUri() 获取该内容节点中的URI内容，如果没有内容将返回空对象。 getIntent() 获取该内容节点中的Intent内容，如果没有内容将返回空对象。 getMimeType() 获取该内容节点的MIME类型。 convertToText(Context context) 将该内容节点的内容转为文本形式。 PasteData.DataProperty 每个PasteData中都有一个PasteData.DataProperty成员，其中存放着该数据对象的属性集合，例如自定义标签、MIME类型集合列表等。 接口名 描述 getMimeTypes() 获取所属数据对象的MIME类型集合列表，当内容节点为空时，返回列表为空对象。 hasMimeType(String mimeType) 判断所属数据对象中是否包含特定MIME类型的内容。 getTimestamp() 获取所属数据对象被写入系统剪贴板时的时间戳，如果该数据对象尚未被写入，则返回0。 setTag(CharSequence tag) 设置自定义标签。 getTag() 获取自定义标签。 setAdditions(PacMap extraProps) 设置一些附加键值对信息。 getAdditions() 获取附加键值对信息。 IPasteDataChangedListener IPasteDataChangedListener是定义剪贴板数据变化回调的接口类，开发者需要实现此接口来编码触发回调时的处理逻辑。 接口名 描述 onChanged() 当系统剪贴板数据发生变化时的回调接口。 开发步骤 应用A获取系统剪贴板服务。 SystemPasteboard pasteboard = SystemPasteboard.getSystemPasteboard(appContext); 应用A向系统剪贴板中写入一条纯文本数据。 if (pasteboard != null) { pasteboard.setPasteData(PasteData.creatPlainTextData(\"Hello, world!\"));} 应用B从系统剪贴板读取数据，将数据对象中的首个文本类型（纯文本/HTML）内容信息在控件中显示，忽略其他类型内容。 PasteData pasteData = pasteboard.getPasteData();if (pasteData == null) { return;}DataProperty dataProperty = pasteData.getProperty();boolean hasHtml = dataProperty.hasMimeType(PasteData.MIMETYPE_TEXT_HTML);boolean hasText = dataProperty.hasMimeType(PasteData.MIMETYPE_TEXT_PLAIN);if (hasHtml || hasText) { Text text = (Text) findComponentById(ResourceTable.Id_text); for (int i = 0; i 应用C注册添加系统剪贴板数据变化回调，当系统剪贴板数据发生变化时触发处理逻辑。 IPasteDataChangedListener listener = new IPasteDataChangedListener() { @Override public void onChanged() { PasteData pasteData = pasteboard.getPasteData(); if (pasteData == null) { return; } // Operations to handle data change on the system pasteboard }};pasteboard.addPasteDataChangedListener(listener); 相关实例 针对剪贴板开发指导，有以下示例工程可供参考： Pasteboard 本示例演示了应用之间的数据剪贴。 "},"thread-mgmt-overview.html":{"url":"thread-mgmt-overview.html","title":"线程管理开发概述","keywords":"","body":"线程管理开发概述 不同应用在各自独立的进程中运行。当应用以任何形式启动时，系统为其创建进程，该进程将持续运行。当进程完成当前任务处于等待状态，且系统资源不足时，系统自动回收。 在启动应用时，系统会为该应用创建一个称为“主线程”的执行线程。该线程随着应用创建或消失，是应用的核心线程。UI界面的显示和更新等操作，都是在主线程上进行。主线程又称UI线程，默认情况下，所有的操作都是在主线程上执行。如果需要执行比较耗时的任务（如下载文件、查询数据库），可创建其他线程来处理。 "},"thread-mgmt-guidelines.html":{"url":"thread-mgmt-guidelines.html","title":"线程管理开发指导","keywords":"","body":"线程管理开发指导 "},"inter-thread-overview.html":{"url":"inter-thread-overview.html","title":"线程间通信开发概述","keywords":"","body":"线程间通信开发概述 "},"inter-thread-guidelines.html":{"url":"inter-thread-guidelines.html","title":"线程间通信开发指导","keywords":"","body":"线程间通信开发指导 场景介绍 如果应用的业务逻辑比较复杂，可能需要创建多个线程来执行多个任务。这种情况下，代码复杂难以维护，任务与线程的交互也会更加繁杂。要解决此问题，开发者可以使用“TaskDispatcher”来分发不同的任务。 接口说明 TaskDispatcher是一个任务分发器，它是Ability分发任务的基本接口，隐藏任务所在线程的实现细节。 为保证应用有更好的响应性，我们需要设计任务的优先级。在UI线程上运行的任务默认以高优先级运行，如果某个任务无需等待结果，则可以用低优先级。 优先级 详细描述 HIGH 最高任务优先级，比默认优先级、低优先级的任务有更高的几率得到执行。 DEFAULT 默认任务优先级， 比低优先级的任务有更高的几率得到执行。 LOW 低任务优先级，比高优先级、默认优先级的任务有更低的几率得到执行。 TaskDispatcher具有多种实现，每种实现对应不同的任务分发器。在分发任务时可以指定任务的优先级，由同一个任务分发器分发出的任务具有相同的优先级。系统提供的任务分发器有GlobalTaskDispatcher、ParallelTaskDispatcher、SerialTaskDispatcher 、SpecTaskDispatcher。 GlobalTaskDispatcher 全局并发任务分发器，由Ability执行getGlobalTaskDispatcher()获取。适用于任务之间没有联系的情况。一个应用只有一个GlobalTaskDispatcher，它在程序结束时才被销毁。 TaskDispatcher globalTaskDispatcher = getGlobalTaskDispatcher(TaskPriority.DEFAULT); ParallelTaskDispatcher 并发任务分发器，由Ability执行createParallelTaskDispatcher()创建并返回。与GlobalTaskDispatcher不同的是，ParallelTaskDispatcher不具有全局唯一性，可以创建多个。开发者在创建或销毁dispatcher时，需要持有对应的对象引用 。 String dispatcherName = \"parallelTaskDispatcher\";TaskDispatcher parallelTaskDispatcher = createParallelTaskDispatcher(dispatcherName, TaskPriority.DEFAULT); SerialTaskDispatcher 串行任务分发器，由Ability执行createSerialTaskDispatcher()创建并返回。由该分发器分发的所有的任务都是按顺序执行，但是执行这些任务的线程并不是固定的。如果要执行并行任务，应使用ParallelTaskDispatcher或者GlobalTaskDispatcher，而不是创建多个SerialTaskDispatcher。如果任务之间没有依赖，应使用GlobalTaskDispatcher来实现。它的创建和销毁由开发者自己管理，开发者在使用期间需要持有该对象引用。 String dispatcherName = \"serialTaskDispatcher\";TaskDispatcher serialTaskDispatcher = createSerialTaskDispatcher(dispatcherName, TaskPriority.DEFAULT); SpecTaskDispatcher 专有任务分发器，绑定到专有线程上的任务分发器。目前已有的专有线程为UI线程，通过UITaskDispatcher进行任务分发。 UITaskDispatcher：绑定到应用主线程的专有任务分发器， 由Ability执行getUITaskDispatcher()创建并返回。 由该分发器分发的所有的任务都是在主线程上按顺序执行，它在应用程序结束时被销毁。 TaskDispatcher uiTaskDispatcher = getUITaskDispatcher(); 开发步骤 syncDispatch 同步派发任务：派发任务并在当前线程等待任务执行完成。在返回前，当前线程会被阻塞。 如下代码示例展示了如何使用GlobalTaskDispatcher派发同步任务： TaskDispatcher globalTaskDispatcher = getGlobalTaskDispatcher(TaskPriority.DEFAULT);globalTaskDispatcher.syncDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"sync task1 run\"); }});HiLog.info(LABEL_LOG, \"after sync task1\"); globalTaskDispatcher.syncDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"sync task2 run\"); }});HiLog.info(LABEL_LOG, \"after sync task2\"); globalTaskDispatcher.syncDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"sync task3 run\"); }});HiLog.info(LABEL_LOG, \"after sync task3\"); // 执行结果如下：// sync task1 run// after sync task1// sync task2 run// after sync task2// sync task3 run// after sync task3 说明 如果对syncDispatch使用不当, 将会导致死锁。如下情形可能导致死锁发生： 在专有线程上，利用该专有任务分发器进行syncDispatch。 在被某个串行任务分发器（dispatcher_a）派发的任务中，再次利用同一个串行任务分发器（dispatcher_a）对象派发任务。 在被某个串行任务分发器（dispatcher_a）派发的任务中，经过数次派发任务，最终又利用该（dispatcher_a）串行任务分发器派发任务。例如：dispatcher_a派发的任务使用dispatcher_b进行任务的派发，在dispatcher_b派发的任务中又利用dispatcher_a进行派发任务。 串行任务分发器（dispatcher_a）派发的任务中利用串行任务分发器（dispatcher_b）进行同步派发任务，同时dispatcher_b派发的任务中利用串行任务分发器（dispatcher_a）进行同步派发任务。在特定的线程执行顺序下将导致死锁。 asyncDispatch 异步派发任务：派发任务，并立即返回，返回值是一个可用于取消任务的接口。 如下代码示例展示了如何使用GlobalTaskDispatcher派发异步任务： TaskDispatcher globalTaskDispatcher = getGlobalTaskDispatcher(TaskPriority.DEFAULT);Revocable revocable = globalTaskDispatcher.asyncDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"async task1 run\"); }});HiLog.info(LABEL_LOG, \"after async task1\"); // 执行结果可能如下：// after async task1// async task1 run delayDispatch 异步延迟派发任务：异步执行，函数立即返回，内部会在延时指定时间后将任务派发到相应队列中。延时时间参数仅代表在这段时间以后任务分发器会将任务加入到队列中，任务的实际执行时间可能晚于这个时间。具体比这个数值晚多久，取决于队列及内部线程池的繁忙情况。 如下代码示例展示了如何使用GlobalTaskDispatcher延迟派发任务： final long callTime = System.currentTimeMillis();final long delayTime = 50L;TaskDispatcher globalTaskDispatcher = getGlobalTaskDispatcher(TaskPriority.DEFAULT); Revocable revocable = globalTaskDispatcher.delayDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"delayDispatch task1 run\"); final long actualDelay = System.currentTimeMillis() - callTime; HiLog.info(LABEL_LOG, \"actualDelayTime >= delayTime: %{public}b\", (actualDelay >= delayTime)); }}, delayTime);HiLog.info(LABEL_LOG, \"after delayDispatch task1\"); // 执行结果可能如下：// after delayDispatch task1// delayDispatch task1 run// actualDelayTime >= delayTime : true Group 任务组：表示一组任务，且该组任务之间有一定的联系，由TaskDispatcher执行createDispatchGroup创建并返回。将任务加入任务组，返回一个用于取消任务的接口。 如下代码示例展示了任务组的使用方式：将一系列相关联的下载任务放入一个任务组，执行完下载任务后关闭应用。 String dispatcherName = \"parallelTaskDispatcher\";TaskDispatcher dispatcher = createParallelTaskDispatcher(dispatcherName, TaskPriority.DEFAULT);// 创建任务组。Group group = dispatcher.createDispatchGroup();// 将任务1加入任务组，返回一个用于取消任务的接口。dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"download task1 is running\"); }});// 将与任务1相关联的任务2加入任务组。dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"download task2 is running\"); }});// 在任务组中的所有任务执行完成后执行指定任务。dispatcher.groupDispatchNotify(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"the close task is running after all tasks in the group are completed\"); }});// 可能的执行结果:// download task1 is running// download task2 is running// the close task is running after all tasks in the group are completed // 另外一种可能的执行结果：// download task2 is running// download task1 is running// the close task is running after all tasks in the group are completed Revocable 取消任务：Revocable是取消一个异步任务的接口。异步任务包括通过 asyncDispatch、delayDispatch、asyncGroupDispatch 派发的任务。如果任务已经在执行中或执行完成，则会返回取消失败。 如下代码示例展示了如何取消一个异步延时任务： TaskDispatcher dispatcher = getUITaskDispatcher();Revocable revocable = dispatcher.delayDispatch(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"delay dispatch\"); }}, 10);boolean revoked = revocable.revoke();HiLog.info(LABEL_LOG, \"%{public}b\", revoked);// 一种可能的结果如下 :// true syncDispatchBarrier 同步设置屏障任务：在任务组上设立任务执行屏障，同步等待任务组中的所有任务执行完成，再执行指定任务。 说明 在全局并发任务分发器（GlobalTaskDispatcher）上同步设置任务屏障，将不会起到屏障作用。 如下代码示例展示了如何同步设置屏障： String dispatcherName = \"parallelTaskDispatcher\";TaskDispatcher dispatcher = createParallelTaskDispatcher(dispatcherName, TaskPriority.DEFAULT);// 创建任务组。Group group = dispatcher.createDispatchGroup();// 将任务加入任务组，返回一个用于取消任务的接口。dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"task1 is running\"); // 1 }});dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"task2 is running\"); // 2 }}); dispatcher.syncDispatchBarrier(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"barrier\"); // 3 }}); HiLog.info(LABEL_LOG, \"after syncDispatchBarrier\"); // 4// 1和2的执行顺序不定；3和4总是在1和2之后按顺序执行。 // 可能的执行结果:// task1 is running// task2 is running// barrier// after syncDispatchBarrier // 另外一种执行结果：// task2 is running// task1 is running// barrier// after syncDispatchBarrier asyncDispatchBarrier 异步设置屏障任务：在任务组上设立任务执行屏障后直接返回，指定任务将在任务组中的所有任务执行完成后再执行。 说明 在全局并发任务分发器（GlobalTaskDispatcher）上异步设置任务屏障，将不会起到屏障作用。可以使用并发任务分发器（ParallelTaskDispatcher）分离不同的任务组，达到微观并行、宏观串行的行为。 如下代码示例展示了如何异步设置屏障： TaskDispatcher dispatcher = createParallelTaskDispatcher(\"dispatcherName\", TaskPriority.DEFAULT);// 创建任务组。Group group = dispatcher.createDispatchGroup();// 将任务加入任务组，返回一个用于取消任务的接口。dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"task1 is running\"); // 1 }});dispatcher.asyncGroupDispatch(group, new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"task2 is running\"); // 2 }}); dispatcher.asyncDispatchBarrier(new Runnable() { @Override public void run() { HiLog.info(LABEL_LOG, \"barrier\"); // 3 }}); HiLog.info(LABEL_LOG, \"after asyncDispatchBarrier\"); // 4// 1和2的执行顺序不定，但总在3之前执行；4不需要等待1、2、3执行完成。 // 可能的执行结果:// task1 is running// task2 is running// after asyncDispatchBarrier// barrier applyDispatch 执行多次任务：对指定任务执行多次。 如下代码示例展示了如何执行多次任务： final int total = 10;final CountDownLatch latch = new CountDownLatch(total);final List indexList = new ArrayList<>(total);TaskDispatcher dispatcher = getGlobalTaskDispatcher(TaskPriority.DEFAULT); // 执行任务 total 次。dispatcher.applyDispatch((index) -> { indexList.add(index); latch.countDown();}, total);// 设置任务超时。try { latch.await();} catch (InterruptedException exception) { HiLog.error(LABEL_LOG, \"latch exception\");}HiLog.info(LABEL_LOG, \"list size matches, %{public}b\", (total == indexList.size()));// 执行结果：// list size matches, true 相关实例 针对线程管理，有以下示例工程可供参考： TaskDispatcher 如果应用的业务逻辑比较复杂，可能需要创建多个线程来执行多个任务。本示例演示了如何使用“TaskDispatcher”来分发不同的任务，例如：同步派发、异步派发、异步延迟派发等。 "},"java-overview.html":{"url":"java-overview.html","title":"Java UI框架概述","keywords":"","body":"Java UI框架概述 应用的Ability在屏幕上将显示一个用户界面，该界面用来显示所有可被用户查看和交互的内容。 应用中所有的用户界面元素都是由Component和ComponentContainer对象构成。Component是绘制在屏幕上的一个对象，用户能与之交互。ComponentContainer是一个用于容纳其他Component和ComponentContainer对象的容器。 Java UI框架提供了一部分Component和ComponentContainer的具体子类，即创建用户界面（UI）的各类组件，包括一些常用的组件（比如：文本、按钮、图片、列表等）和常用的布局（比如：DirectionalLayout和DependentLayout）。用户可通过组件进行交互操作，并获得响应。 所有的UI操作都应该在主线程进行设置。 组件和布局 用户界面元素统称为组件，组件根据一定的层级结构进行组合形成布局。组件在未被添加到布局中时，既无法显示也无法交互，因此一个用户界面至少包含一个布局。在UI框架中，具体的布局类通常以XXLayout命名，完整的用户界面是一个布局，用户界面中的一部分也可以是一个布局。布局中容纳Component与ComponentContainer对象。 Component和ComponentContainer Component：提供内容显示，是界面中所有组件的基类，开发者可以给Component设置事件处理回调来创建一个可交互的组件。Java UI框架提供了一些常用的界面元素，也可称之为组件，组件一般直接继承Component或它的子类，如Text、Image等。 ComponentContainer：作为容器容纳Component或ComponentContainer对象，并对它们进行布局。Java UI框架提供了一些标准布局功能的容器，它们继承自ComponentContainer，一般以“Layout”结尾，如DirectionalLayout、DependentLayout等。 图1 Component结构 LayoutConfig 每种布局都根据自身特点提供LayoutConfig供子Component设定布局属性和参数，通过指定布局属性可以对子Component在布局中的显示效果进行约束。例如：“width”、“height”是最基本的布局属性，它们指定了组件的大小。 图2 LayoutConfig 组件树 布局把Component和ComponentContainer以树状的层级结构进行组织，这样的一个布局就称为组件树。组件树的特点是仅有一个根组件，其他组件有且仅有一个父节点，组件之间的关系受到父节点的规则约束。 "},"java-component-layout-overview.html":{"url":"java-component-layout-overview.html","title":"开发说明","keywords":"","body":"开发说明 HarmonyOS提供了Ability和AbilitySlice两个基础类，一个有界面的Ability可以由一个或多个AbilitySlice构成，AbilitySlice主要用于承载单个页面的具体逻辑实现和界面UI，是应用显示、运行和跳转的最小单元。AbilitySlice通过setUIContent为界面设置布局。 接口声明 接口描述 setUIContent(ComponentContainer root) 设置界面入口，root为界面组件树根节点。 组件需要进行组合，并添加到界面的布局中。在Java UI框架中，提供了两种编写布局的方式： 在代码中创建布局：用代码创建Component和ComponentContainer对象，为这些对象设置合适的布局参数和属性值，并将Component添加到ComponentContainer中，从而创建出完整界面。 在XML中声明UI布局：按层级结构来描述Component和ComponentContainer的关系，给组件节点设定合适的布局参数和属性值，代码中可直接加载生成此布局。 这两种方式创建出的布局没有本质差别，在XML中声明布局，在加载后同样可在代码中对该布局进行修改。 组件分类 根据组件的功能，可以将组件分为布局类、显示类、交互类三类： 组件类别 组件名称 功能描述 布局类 PositionLayout、DirectionalLayout、StackLayout、DependentLayout、TableLayout、AdaptiveBoxLayout 提供了不同布局规范的组件容器，例如以单一方向排列的DirectionalLayout、以相对位置排列的DependentLayout、以确切位置排列的PositionLayout等。 显示类 Text、Image、Clock、TickTimer、ProgressBar 提供了单纯的内容显示，例如用于文本显示的Text，用于图像显示的Image等。 交互类 TextField、Button、Checkbox、RadioButton/RadioContainer、Switch、ToggleButton、Slider、Rating、ScrollView、TabList、ListContainer、PageSlider、PageFlipper、PageSliderIndicator、Picker、TimePicker、DatePicker、SurfaceProvider、ComponentProvider 提供了具体场景下与用户交互响应的功能，例如Button提供了点击响应功能，Slider提供了进度选择功能等。 框架提供的组件使应用界面开发更加便利，这些组件的具体功能说明及属性设置详见API参考。 相关实例 针对常用组件和布局开发，有以下示例工程可供参考： Components 本示例演示了Text和Button两种常用组件的基础使用方法。 CommonLayout 本示例演示了DirectionalLayout和DependentLayout两种常用布局的基础使用方法。 针对Java UI框架的组件与布局开发，有以下Codelabs可供参考： 常用组件和布局 基于HarmonyOS Java UI，实现常见组件或者布局。 分布式新闻客户端 基于HarmonyOS应用中Service Ability和Page Ability的使用，实现跨设备FA拉起。 跨设备视频播放 基于分布式能力和IDL跨进程通信，实现视频跨设备播放、控制。 分布式游戏手柄 基于分布式能力，将手机作为智慧屏的虚拟手柄终端，组成全新的多人娱乐场景。 "},"java-component-layout-code.html":{"url":"java-component-layout-code.html","title":"代码创建布局","keywords":"","body":"代码创建布局 开发如下图所示界面，需要添加一个Text组件和Button组件。由于两个组件从上到下依次居中排列，可以选择使用竖向的DirectionalLayout布局来放置组件。 图1 开发样例图 代码创建布局需要在AbilitySlice中分别创建组件和布局，并将它们进行组织关联。 创建组件 声明组件 Button button = new Button(getContext()); 设置组件大小 button.setWidth(ComponentContainer.LayoutConfig.MATCH_CONTENT);button.setHeight(ComponentContainer.LayoutConfig.MATCH_CONTENT); 设置组件属性 button.setText(\"My name is Button.\");button.setTextSize(50); 创建布局并使用 声明布局 DirectionalLayout directionalLayout = new DirectionalLayout(getContext()); 设置布局大小 directionalLayout.setWidth(ComponentContainer.LayoutConfig.MATCH_PARENT);directionalLayout.setHeight(ComponentContainer.LayoutConfig.MATCH_PARENT); 设置布局属性 directionalLayout.setOrientation(Component.VERTICAL); 将组件添加到布局中（视布局需要对组件设置布局属性进行约束） directionalLayout.addComponent(button); 将布局添加到组件树中 setUIContent(directionalLayout); 示例代码如下： public class ExampleAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 声明布局 DirectionalLayout directionalLayout = new DirectionalLayout(getContext()); // 设置布局大小 directionalLayout.setWidth(ComponentContainer.LayoutConfig.MATCH_PARENT); directionalLayout.setHeight(ComponentContainer.LayoutConfig.MATCH_PARENT); // 设置布局属性 directionalLayout.setOrientation(Component.VERTICAL); directionalLayout.setPadding(32, 32, 32, 32); Text text = new Text(getContext()); text.setText(\"My name is Text.\"); text.setTextSize(50); text.setId(100); // 为组件添加对应布局的布局属性 DirectionalLayout.LayoutConfig layoutConfig = new DirectionalLayout.LayoutConfig(ComponentContainer.LayoutConfig.MATCH_CONTENT, ComponentContainer.LayoutConfig.MATCH_CONTENT); layoutConfig.alignment = LayoutAlignment.HORIZONTAL_CENTER; text.setLayoutConfig(layoutConfig); // 将Text添加到布局中 directionalLayout.addComponent(text); // 类似的添加一个Button Button button = new Button(getContext()); layoutConfig.setMargins(0, 50, 0, 0); button.setLayoutConfig(layoutConfig); button.setText(\"My name is Button.\"); button.setTextSize(50); ShapeElement background = new ShapeElement(); background.setRgbColor(new RgbColor(0, 125, 255)); background.setCornerRadius(25); button.setBackground(background); button.setPadding(10, 10, 10, 10); button.setClickedListener(new Component.ClickedListener() { @Override // 在组件中增加对点击事件的检测 public void onClick(Component component) { // 此处添加按钮被点击需要执行的操作 } }); directionalLayout.addComponent(button); // 将布局作为根布局添加到视图树中 super.setUIContent(directionalLayout); }} 根据以上步骤创建组件和布局后的界面显示效果如图1所示。其中，代码示例中为组件设置了一个按键回调，在按键被按下后，应用会执行自定义的操作。 在代码示例中，可以看到设置组件大小的方法有两种： 通过setWidth/setHeight直接设置宽高。 通过setLayoutConfig方法设置布局属性来设定宽高。 这两种方法的区别是后者还可以增加更多的布局属性设置，例如：使用“alignment”设置水平居中的约束。另外，这两种方法设置的宽高以最后设置的作为最终结果。它们的取值一致，可以是以下取值： 具体以像素为单位的数值。 MATCH_PARENT：表示组件大小将扩展为父组件允许的最大值，它将占据父组件方向上的剩余大小。 MATCH_CONTENT：表示组件大小与它内容占据的大小范围相适应。 "},"java-component-layout-xml.html":{"url":"java-component-layout-xml.html","title":"XML创建布局","keywords":"","body":"XML创建布局 XML声明布局的方式更加简便直观。每一个Component和ComponentContainer对象大部分属性都支持在XML中进行设置，它们都有各自的XML属性列表。某些属性仅适用于特定的组件，例如：只有Text支持“text_color”属性，但不支持该属性的组件如果添加了该属性，该属性则会被忽略。具有继承关系的组件子类将继承父类的属性列表，Component作为组件的基类，拥有各个组件常用的属性，比如：ID、布局参数等。 ID ohos:id=\"$+id:text\" 在XML中使用此格式声明一个对开发者友好的ID，它会在编译过程中转换成一个常量。尤其在DependentLayout布局中，组件之间需要描述相对位置关系，描述时要通过ID来指定对应组件。 布局中的组件通常要设置独立的ID，以便在程序中查找该组件。如果布局中有不同组件设置了相同的ID，在通过ID查找组件时会返回查找到的第一个组件，因此尽量保证在所要查找的布局中为组件设置独立的ID值，避免出现与预期不符合的问题。 布局参数 ohos:width=\"20vp\"ohos:height=\"10vp\" 与代码中设置组件的宽度和高度类似，在XML中它们的取值可以是： 具体的数值：10（以像素为单位）、10vp（以屏幕相对像素为单位）。 match_parent：表示组件大小将扩展为父组件允许的最大值，它将占据父组件方向上的剩余大小。 match_content：表示组件大小与它的内容占据的大小范围相适应。 创建XML布局文件 在DevEco Studio的“Project”窗口，打开“entry > src > main > resources > base”，右键点击“layout”文件夹，选择“New > Layout Resource File”，命名为“first_layout”。 打开新创建的first_layout.xml布局文件，修改其中的内容，对布局和组件的属性和层级进行描述。 加载XML布局 在代码中需要加载XML布局，并添加为根布局或作为其他布局的子Component。 package com.example.myapplication.slice; import com.example.myapplication.ResourceTable;import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.colors.RgbColor;import ohos.agp.components.*;import ohos.agp.components.element.ShapeElement; public class ExampleAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 加载XML布局作为根布局 super.setUIContent(ResourceTable.Layout_first_layout); Button button = (Button) findComponentById(ResourceTable.Id_button); if (button != null) { // 设置组件的属性 ShapeElement background = new ShapeElement(); background.setRgbColor(new RgbColor(0, 125, 255)); background.setCornerRadius(25); button.setBackground(background); button.setClickedListener(new Component.ClickedListener() { @Override // 在组件中增加对点击事件的检测 public void onClick(Component component) { // 此处添加按钮被点击需要执行的操作 } }); } }} "},"java-component-text.html":{"url":"java-component-text.html","title":"Text","keywords":"","body":"Text Text是用来显示字符串的组件，在界面上显示为一块文本区域。Text作为一个基本组件，有很多扩展，常见的有按钮组件Button，文本编辑组件TextField。 支持的XML属性 Text的共有XML属性继承自：Component Text的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 text 显示文本 string类型 可以直接设置文本字串，也可以引用string资源。 ohos:text=\"熄屏时间\"ohos:text=\"$string:test_str\" hint 提示文本 string类型 可以直接设置文本字串，也可以引用string资源。 ohos:hint=\"联系人\"ohos:hint=\"$string:test_str\" text_font 字体 sans-serif 可以设置的字体如表中所列。 ohos:text_font=\"HwChinese-medium\" sans-serif-medium HwChinese-medium sans-serif-condensed sans-serif-condensed-medium monospace truncation_mode 长文本截断方式 none 表示文本超长时无截断。 ohos:truncation_mode=\"none\" ellipsis_at_start 表示文本超长时在文本框起始处使用省略号截断。 ohos:truncation_mode=\"ellipsis_at_start\" ellipsis_at_middle 表示文本超长时在文本框中间位置使用省略号截断。 ohos:truncation_mode=\"ellipsis_at_middle\" ellipsis_at_end 表示文本超长时在文本框结尾处使用省略号截断。 ohos:truncation_mode=\"ellipsis_at_end\" auto_scrolling 表示文本超长时滚动显示全部文本。 ohos:truncation_mode=\"auto_scrolling\" text_size 文本大小 float类型 表示字体大小的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:text_size=\"30\"ohos:text_size=\"16fp\"ohos:text_size=\"$float:size_value\" element_padding 文本与图片的边距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:element_padding=\"20\"ohos:element_padding=\"8vp\"ohos:element_padding=\"$float:size_value\" bubble_width 文本气泡宽度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_width=\"20\"ohos:bubble_width=\"10vp\"ohos:bubble_width=\"$float:size_value\" bubble_height 文本气泡高度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_height=\"20\"ohos:bubble_height=\"10vp\"ohos:bubble_height=\"$float:size_value\" bubble_left_width 文本气泡左宽度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_left_width=\"20\"ohos:bubble_left_width=\"10vp\"ohos:bubble_left_width=\"$float:size_value\" bubble_left_height 文本气泡左高度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_left_height=\"20\"ohos:bubble_left_height=\"10vp\"ohos:bubble_left_height=\"$float:size_value\" bubble_right_width 文本气泡右宽度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_right_width=\"20\"ohos:bubble_right_width=\"10vp\"ohos:bubble_right_width=\"$float:size_value\" bubble_right_height 文本气泡右高度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bubble_right_height=\"20\"ohos:bubble_right_height=\"10vp\"ohos:bubble_right_height=\"$float:size_value\" text_color 文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:text_color=\"#A8FFFFFF\"ohos:text_color=\"$color:black\" hint_color 提示文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:hint_color=\"#A8FFFFFF\"ohos:hint_color=\"$color:black\" selection_color 选中文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:selection_color=\"#A8FFFFFF\"ohos:selection_color=\"$color:black\" text_alignment 文本对齐方式 left 表示文本靠左对齐。 可以设置取值项如表中所列，也可以使用“\\ ”进行多项组合。ohos:text_alignment=\"top\"ohos:text_alignment=\"top\\ left\" top 表示文本靠顶部对齐。 right 表示文本靠右对齐。 bottom 表示文本靠底部对齐。 horizontal_center 表示文本水平居中对齐。 vertical_center 表示文本垂直居中对齐。 center 表示文本居中对齐。 start 表示文本靠起始端对齐。 end 表示文本靠结尾端对齐。 max_text_lines 文本最大行数 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:max_text_lines=\"2\"ohos:max_text_lines=\"$integer:two\" text_input_type 文本输入类型 pattern_null 表示未指定文本输入类型，默认文本输入类型为内容模式。 ohos:text_input_type=\"pattern_null\" pattern_text 表示文本输入类型为普通文本模式。 ohos:text_input_type=\"pattern_text\" pattern_number 表示文本输入类型为数字。 ohos:text_input_type=\"pattern_number\" pattern_password 表示文本输入类型为密码。 ohos:text_input_type=\"pattern_password\" input_enter_key_type 输入键类型 enter_key_type_unspecified 表示指定输入键类型，采用默认类型。 ohos:input_enter_key_type=\"enter_key_type_unspecified\" enter_key_type_search 表示采用执行“搜索”动作的输入键类型。 ohos:input_enter_key_type=\"enter_key_type_search\" enter_key_type_go 表示采用执行“go”动作的输入键类型。 ohos:input_enter_key_type=\"enter_key_type_go\" enter_key_type_send 表示采用执行“发送”动作的输入键类型。 ohos:input_enter_key_type=\"enter_key_type_send\" auto_scrolling_duration 自动滚动时长 integer类型 可以直接设置整型数值，也可以引用integer资源。表示时间的值不可小于0，单位为ms。 ohos:auto_scrolling_duration=\"1000\"ohos:auto_scrolling_duration=\"$integer:during\" multiple_lines 多行模式设置 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:multiple_lines=\"true\"ohos:multiple_lines=\"$boolean:true\" auto_font_size 是否支持文本自动调整文本字体大小 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:auto_font_size=\"true\"ohos:auto_font_size=\"$boolean:true\" scrollable 文本是否可滚动 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:scrollable=\"true\"ohos:scrollable=\"$boolean:true\" text_cursor_visible 文本光标是否可见。只有在可编辑的组件上可配置，否则该值始终为false。 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:text_cursor_visible=\"true\"ohos:text_cursor_visible=\"$boolean:true\" italic 文本是否斜体字体 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:italic=\"true\"ohos:italic=\"$boolean:true\" padding_for_text 设置文本顶部与底部是否默认留白。默认值为true，true表示保留默认留白，false表示顶部与底部不留白 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:padding_for_text=\"true\"ohos:padding_for_text=\"$boolean:true\" additional_line_spacing 需增加的行间距 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:additional_line_spacing=\"2\"ohos:additional_line_spacing=\"$float:line_spacing_add\" line_height_num 行间距倍数 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:line_height_num=\"1.5\"ohos:line_height_num=\"$float:line_spacing_multi\" element_left 文本左侧图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。说明element_left与element_start、element_end属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，element_left会与element_start属性冲突；在“水平布局方向为从右到左”时，element_left会与element_end属性冲突。同时配置时，element_start、element_end优先级高于element_left属性。 ohos:element_left=\"#FFFFFFFF\"ohos:element_left=\"$color:black\"ohos:element_left=\"$media:media_src\"ohos:element_left=\"$graphic:graphic_src\" element_top 文本上方图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:element_top=\"#FFFFFFFF\"ohos:element_top=\"$color:black\"ohos:element_top=\"$media:media_src\"ohos:element_top=\"$graphic:graphic_src\" element_right 文本右侧图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。说明element_right与element_start、element_end属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，element_right会与element_end属性冲突；在“水平布局方向为从右到左”时，element_right会与element_start属性冲突。同时配置时，element_start、element_end优先级高于element_right属性。 ohos:element_right=\"#FFFFFFFF\"ohos:element_right=\"$color:black\"ohos:element_right=\"$media:media_src\"ohos:element_right=\"$graphic:graphic_src\" element_bottom 文本下方图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:element_bottom=\"#FFFFFFFF\"ohos:element_bottom=\"$color:black\"ohos:element_bottom=\"$media:media_src\"ohos:element_bottom=\"$graphic:graphic_src\" element_start 文本开始方向图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。说明element_start与element_left、element_right属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，element_start会与element_left属性冲突；在“水平布局方向为从右到左”时，element_start会与element_right属性冲突。同时配置时，element_start优先级高于element_left、element_right属性。 ohos:element_start=\"#FFFFFFFF\"ohos:element_start=\"$color:black\"ohos:element_start=\"$media:media_src\"ohos:element_start=\"$graphic:graphic_src\" element_end 文本结束方向图标 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。说明element_end与element_left、element_right属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，element_end会与element_right属性冲突；在“水平布局方向为从右到左”时，element_end会与element_left属性冲突。同时配置时，element_end优先级高于element_left、element_right属性。 ohos:element_end=\"#FFFFFFFF\"ohos:element_end=\"$color:black\"ohos:element_end=\"$media:media_src\"ohos:element_end=\"$graphic:graphic_src\" element_cursor_bubble 文本的光标气泡图形只有在可编辑的组件上可配置 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:element_cursor_bubble=\"#FFFFFFFF\"ohos:element_cursor_bubble=\"$color:black\"ohos:element_cursor_bubble=\"$media:media_src\"ohos:element_cursor_bubble=\"$graphic:graphic_src\" element_selection_left_bubble 选中文本的左侧气泡图形 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:element_selection_left_bubble=\"#FFFFFFFF\"ohos:element_selection_left_bubble=\"$color:black\"ohos:element_selection_left_bubble=\"$media:media_src\"ohos:element_selection_left_bubble=\"$graphic:graphic_src\" element_selection_right_bubble 选中文本的右侧气泡图形 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:element_selection_right_bubble=\"#FFFFFFFF\"ohos:element_selection_right_bubble=\"$color:black\"ohos:element_selection_right_bubble=\"$media:media_src\"ohos:element_selection_right_bubble=\"$graphic:graphic_src\" 创建Text 在layout目录下的xml文件中创建Text。 设置Text 在xml中设置Text的背景。 layout目录下xml文件的代码示例如下： 常用的背景如常见的文本背景、按钮背景，可以采用XML格式放置在graphic目录下。 在“Project”窗口，打开“entry > src > main > resources > base”，右键点击“graphic”文件夹，选择“New > File”，命名为“background_text.xml”，在background_text.xml中定义文本的背景。 图1 使用xml设置Text背景的效果 设置字体大小和颜色 图2 设置字体大小和颜色的效果 设置字体风格和字重 图3 设置字体风格和字重的效果 设置文本对齐方式 图4 设置文本对齐方式的效果 设置文本换行和最大显示行数 图5 设置文本换行和最大显示行数的效果 自动调节字体大小 Text对象支持根据文本长度自动调整文本的字体大小和换行。 设置自动换行、最大显示行数和自动调节字体大小。 通过setAutoFontSizeRule设置自动调整规则，三个入参分别是最小的字体大小、最大的字体大小、每次调整文本字体大小的步长。 Text text = (Text) findComponentById(ResourceTable.Id_text);// 设置自动调整规则text.setAutoFontSizeRule(30, 100, 1);// 设置点击一次增多一个\"T\"text.setClickedListener(new Component.ClickedListener() { @Override public void onClick(Component component) { text.setText(text.getText() + \"T\"); }}); 图6 自动调节字体大小 跑马灯效果 当文本过长时，可以设置跑马灯效果，实现文本滚动显示。前提是文本换行关闭且最大显示行数为1，默认情况下即可满足前提要求。 // 跑马灯效果text.setTruncationMode(Text.TruncationMode.AUTO_SCROLLING);// 始终处于自动滚动状态text.setAutoScrollingCount(Text.AUTO_SCROLLING_FOREVER);// 启动跑马灯效果text.startAutoScrolling(); 图7 跑马灯效果 场景示例 利用文本组件实现一个标题栏和详细内容的界面。 图8 界面效果 源码示例： color_light_gray_element.xml： background_text.xml： "},"java-component-button.html":{"url":"java-component-button.html","title":"Button","keywords":"","body":"Button Button是一种常见的组件，点击可以触发对应的操作，通常由文本或图标组成，也可以由图标和文本共同组成。 图1 文本按钮 图2 图标按钮 图3 图标和文本共同组成的按钮 支持的XML属性 Button无自有的XML属性，共有XML属性继承自Text 创建Button 创建如下样式的按钮： 在layout目录下的xml文件中创建Button，并设置按钮的背景形状、颜色。 常用的背景如文本背景、按钮背景，通常采用XML格式放置在graphic目录下。 在“Project”窗口，打开“entry > src > main > resources > base”，右键点击“graphic”文件夹，选择“New > File”，命名为“background_button.xml”，在该文件中定义按钮的背景形状、颜色。 响应点击事件 按钮的重要作用是当用户单击按钮时，会执行相应的操作或者界面出现相应的变化。实际上用户点击按钮时，Button对象将收到一个点击事件。开发者可以自定义响应点击事件的方法。例如，通过创建一个Component.ClickedListener对象，然后通过调用setClickedListener将其分配给按钮。 Button button = (Button) findComponentById(ResourceTable.Id_button);// 为按钮设置点击事件回调button.setClickedListener(new Component.ClickedListener() { @Override public void onClick(Component component) { // 此处添加点击按钮后的事件处理逻辑 }}); 不同类型的按钮 按照按钮的形状，按钮可以分为：普通按钮，椭圆按钮，胶囊按钮，圆形按钮等。 普通按钮 普通按钮和其他按钮的区别在于不需要设置任何形状，只设置文本和背景颜色即可，例如： color_blue_element.xml： 椭圆按钮 椭圆按钮是通过设置background_element的来实现的，background_element的shape设置为椭圆（oval），例如： oval_button_element.xml: 胶囊按钮 胶囊按钮是一种常见的按钮，设置按钮背景时将背景设置为矩形形状，并且设置ShapeElement的radius的半径，例如： capsule_button_element.xml: 圆形按钮 圆形按钮和椭圆按钮的区别在于组件本身的宽度和高度需要相同，例如： circle_button_element.xml: 场景示例 利用圆形按钮，胶囊按钮，文本组件可以绘制出如下拨号盘的UI界面。 图4 界面效果 源码示例： color_light_gray_element.xml： green_text_element.xml： green_circle_button_element.xml： green_capsule_button_element.xml： "},"java-component-textfield.html":{"url":"java-component-textfield.html","title":"TextField","keywords":"","body":"TextField TextField提供了一种文本输入框。 支持的XML属性 TextField的共有XML属性继承自：Text TextField的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 basement 输入框基线 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:basement=\"#000000\"ohos:basement=\"$color:black\"ohos:basement=\"$media:media_src\"ohos:basement=\"$graphic:graphic_src\" 创建TextField 在layout目录下的xml文件中创建一个TextField。 获取输入框的内容： String content = textField.getText(); 设置TextField 在xml中设置TextField的背景。 layout目录下xml文件的代码示例如下： graphic目录下xml文件（例：background_text_field.xml）的代码示例如下： 设置提示文字 图1 创建TextField效果 设置 Bubble 其中ele_cursor_bubble.xml 图2 设置bubble的效果 设置TextField的内边距 设置TextField的多行显示 设置TextField不可用状态 通过TextField的Enable属性来控制文本框是否可用，当设置成false后，文本框不再能被输入。 TextField textField = (TextField) findComponentById(ResourceTable.Id_text_field);textField.setEnabled(false); 响应焦点变化 textField.setFocusChangedListener((component, isFocused) -> { if (isFocused) { // 获取到焦点 ... } else { // 失去焦点 ... }}); 设置基线 图3 设置基线的效果 场景示例 当点击登录按钮，将会出现错误提示，同时将会改变TextField的状态。 图4 演示TextField错误提示效果 ability_text_field.xml代码示例： background_text_field.xml代码示例： background_btn.xml代码示例： Java代码示例： // 当点击登录，改变相应组件的样式Button button = (Button) findComponentById(ResourceTable.Id_ensure_button);button.setClickedListener((component -> { // 显示错误提示的Text Text text = (Text) findComponentById(ResourceTable.Id_error_tip_text); text.setVisibility(Component.VISIBLE); // 显示TextField错误状态下的样式 ShapeElement errorElement = new ShapeElement(this, ResourceTable.Graphic_background_text_field_error); TextField textField = (TextField) findComponentById(ResourceTable.Id_text_field); textField.setBackground(errorElement); // TextField失去焦点 textField.clearFocus();})); 其中background_text_field_error.xml代码示例： "},"java-component-image.html":{"url":"java-component-image.html","title":"Image","keywords":"","body":"Image Image是用来显示图片的组件。 支持的XML属性 Image的共有XML属性继承自：Component Image的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 clip_alignment 图像裁剪对齐方式 left 表示按左对齐裁剪。 ohos:clip_alignment=\"left\" right 表示按右对齐裁剪。 ohos:clip_alignment=\"right\" top 表示按顶部对齐裁剪。 ohos:clip_alignment=\"top\" bottom 表示按底部对齐裁剪。 ohos:clip_alignment=\"bottom\" center 表示按居中对齐裁剪。 ohos:clip_alignment=\"center\" image_src 图像 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:image_src=\"#FFFFFFFF\"ohos:image_src=\"$color:black\"ohos:image_src=\"$media:warning\"ohos:image_src=\"$graphic:graphic_src\" scale_mode 图像缩放类型 zoom_center 表示原图按照比例缩放到与Image最窄边一致，并居中显示。 ohos:scale_mode=\"center\" zoom_start 表示原图按照比例缩放到与Image最窄边一致，并靠起始端显示。 zoom_end 表示原图按照比例缩放到与Image最窄边一致，并靠结束端显示。 stretch 表示将原图缩放到与Image大小一致。 center 表示不缩放，按Image大小显示原图中间部分。 inside 表示将原图按比例缩放到与Image相同或更小的尺寸，并居中显示。 clip_center 表示将原图按比例缩放到与Image相同或更大的尺寸，并居中显示。 创建Image 在“Project”窗口，打开“entry > src > main > resources > base > media”，添加一个图片至media文件夹下，以“plant.JPG”为例。 既可以在XML中创建Image，也可以在代码中创建Image，两种方式如下： 在XML中创建Image 在代码中创建Image Image image = new Image(getContext());image.setPixelMap(ResourceTable.Media_plant); 图1 创建一个Image 使用Image 设置透明度 图2 设置透明度为0.5的效果 设置缩放系数 图3 设置X轴和Y轴缩放为0.5的效果 设置缩放方式 当图片尺寸与Image尺寸不同时，可以根据不同的缩放方式来对图片进行缩放，如设置Image的宽高为200vp。 以按比例缩小居中显示为例，设置ohos:scale_mode=\"zoom_center\"。 图4 设置缩放方式为zoom_center的效果 设置裁剪对齐模式 当Image尺寸小于图片尺寸时，可以对图片进行裁剪，仍以Image的宽高为200vp为例，小于图片尺寸。 以左对齐裁剪为例，设置clip_alignment=\"left\"。 图5 设置左对齐裁剪的效果 "},"java-component-tablist-tab.html":{"url":"java-component-tablist-tab.html","title":"TabList和Tab","keywords":"","body":"TabList和Tab Tablist可以实现多个页签栏的切换，Tab为某个页签。子页签通常放在内容区上方，展示不同的分类。页签名称应该简洁明了，清晰描述分类的内容。 支持的XML属性 Tablist的共有XML属性继承自： ScrollView Tablist的自有XML属性见下表： | 属性名称 | 中文描述 | 取值 | 取值说明 | 使用案例 | | ----------------------------- | ---------------------------------- | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | | fixed_mode | 固定所有页签并同时显示 | boolean类型 | 可以直接设置true/false，也可以引用boolean资源。 | ohos:fixed_mode=\"true\"ohos:fixed_mode=\"$boolean:true_tag\" | | orientation | 页签排列方向 | horizontal | 表示水平排列。 | ohos:orientation=\"horizontal\" | | vertical | 表示垂直排列。 | ohos:orientation=\"vertical\" | | | | normal_text_color | 未选中的文本颜色 | color类型 | 可以直接设置色值，也可以引用color资源。 | ohos:normal_text_color=\"#FFFFFFFF\"ohos:normal_text_color=\"$color:black\" | | selected_text_color | 选中的文本颜色 | color类型 | 可以直接设置色值，也可以引用color资源。 | ohos:normal_text_color=\"#FFFFFFFF\"ohos:normal_text_color=\"$color:black\" | | selected_tab_indicator_color | 选中页签的颜色 | color类型 | 可以直接设置色值，也可以引用color资源。 | ohos:normal_text_color=\"#FFFFFFFF\"ohos:normal_text_color=\"$color:black\" | | selected_tab_indicator_height | 选中页签的高度 | float类型 | 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 | ohos:tab_length=\"100\"ohos:tab_length=\"20vp\"ohos:tab_length=\"$float:size_value\" | | tab_indicator_type | 页签指示类型 | invisible | 表示选中的页签无指示标记。 | ohos:tab_indicator_type=\"invisible\" | | bottom_line | 表示选中的页签通过底部下划线标记。 | ohos:tab_indicator_type=\"bottom_line\" | | | | left_line | 表示选中的页签通过左侧分割线标记。 | ohos:tab_indicator_type=\"left_line\" | | | | oval | 表示选中的页签通过椭圆背景标记。 | ohos:tab_indicator_type=\"oval\" | | | | tab_length | 页签长度 | float类型 | 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 | ohos:tab_length=\"100\"ohos:tab_length=\"20vp\"ohos:tab_length=\"$float:size_value\" | | tab_margin | 页签间距 | float类型 | 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 | ohos:tab_margin=\"100\"ohos:tab_margin=\"20vp\"ohos:tab_margin=\"$float:size_value\" | | text_alignment | 文本对齐方式 | left | 表示文本靠左对齐。 | 可以设置取值项如表中所列，也可以使用“|”进行多项组合。ohos:text_alignment=\"center\"ohos:text_alignment=\"top|left\" | | top | 表示文本靠顶部对齐。 | | | | | right | 表示文本靠右对齐。 | | | | | bottom | 表示文本靠底部对齐。 | | | | | horizontal_center | 表示文本水平居中对齐。 | | | | | vertical_center | 表示文本垂直居中对齐。 | | | | | center | 表示文本居中对齐。 | | | | | start | 表示文本靠起始端对齐。 | | | | | end | 表示文本靠结尾端对齐。 | | | | | text_size | 文本大小 | float类型 | 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 | ohos:text_size=\"100\"ohos:text_size=\"16fp\"ohos:text_size=\"$float:size_value\" | xml中创建TabList 设置默认状态和选中状态的字体颜色和indicator的颜色 TabList中添加Tab TabList tabList = (TabList) findComponentById(ResourceTable.Id_tab_list);TabList.Tab tab = tabList.new Tab(getContext());tab.setText(\"Image\");tabList.addTab(tab); 在代码中设置Tab的布局 tabList.setTabLength(60); // 设置Tab的宽度tabList.setTabMargin(26); // 设置两个Tab之间的间距 图1 效果展示 设置FixedMode 默认为false，该模式下TabList的总宽度是各Tab宽度的总和，若固定了TabList的宽度，当超出可视区域，则可以通过滑动TabList来显示。如果设置为true，TabList的总宽度将与可视区域相同，各个Tab的宽度也会根据TabList的宽度而平均分配，该模式适用于Tab较少的情况。 tabList.setFixedMode(true); 图2 fixedMode设为true的效果 在某个位置新增Tab // 本示例中在\"图片\"和\"视频\"之间的页签中新增\"新闻\"页签TabList.Tab tab = tabList.new Tab(getContext());tab.setText(\"News\");tab.setMinWidth(64);tab.setPadding(12, 0, 12, 0);tabList.addTab(tab, 1); // 1表示位置 图3 在某一位置新增tab的效果 响应焦点变化 tabList.addTabSelectedListener(new TabList.TabSelectedListener() { @Override public void onSelected(TabList.Tab tab) { // 当某个Tab从未选中状态变为选中状态时的回调 ... } @Override public void onUnselected(TabList.Tab tab) { // 当某个Tab从选中状态变为未选中状态时的回调 ... } @Override public void onReselected(TabList.Tab tab) { // 当某个Tab已处于选中状态，再次被点击时的状态回调 ... }}); 方法 说明 getSelectedTab 返回选中的Tab getSelectedTabIndex 返回选中的Tab的位置索引 getTabCount 获取Tab的个数 getTabAt 获取某个Tab removeTab 移除某个位置的tab setOrientation 设置横或竖方向 Tab的使用 设置Tab属性 tab.setMinWidth(64);tab.setPadding(12, 0, 12, 0); 选中某个Tab tab.select(); 获取Tab在TabList中的位置索引 tab.getPosition(); "},"java-component-picker.html":{"url":"java-component-picker.html","title":"Picker","keywords":"","body":"Picker Picker提供了滑动选择器，允许用户从预定义范围中进行选择。 支持的XML属性 Picker的共有XML属性继承自：DirectionalLayout Picker的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 element_padding 文本和Element之间的间距Element必须通过setElementFormatter接口配置 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:element_padding=\"30\"ohos:element_padding=\"16vp\"ohos:element_padding=\"$float:padding\" max_value 最大值 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:max_value=\"10\"ohos:max_value=\"$integer:value\" min_value 最小值 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:min_value=\"1\"ohos:min_value=\"$integer:value\" value 当前值 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:value=\"5\"ohos:value=\"$integer:value\" normal_text_color 未选中的文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:normal_text_color=\"#A8FFFFFF\"ohos:normal_text_color=\"$color:black\" normal_text_size 取消选中的文本大小 float类型 表示字体大小的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:normal_text_size=\"30\"ohos:normal_text_size=\"16fp\"ohos:normal_text_size=\"$float:size_value\" selected_text_color 选中的文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:selected_text_color=\"#A8FFFFFF\"ohos:selected_text_color=\"$color:black\" selected_text_size 选中的文本大小 float类型 表示字体大小的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:selected_text_size=\"30\"ohos:selected_text_size=\"16fp\"ohos:selected_text_size=\"$float:size_value\" selector_item_num 显示的项目数量 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:selector_item_num=\"10\"ohos:selector_item_num=\"$integer:num\" selected_normal_text_margin_ratio 已选文本边距与正常文本边距的比例 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。取值范围为>0。 ohos:selected_normal_text_margin_ratio=\"0.5\"ohos:selected_normal_text_margin_ratio=\"$float:ratio\" shader_color 着色器颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:shader_color=\"#A8FFFFFF\"ohos:shader_color=\"$color:black\" top_line_element 选中项的顶行 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:top_line_element=\"#FFFFFFFF\"ohos:top_line_element=\"$color:black\"ohos:top_line_element=\"$media:media_src\"ohos:top_line_element=\"$graphic:graphic_src\" bottom_line_element 选中项的底线 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:bottom_line_element=\"#FFFFFFFF\"ohos:bottom_line_element=\"$color:black\"ohos:bottom_line_element=\"$media:media_src\"ohos:bottom_line_element=\"$graphic:graphic_src\" wheel_mode_enabled 选择轮是否绕行 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:wheel_mode_enabled=\"true\"ohos:wheel_mode_enabled=\"$boolean:true\" 使用Picker 在XML中创建Picker 设置Picker的取值范围 Picker picker = (Picker) findComponentById(ResourceTable.Id_test_picker);picker.setMinValue(0); // 设置选择器中的最小值picker.setMaxValue(6); // 设置选择器中的最大值 图1 创建的选择器 响应选择器变化 picker.setValueChangedListener((picker1, oldVal, newVal) -> { // oldVal:上一次选择的值； newVal：最新选择的值}); 格式化Picker的显示 通过Picker的setFormatter(Formatter formatter)方法，用户可以将Picker选项中显示的字符串修改为特定的格式。 picker.setFormatter(i -> { String value; switch (i) { case 0: value = \"Mon\"; break; case 1: value = \"Tue\"; break; case 2: value = \"Wed\"; break; case 3: value = \"Thu\"; break; case 4: value = \"Fri\"; break; case 5: value = \"Sat\"; break; case 6: value = \"Sun\"; break; default: value = \"\" + i; } return value;}); 图2 修改格式后的选择器 设置要显示的字符串数组 对于不直接显示数字的组件，该方法可以设置字符串与数字一一对应。字符串数组长度必须等于取值范围内的值总数。用户在使用时需要注意，该方法会覆盖picker.setFormatter(Formatter formatter)方法。 Java代码中 picker.setDisplayedData(new String[]{\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"}); 样式设置 文本相关属性 在XML文件中设置文本样式： 在Java代码中设置文本样式： picker.setNormalTextFont(Font.DEFAULT_BOLD);picker.setNormalTextSize(40);picker.setNormalTextColor(new Color(Color.getIntColor(\"#FFA500\")));picker.setSelectedTextFont(Font.DEFAULT_BOLD);picker.setSelectedTextSize(40);picker.setSelectedTextColor(new Color(Color.getIntColor(\"#00FFFF\"))); 图3 设置后的样式 设置所选文本的上下边框 在XML中设置： 在Java代码中设置 ShapeElement shape = new ShapeElement();shape.setShape(ShapeElement.RECTANGLE);shape.setRgbColor(RgbColor.fromArgbInt(0xFF40E0D0));// 单独设置上边框// picker.setDisplayedLinesTopElement(shape); // 单独设置下边框// picker.setDisplayedLinesBottomElement(shape);// 同时设置上下边框picker.setDisplayedLinesElements(shape, shape); 图4 设置后的上下边框样式 设置Picker的着色器颜色 在XML文件中设置： 在Java代码中设置： picker.setShaderColor(new Color(Color.getIntColor(\"#1E90FF\"))); 图5 设置着色器颜色后的样式 设置Picker中所选文本边距与普通文本边距的比例 在XML文件中设置： 在Java代码中设置： picker.setSelectedNormalTextMarginRatio(5.0f); 图6 设置边距后的效果 设置选择轮模式 该模式是来决定Picker是否是循环显示数据的。 在XML文件中设置： 在Java代码中设置： picker.setWheelModeEnabled(true); 图7 更改选择轮模式后的显示效果 "},"java-component-datepicker.html":{"url":"java-component-datepicker.html","title":"DatePicker","keywords":"","body":"DatePicker DatePicker主要供用户选择日期。 支持的XML属性 DatePicker的共有XML属性继承自：StackLayout DatePicker的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 date_order 显示格式，年月日 0 表示日期以日-月-年的格式显示。 ohos:date_order=\"0\" 1 表示日期以月-日-年的格式显示。 2 表示日期以年-月-日的格式显示。 3 表示日期以年-日-月的格式显示。 4 表示日期以日-月的格式显示。 5 表示日期以月-日的格式显示。 6 表示日期以年-月的格式显示。 7 表示日期以月-年的格式显示。 8 表示只显示年份。 9 表示只显示月份。 10 表示只显示日期。 day_fixed 日期是否固定 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:day_fixed=\"true\"ohos:day_fixed=\"$boolean:true\" month_fixed 月份是否固定 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:month_fixed=\"true\"ohos:month_fixed=\"$boolean:true\" year_fixed 年份是否固定 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:year_fixed=\"true\"ohos:year_fixed=\"$boolean:true\" max_date 最大日期 long类型 可以直接设置长整型值，也可以引用string资源。 ohos:time=\"1234567\"ohos:time=\"$string:date\" min_date 最小日期 long类型 可以直接设置长整型值，也可以引用string资源。 ohos:time=\"1234567\"ohos:time=\"$string:date\" text_size 文本大小 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:text_size=\"30\"ohos:text_size=\"16fp\"ohos:text_size=\"$float:size_value\" normal_text_size 取消选中文本的大小 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:normal_text_size=\"30\"ohos:normal_text_size=\"16fp\"ohos:normal_text_size=\"$float:size_value\" selected_text_size 选中文本的大小 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:selected_text_size=\"30\"ohos:selected_text_size=\"16fp\"ohos:selected_text_size=\"$float:size_value\" normal_text_color 取消选中文本的颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:normal_text_color=\"#A8FFFFFF\"ohos:normal_text_color=\"$color:black\" selected_text_color 选中文本的颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:selected_text_color=\"#A8FFFFFF\"ohos:selected_text_color=\"$color:black\" operated_text_color 操作项的文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:operated_text_color=\"#A8FFFFFF\"ohos:operated_text_color=\"$color:black\" selected_normal_text_margin_ratio 已选文本边距与正常文本边距的比例 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。取值需>0.0f，默认值为1.0f。 ohos:selected_normal_text_margin_ratio=\"0.5\"ohos:selected_normal_text_margin_ratio=\"$float:ratio\" selector_item_num 显示的项数 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:selector_item_num=\"10\"ohos:selector_item_num=\"$integer:num\" shader_color 着色器颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:shader_color=\"#A8FFFFFF\"ohos:shader_color=\"$color:black\" top_line_element 选中项的顶行 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:top_line_element=\"#FFFFFFFF\"ohos:top_line_element=\"$color:black\"ohos:top_line_element=\"$media:media_src\"ohos:top_line_element=\"$graphic:graphic_src\" bottom_line_element 选中项的底线 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:bottom_line_element=\"#FFFFFFFF\"ohos:bottom_line_element=\"$color:black\"ohos:bottom_line_element=\"$media:media_src\"ohos:bottom_line_element=\"$graphic:graphic_src\" wheel_mode_enabled 选择轮是否绕行 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:wheel_mode_enabled=\"true\"ohos:wheel_mode_enabled=\"$boolean:true\" 使用DatePicker 在XML中创建DatePicker 图1 创建默认的DatePicker 获取当前选择日期，日/月/年，DatePicker默认选择当前日期。 // 获取DatePicker实例DatePicker datePicker = (DatePicker) findComponentById(ResourceTable.Id_date_pick);int day = datePicker.getDayOfMonth();int month = datePicker.getMonth();int year = datePicker.getYear(); 响应日期改变事件： 在XML中添加Text显示选择日期： 在Java代码中响应日期改变事件： Text selectedDate = (Text) findComponentById(ResourceTable.Id_text_date);datePicker.setValueChangedListener( new DatePicker.ValueChangedListener() { @Override public void onValueChanged(DatePicker datePicker, int year, int monthOfYear, int dayOfMonth) { selectedDate.setText(String.format(\"%02d/%02d/%4d\", dayOfMonth, monthOfYear, year)); } }); 图2 日期改变响应效果 设置当前日期 datePicker.updateDate(2021, 8, 8); 设置日期的范围 如需对DatePicker的日期选择范围有要求，可以设置属性min_date和max_date。设置的值为日期对应的Unix时间戳。 设置最小日期 在xml设置： 在代码中设置： datePicker.setMinDate(1627747200); 图3 设置最小日期为2021/08/01 设置最大日期 在XML中设置： 在代码中设置： datePicker.setMaxDate(1630339200); 图4 设置最大日期为2021/08/31 固定年/月/日 在XML中设置： 在代码中设置： datePicker.setYearFixed(true); 样式设置 文本相关属性 设置待选项的字体大小和颜色 图5 设置待选项的字体大小和颜色效果 设置已选项的字体大小和颜色 在XML中设置： 在代码中设置： datePicker.setSelectedTextSize(40);datePicker.setSelectedTextColor(new Color(Color.getIntColor(\"#FFA500\"))); 图6 设置已选项的字体大小和颜色效果 设置操作项的字体颜色 在XML中设置： 在代码中设置： datePicker.setOperatedTextColor(new Color(Color.getIntColor(\"#00FFFF\"))); 图7 设置操作项的字体颜色效果 设置DatePicker中所选文本边距与普通文本边距的比例 在XML中设置： 在代码中设置： datePicker.setSelectedNormalTextMarginRatio(10.0f) 图8 已选文本边距与正常文本边距比例设置为10 设置滚轮绕行 在XML中设置： 在代码中设置： datePicker.setWheelModeEnabled(true); 图9 滚轮绕行效果 设置选中日期的上下边框 在XML中设置： 在代码中设置： ShapeElement shape = new ShapeElement();shape.setShape(ShapeElement.RECTANGLE);shape.setRgbColor(RgbColor.fromArgbInt(0xFF9370DB));datePicker.setDisplayedLinesElements(shape,shape); 图10 添加选中项上下边框效果 设置着色器颜色 在XML中设置： 在代码中设置： datePicker.setShaderColor(new Color(Color.getIntColor(\"#00CED1\"))); 图11 设置着色器颜色效果 "},"java-component-timepicker.html":{"url":"java-component-timepicker.html","title":"TimePicker","keywords":"","body":"TimePicker TimePicker主要供用户选择时间。 支持的XML属性 TimePicker的共有XML属性继承自：StackLayout TimePicker的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 am_pm_order 上午下午排列顺序 0 表示am/pm列靠时间选择器起始端显示。 ohos:am_pm_order=\"0\" 1 表示am/pm列靠时间选择器结束端显示。 ohos:am_pm_order=\"1\" 2 表示am/pm列靠时间选择器左侧显示。 ohos:am_pm_order=\"2\" 3 表示am/pm列靠时间选择器右侧显示。 ohos:am_pm_order=\"3\" mode_24_hour 是否24小时制显示 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:mode_24_hour=\"true\"ohos:mode_24_hour=\"$boolean:true\" hour 显示小时 integer类型 可以直接设置整型数值，也可以引用integer资源。小时取值范围必须在0~23。 ohos:hour=\"23\"ohos:hour=\"$integer:hour\" minute 显示分钟 integer类型 可以直接设置整型数值，也可以引用integer资源。分钟取值范围必须在0~59。 ohos:minute=\"59\"ohos:minute=\"$integer:minute\" second 显示秒 integer类型 可以直接设置整型数值，也可以引用integer资源。秒钟取值范围必须在0~59。 ohos:second=\"59\"ohos:second=\"$integer:second\" normal_text_color 取消选中文本的颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:normal_text_color=\"#FFFFFFFF\"ohos:normal_text_color=\"$color:black\" selected_text_color 选中文本的颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:selected_text_color=\"#FF45A5FF\"ohos:selected_text_color=\"$color:black\" operated_text_color 操作项的文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:operated_text_color=\"#A8FFFFFF\"ohos:operated_text_color=\"$color:black\" normal_text_size 取消选中文本的大小 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:normal_text_size=\"30\"ohos:normal_text_size=\"16fp\"ohos:normal_text_size=\"$float:size_value\" selected_text_size 选中文本的大小 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:selected_text_size=\"30\"ohos:selected_text_size=\"16fp\"ohos:selected_text_size=\"$float:size_value\" selected_normal_text_margin_ratio 已选文本边距与正常文本边距的比例 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。取值需>0.0f，默认值为1.0f。 ohos:selected_normal_text_margin_ratio=\"0.5\"ohos:selected_normal_text_margin_ratio=\"$float:ratio\" selector_item_num 显示的项数 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:selector_item_num=\"3\"ohos:selector_item_num=\"$integer:num\" shader_color 着色器颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:shader_color=\"#A8FFFFFF\"ohos:shader_color=\"$color:black\" text_am 上午文本 string类型 可以直接设置文本字串，也可以引用string资源。 ohos:text_am=\"8:00:00\"ohos:text_am=\"$string:am\" text_pm 下午文本 string类型 可以直接设置文本字串，也可以引用string资源。 ohos:text_pm=\"22:00:00\"ohos:text_pm=\"$string:pm\" top_line_element 选中项的顶行 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:top_line_element=\"#FFFFFFFF\"ohos:top_line_element=\"$color:black\"ohos:top_line_element=\"$media:media_src\"ohos:top_line_element=\"$graphic:graphic_src\" bottom_line_element 选中项的底线 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:bottom_line_element=\"#FFFFFFFF\"ohos:bottom_line_element=\"$color:black\"ohos:bottom_line_element=\"$media:media_src\"ohos:bottom_line_element=\"$graphic:graphic_src\" wheel_mode_enabled 选择轮是否绕行 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:wheel_mode_enabled=\"false\"ohos:wheel_mode_enabled=\"$boolean:false\" 使用TimePicker 创建TimePicker 图1 创建一个默认的TimePicker的效果 获取时间 TimePicker timePicker = (TimePicker) findComponentById(ResourceTable.Id_time_picker);int hour = timePicker.getHour();int minute = timePicker.getMinute();int second = timePicker.getSecond(); 设置时间 timePicker.setHour(19);timePicker.setMinute(18);timePicker.setSecond(12); 响应时间改变事件 timePicker.setTimeChangedListener(new TimePicker.TimeChangedListener() { @Override public void onTimeChanged(TimePicker timePicker, int hour, int minute, int second) { ... }}); 显示样式配置 设置字体属性 设置未选中字体的颜色和大小 图2 设置未选中字体的颜色和大小的效果 设置选中字体的颜色和大小 图3 设置选中字体的颜色和大小效果 设置操作项文本颜色 图4 操作项文本颜色设置效果 设置TimePicker中所选文本边距与普通文本边距的比例 图5 选中与未选中文本间隔效果 设置着色器颜色 图6 配置着色器颜色效果 设置选中时间的上下边框 图7 设置上下区域分割线颜色效果 设置12小时制下显示样式 AM/PM默认置于左侧，如需位于右边： 图8 设置AM/PM位于右边显示的效果 范围选择设置 设置隐藏或显示时分秒 隐藏小时的显示 timePicker.showHour(false); 图9 小时不显示效果 隐藏分钟 timePicker.showMinute(false); 图10 隐藏分钟效果 隐藏秒 timePicker.showSecond(false); 图11 隐藏秒效果 设置TimePicker的selector是否可以滑动 设置小时selector无法滚动选择 timePicker.enableHour(false); 图12 小时selector无法滚动选择效果 设置分钟selector无法滚动 timePicker.enableMinute(false); 图13 分钟selector固定无法选择效果 设置秒selector无法滚动 timePicker.enableSecond(false); 图14 秒selector无法滚动选择效果 "},"java-component-switch.html":{"url":"java-component-switch.html","title":"Switch","keywords":"","body":"Switch Switch是切换单个设置开/关两种状态的组件。 支持的XML属性 Switch的共有XML属性继承自：Text Switch的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 text_state_on 开启时显示的文本 string类型 可以直接设置文本字串，也可以引用string资源。 ohos:text_state_on=\"联系\"ohos:text_state_on=\"$string:test_str\" text_state_off 关闭时显示的文本 string类型 可以直接设置文本字串，也可以引用string资源。 ohos:text_state_off=\"联系\"ohos:text_state_off=\"$string:test_str\" track_element 轨迹样式 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:track_element=\"#FF0000FF\"ohos:track_element=\"$color:black\"ohos:track_element=\"$media:media_src\"ohos:track_element=\"$graphic:graphic_src\" thumb_element thumb样式 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:thumb_element=\"#FF0000FF\"ohos:thumb_element=\"$color:black\"ohos:thumb_element=\"$media:media_src\"ohos:thumb_element=\"$graphic:graphic_src\" marked 当前状态 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:marked=\"true\"ohos:marked=\"$boolean:true\" check_element 状态标志样式 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:check_element=\"#000000\"ohos:check_element=\"$color:black\"ohos:check_element=\"$media:media_src\"ohos:check_element=\"$graphic:graphic_src\" 创建Switch 在layout目录下的xml文件中创建Switch。 图1 Switch效果 设置Switch 设置Switch在开启和关闭时的文本。 在xml中设置： 在Java代码中设置： Switch btnSwitch = (Switch) findComponentById(ResourceTable.Id_btn_switch);btnSwitch.setStateOffText(\"OFF\");btnSwitch.setStateOnText(\"ON\"); 图2 设置开启和关闭文本效果 设置响应Switch状态改变的事件。 btnSwitch.setCheckedStateChangedListener(new AbsButton.CheckedStateChangedListener() { // 回调处理Switch状态改变事件 @Override public void onCheckedChanged(AbsButton button, boolean isChecked) { }}); 设置Switch的滑块和轨迹的样式。 定义Switch在开启和关闭状态下滑块和轨迹的样式。 ShapeElement elementThumbOn = new ShapeElement();elementThumbOn.setShape(ShapeElement.OVAL);elementThumbOn.setRgbColor(RgbColor.fromArgbInt(0xFF1E90FF));elementThumbOn.setCornerRadius(50);// 关闭状态下滑块的样式ShapeElement elementThumbOff = new ShapeElement();elementThumbOff.setShape(ShapeElement.OVAL);elementThumbOff.setRgbColor(RgbColor.fromArgbInt(0xFFFFFFFF));elementThumbOff.setCornerRadius(50);// 开启状态下轨迹样式ShapeElement elementTrackOn = new ShapeElement();elementTrackOn.setShape(ShapeElement.RECTANGLE);elementTrackOn.setRgbColor(RgbColor.fromArgbInt(0xFF87CEFA));elementTrackOn.setCornerRadius(50);// 关闭状态下轨迹样式ShapeElement elementTrackOff = new ShapeElement();elementTrackOff.setShape(ShapeElement.RECTANGLE);elementTrackOff.setRgbColor(RgbColor.fromArgbInt(0xFF808080));elementTrackOff.setCornerRadius(50); 通过以下方法，按状态将样式整合到StateElement中。 private StateElement trackElementInit(ShapeElement on, ShapeElement off){ StateElement trackElement = new StateElement(); trackElement.addState(new int[]{ComponentState.COMPONENT_STATE_CHECKED}, on); trackElement.addState(new int[]{ComponentState.COMPONENT_STATE_EMPTY}, off); return trackElement;}private StateElement thumbElementInit(ShapeElement on, ShapeElement off) { StateElement thumbElement = new StateElement(); thumbElement.addState(new int[]{ComponentState.COMPONENT_STATE_CHECKED}, on); thumbElement.addState(new int[]{ComponentState.COMPONENT_STATE_EMPTY}, off); return thumbElement;} 设置Switch的滑块与轨迹的样式。 Switch btnSwitch = (Switch) findComponentById(ResourceTable.Id_btn_switch);btnSwitch.setTrackElement(trackElementInit(elementTrackOn, elementTrackOff));btnSwitch.setThumbElement(thumbElementInit(elementThumbOn, elementThumbOff)); 图3 设置滑块与轨迹样式效果 "},"java-component-radiobutton.html":{"url":"java-component-radiobutton.html","title":"RadioButton","keywords":"","body":"RadioButton RadioButton用于多选一的操作，需要搭配RadioContainer使用，实现单选效果。 支持的XML属性 RadioButton的共有XML属性继承自：Text RadioButton的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 marked 当前状态 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:marked=\"true\"ohos:marked=\"$boolean:true\" text_color_on 处于选中状态的文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:text_color_on=\"#FFFFFFFF\"ohos:text_color_on=\"$color:black\" text_color_off 处于未选中状态的文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:text_color_off=\"#FFFFFFFF\"ohos:text_color_off=\"$color:black\" check_element 状态标志样式 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:check_element=\"#000000\"ohos:check_element=\"$color:black\"ohos:check_element=\"$media:media_src\"ohos:check_element=\"$graphic:graphic_src\" 创建RadioButton 在layout目录下的xml文件中创建RadioButton。 图1 RadioButton效果 设置RadioButton 设置单选按钮的字体颜色： 在xml中设置：text_color_on为选中状态的字体颜色，text_color_off为未选中状态的字体颜色。 在Java代码中设置： rBtn.setTextColorOn(new Color(Color.getIntColor(\"#0066FF\")));rBtn.setTextColorOff(new Color(Color.getIntColor(\"#505050\"))); 图2 设置单选按钮字体颜色效果 "},"java-component-radiocontainer.html":{"url":"java-component-radiocontainer.html","title":"RadioContainer","keywords":"","body":"RadioContainer RadioContainer是RadioButton的容器，在其包裹下的RadioButton保证只有一个被选项。 支持的XML属性 RadioContainer的共有XML属性继承自：DirectionalLayout 创建RadioContainer 在layout目录下的xml文件创建RadioContainer，并在RadioContainer中创建RadioButton。 ... 图1 RadioContainer效果 设置RadioContainer 设置响应RadioContainer状态改变的事件。 RadioContainer container = (RadioContainer) findComponentById(ResourceTable.Id_radio_container);container.setMarkChangedListener(new RadioContainer.CheckedStateChangedListener() { @Override public void onCheckedChanged(RadioContainer radioContainer, int index) { }}); 根据索引值设置指定RadioButton为选定状态。 container.mark(0); 清除RadioContainer中所有RadioButton的选定状态。 container.cancelMarks(); 设置RadioButton的布局方向：orientation设置为“horizontal”，表示横向布局；orientation设置为“vertical”，表示纵向布局。默认为纵向布局。 在xml中设置： ... 在Java代码中设置： container.setOrientation(Component.HORIZONTAL); 图2 设置布局方向为横向布局效果 场景实例 使用RadioContainer实现单选题的选择效果。 图3 实现单选场景效果 xml代码示例： Java代码示例： 通过以下方法，定义RadioButton的背景。 private StateElement createStateElement() { ShapeElement elementButtonOn = new ShapeElement(); elementButtonOn.setRgbColor(RgbPalette.RED); elementButtonOn.setShape(ShapeElement.OVAL); ShapeElement elementButtonOff = new ShapeElement(); elementButtonOff.setRgbColor(RgbPalette.WHITE); elementButtonOff.setShape(ShapeElement.OVAL); StateElement checkElement = new StateElement(); checkElement.addState(new int[]{ComponentState.COMPONENT_STATE_CHECKED}, elementButtonOn); checkElement.addState(new int[]{ComponentState.COMPONENT_STATE_EMPTY}, elementButtonOff); return checkElement; } 设置RadioButton的背景。 RadioContainer radioContainer = (RadioContainer) findComponentById(ResourceTable.Id_radio_container);int count = radioContainer.getChildCount();for (int i = 0; i 设置响应RadioContainer状态改变的事件，显示单选结果。 Text answer = (Text) findComponentById(ResourceTable.Id_text_checked);radioContainer.setMarkChangedListener((radioContainer1, index) -> { answer.setText(String.format(\"[%c]\",(char)('A'+index)));}); "},"java-component-checkbox.html":{"url":"java-component-checkbox.html","title":"Checkbox","keywords":"","body":"Checkbox Checkbox可以实现选中和取消选中的功能。 支持的XML属性 Checkbox的共有XML属性继承自：Text Checkbox的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 marked 当前状态（选中或取消选中） boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:marked=\"true\"ohos:marked=\"$boolean:true\" text_color_on 处于选中状态的文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:text_color_on=\"#FFFFFFFF\"ohos:text_color_on=\"$color:black\" text_color_off 处于未选中状态的文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:text_color_off=\"#FFFFFFFF\"ohos:text_color_off=\"$color:black\" check_element 状态标志样式 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:check_element=\"#000000\"ohos:check_element=\"$color:black\"ohos:check_element=\"$media:media_src\"ohos:check_element=\"$graphic:graphic_src\" 创建Checkbox 在layout目录下的xml文件中创建一个Checkbox。 图1 Checkbox效果 设置Checkbox 在XML中配置Checkbox的选中和取消选中的状态标志样式。 layout目录下XML文件的示例代码如下： graphic目录下创建checkbox_check_element.xml、background_checkbox_checked.xml和background_checkbox_empty.xml三个文件。 checkbox_check_element.xml示例代码： background_checkbox_checked.xml示例代码： background_checkbox_empty.xml示例代码： 图2 在XML中配置选中和取消选中状态效果 设置Checkbox的文字在选中和取消选中时的颜色。 图3 设置Checkbox文字颜色的效果 设置Checkbox的选中状态。 checkbox.setChecked(true); 设置不同状态之间的切换：如果当前为选中状态，那么将变为未选中；如果当前是未选中状态，将变为选中状态。 checkbox.toggle(); 设置响应Checkbox状态变更的事件。 // state表示是否被选中checkbox.setCheckedStateChangedListener((component, state) -> { // 状态改变的逻辑 ...}); 场景实例 使用Checkbox实现多选题的选择效果。 图4 实现多选场景的效果 XML代码示例： Java代码示例： // 保存最终选中的结果private Set selectedSet = new HashSet<>(); // 初始化Checkboxprivate void initCheckbox() { Checkbox checkbox1 = (Checkbox) findComponentById(ResourceTable.Id_check_box_1); checkbox1.setButtonElement(elementButtonInit()); checkbox1.setCheckedStateChangedListener((component, state) -> { if (state) { selectedSet.add(\"A\"); } else { selectedSet.remove(\"A\"); } showAnswer(); }); Checkbox checkbox2 = (Checkbox) findComponentById(ResourceTable.Id_check_box_2); checkbox2.setButtonElement(elementButtonInit()); checkbox2.setCheckedStateChangedListener((component, state) -> { if (state) { selectedSet.add(\"B\"); } else { selectedSet.remove(\"B\"); } showAnswer(); }); Checkbox checkbox3 = (Checkbox) findComponentById(ResourceTable.Id_check_box_3); checkbox3.setButtonElement(elementButtonInit()); checkbox3.setCheckedStateChangedListener((component, state) -> { if (state) { selectedSet.add(\"C\"); } else { selectedSet.remove(\"C\"); } showAnswer(); }); Checkbox checkbox4 = (Checkbox) findComponentById(ResourceTable.Id_check_box_4); checkbox4.setButtonElement(elementButtonInit()); checkbox4.setCheckedStateChangedListener((component, state) -> { if (state) { selectedSet.add(\"D\"); } else { selectedSet.remove(\"D\"); } showAnswer(); });} // 设置Checkbox背景private StateElement elementButtonInit() { ShapeElement elementButtonOn = new ShapeElement(); elementButtonOn.setRgbColor(RgbPalette.RED); elementButtonOn.setShape(ShapeElement.OVAL); ShapeElement elementButtonOff = new ShapeElement(); elementButtonOff.setRgbColor(RgbPalette.BLACK); elementButtonOff.setShape(ShapeElement.OVAL); StateElement checkElement = new StateElement(); checkElement.addState(new int[]{ComponentState.COMPONENT_STATE_CHECKED}, elementButtonOn); checkElement.addState(new int[]{ComponentState.COMPONENT_STATE_EMPTY}, elementButtonOff); return checkElement;} // 显示结果private void showAnswer() { Text answerText = (Text) findComponentById(ResourceTable.Id_text_answer); String answer = selectedSet.toString(); answerText.setText(answer);} "},"java-component-progressbar.html":{"url":"java-component-progressbar.html","title":"ProgressBar","keywords":"","body":"ProgressBar ProgressBar用于显示内容或操作的进度。 支持的XML属性 ProgressBar的共有XML属性继承自：ScrollView ProgressBar的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 divider_lines_enabled 分割线 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:divider_lines_enabled=\"true\"ohos:divider_lines_enabled=\"$boolean:true\" divider_lines_number 分割线数量 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:divider_lines_number=\"1\"ohos:divider_lines_number=\"$integer:one\" infinite 是否使用不确定模式 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:infinite=\"true\"ohos:infinite=\"$boolean:true\" infinite_element 不确定模式图样配置前提：infinite需设置为true Element类型 仅可引用media/graphic下的图片资源。 ohos:infinite_element=\"$media:media_src\"ohos:infinite_element=\"$graphic:graphic_src\" max 最大值 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:max=\"1\"ohos:max=\"$integer:one\" max_height 最大高度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:max_height=\"100\"ohos:max_height=\"20vp\"ohos:max_height=\"$float:size_value\" max_width 最大宽度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:max_width=\"100\"ohos:max_width=\"20vp\"ohos:max_width=\"$float:size_value\" min 最小值 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:min=\"1\"ohos:min=\"$integer:one\" orientation 排列方向 horizontal 表示ProgressBar水平显示。 ohos:orientation=\"horizontal\" vertical 表示ProgressBar垂直显示。 progress 当前进度 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:progress=\"10\"ohos:progress=\"$integer:ten\" background_instruct_element 背景 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:background_instruct_element=\"#000000\"ohos:background_instruct_element=\"$color:black\"ohos:background_instruct_element=\"$media:media_src\"ohos:background_instruct_element=\"$graphic:graphic_src\" progress_width 进度条宽度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:progress_width=\"100\"ohos:progress_width=\"20vp\"ohos:progress_width=\"$float:size_value\" progress_color 进度条颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:progress_color=\"#FF262626\"ohos:progress_color=\"$color:black\" progress_element 进度条背景 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:progress_element=\"#000000\"ohos:progress_element=\"$color:black\"ohos:progress_element=\"$media:media_src\"ohos:progress_element=\"$graphic:graphic_src\" progress_hint_text 进度提示文本 string类型 可以直接设置文本字串，也可以引用string资源。 ohos:progress_hint_text=\"test\"ohos:progress_hint_text=\"$string:test_str\" progress_hint_text_alignment 进度提示文本对齐方式 left 表示文本靠左对齐。 可以设置取值项如表中所列，也可以使用“\\ ”进行多项组合。ohos:progress_hint_text_alignment=\"top\"ohos:progress_hint_text_alignment=\"top\\ left\" top 表示文本靠顶部对齐。 right 表示文本靠右对齐。 bottom 表示文本靠底部对齐。 horizontal_center 表示文本水平居中对齐。 vertical_center 表示文本垂直居中对齐。 center 表示文本居中对齐。 progress_hint_text_color 进度提示文本颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:progress_hint_text_color=\"#FFFFFFFF\"ohos:progress_hint_text_color=\"$color:black\" vice_progress 当前副进度 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:vice_progress=\"1\"ohos:vice_progress=\"$integer:one\" vice_progress_element 副进度条背景 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:vice_progress_element=\"#000000\"ohos:vice_progress_element=\"$color:black\"ohos:vice_progress_element=\"$media:media_src\"ohos:vice_progress_element=\"$graphic:graphic_src\" step 进度的步长 integer类型 可以直接设置整型数值，也可以引用integer资源。默认值为1。若step设置为10，进度值则为10的倍数。 ohos:step=\"1\"ohos:step=\"$integer:one\" progress_hint_text_size 进度提示文本大小 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:progress_hint_text_size=\"100\"ohos:progress_hint_text_size=\"20fp\"ohos:progress_hint_text_size=\"$float:size_value\" 创建ProgressBar 在layout目录下的xml文件中创建一个ProgressBar。 图1 创建ProgressBar效果 设置ProgressBar 设置ProgressBar方向为垂直。 图2 垂直ProgressBar效果 设置当前进度 在xml中的设置： 或者在Java中设置： progressBar.setProgressValue(60); 设置最大和最小值 在xml中设置： 或者在Java中设置： progressBar.setMaxValue(400);progressBar.setMinValue(0); 图3 设置最大和最小值以及进度的效果 设置ProgressBar进度颜色 图4 设置ProgressBar颜色效果 设置ProgressBar底色颜色 图5 设置底色颜色效果 设置ProgressBar分割线 在xml中配置： 在Java代码中配置： progressBar.enableDividerLines(true);progressBar.setDividerLinesNumber(5); 图6 添加分割线效果 设置ProgressBar分割线颜色 progressBar.setDividerLineColor(Color.MAGENTA); 图7 设置分割线颜色效果 设置ProgressBar提示文字 图8 设置提示文字效果 相关实例 针对ProgressBar组件开发，有以下示例工程可供参考： ProgressBar 本示例演示了ProgressBar的基本使用方法。 "},"java-component-roundprogressbar.html":{"url":"java-component-roundprogressbar.html","title":"RoundProgressBar","keywords":"","body":"RoundProgressBar RoundProgressBar继承自ProgressBar，拥有ProgressBar的属性，在设置同样的属性时用法和ProgressBar一致，用于显示环形进度。 支持的XML属性 RoundProgressBar的共有XML属性继承自：ProgressBar RoundProgressBar的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 start_angle 圆形进度条的起始角度 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:start_angle=\"10\"ohos:start_angle=\"$float:float_num\" max_angle 圆形进度条的最大角度 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:start_angle=\"360.0\"ohos:start_angle=\"$float:float_num\" 创建RoundProgressBar 图1 创建RoundProgressBar效果 设置开始和结束角度 图2 设置角度效果 "},"java-component-toastdialog.html":{"url":"java-component-toastdialog.html","title":"ToastDialog","keywords":"","body":"ToastDialog ToastDialog是在窗口上方弹出的对话框，是通知操作的简单反馈。ToastDialog会在一段时间后消失，在此期间，用户还可以操作当前窗口的其他组件。 创建一个ToastDialog new ToastDialog(getContext()) .setText(\"This is a ToastDialog\") .show(); 图1 ToastDialog效果图 设置位置 new ToastDialog(getContext()) .setText(\"This is a ToastDialog displayed in the middle\") .setAlignment(LayoutAlignment.CENTER) .show(); 图2 设置显示位置的效果 自定义ToastDialog的Component Java代码示例： DirectionalLayout toastLayout = (DirectionalLayout) LayoutScatter.getInstance(this) .parse(ResourceTable.Layout_layout_toast, null, false);new ToastDialog(getContext()) .setContentCustomComponent(toastLayout) .setSize(DirectionalLayout.LayoutConfig.MATCH_CONTENT, DirectionalLayout.LayoutConfig.MATCH_CONTENT) .setAlignment(LayoutAlignment.CENTER) .show(); layout_toast.xml布局： 其中background_toast_element.xml： 图3 自定义Component效果 场景示例 自定义视图：添加多个视图的场景。 图4 自定义多个组件的效果 layout_toast_and_image.xml代码示例： 其中background_toast_element.xml： Java示例代码： DirectionalLayout layout = (DirectionalLayout) LayoutScatter.getInstance(this) .parse(ResourceTable.Layout_layout_toast_and_image, null, false);new ToastDialog(getContext()) .setContentCustomComponent(layout) .setSize(DirectionalLayout.LayoutConfig.MATCH_CONTENT, DirectionalLayout.LayoutConfig.MATCH_CONTENT) .setAlignment(LayoutAlignment.CENTER) .show(); "},"java-component-scrollview.html":{"url":"java-component-scrollview.html","title":"ScrollView","keywords":"","body":"ScrollView ScrollView是一种带滚动功能的组件，它采用滑动的方式在有限的区域内显示更多的内容。 支持的XML属性 ScrollView的共有XML属性继承自：StackLayout ScrollView的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 match_viewport 是否拉伸匹配 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:match_viewport=\"true\"ohos:match_viewport=\"$boolean:true\" rebound_effect 回弹效果 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:rebound_effect=\"true\"ohos:rebound_effect=\"$boolean:true\" 创建ScrollView 在layout目录下的xml文件中创建ScrollView，ScrollView的展示需要布局支持，此处以DirectionalLayout为例。 ... 图1 ScrollView效果 设置ScrollView ScrollView的速度、滚动、回弹等常用接口如下： 方法 作用 doFling(int velocityX, int velocityY)doFlingX(int velocityX)doFlingY(int velocityY) 设置X轴和Y轴滚动的初始速度，单位（px） fluentScrollBy(int dx, int dy)fluentScrollByX(int dx)fluentScrollByY(int dy) 根据像素数平滑滚动到指定位置，单位（px） fluentScrollTo(int x, int y)fluentScrollXTo(int x)fluentScrollYTo(int y) 根据指定坐标平滑滚动到指定位置，单位（px） setReboundEffect(boolean enabled) 设置是否启用回弹效果，默认false setReboundEffectParams(int overscrollPercent, float overscrollRate, int remainVisiblePercent)setReboundEffectParams(ReboundEffectParams reboundEffectParams)setOverscrollPercent(int overscrollPercent)setOverscrollRate(float overscrollRate)setRemainVisiblePercent(int remainVisiblePercent) 配置回弹效果overscrollPercent：过度滚动百分比，默认值40overscrollRate：过度滚动率，默认值0.6remainVisiblePercent：应保持可见内容的最小百分比，默认值20 根据像素数平滑滚动。 btnScroll.setClickedListener(component -> { scrollView.fluentScrollByY(300);}); 图2 根据像素数平滑滚动效果 平滑滚动到指定位置。 scrollView.fluentScrollYTo(500); 图3 平滑滚动到指定位置效果 设置布局方向：ScrollView自身没有设置布局方向的属性，所以需要在其子布局中设置。以横向布局horizontal为例： ... 图4 设置布局方向为横向布局效果 设置回弹效果。 在xml中设置： ... 在Java代码中设置： scrollView.setReboundEffect(true); 图5 开启回弹效果 设置缩放匹配效果。 在xml中设置： ... 在Java代码中设置： scrollView.setMatchViewportEnabled(true); 图6 设置缩放匹配效果 "},"java-component-listcontainer.html":{"url":"java-component-listcontainer.html","title":"ListContainer","keywords":"","body":"ListContainer ListContainer是用来呈现连续、多行数据的组件，包含一系列相同类型的列表项。 支持的XML属性 ListContainer的共有XML属性继承自：Component ListContainer的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 rebound_effect 开启/关闭回弹效果 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:rebound_effect=\"true\"ohos:rebound_effect=\"$boolean:true\" shader_color 着色器颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:shader_color=\"#A8FFFFFF\"ohos:shader_color=\"$color:black\" orientation 列表项排列方向 horizontal 表示水平方向列表。 ohos:orientation=\"horizontal\" vertical 表示垂直方向列表。 ohos:orientation=\"vertical\" ListContainer的使用方法 在layout目录下，AbilitySlice对应的布局文件page_listcontainer.xml文件中创建ListContainer。 在layout目录下新建xml文件（例：item_sample.xml），作为ListContainer的子布局。 创建SampleItem.java，作为ListContainer的数据包装类。 public class SampleItem { private String name; public SampleItem(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; }} ListContainer每一行可以为不同的数据，因此需要适配不同的数据结构，使其都能添加到ListContainer上。 创建SampleItemProvider.java，继承自BaseItemProvider。必须重写的方法如下： | 方法 | 作用 | | ------------------------------------------------------------ | -------------------------------- | | int getCount() | 返回填充的表项个数。 | | Object getItem(int position) | 根据position返回对应的数据。 | | long getItemId(int position) | 返回某一项的id。 | | Component getComponent(int position, Component covertComponent,ComponentContainer componentContainer) | 根据position返回对应的界面组件。 | 代码示例如下： import ohos.aafwk.ability.AbilitySlice;import ohos.agp.components.*;import java.util.List;public class SampleItemProvider extends BaseItemProvider { private List list; private AbilitySlice slice; public SampleItemProvider(List list, AbilitySlice slice) { this.list = list; this.slice = slice; } @Override public int getCount() { return list == null ? 0 : list.size(); } @Override public Object getItem(int position) { if (list != null && position >= 0 && position 在Java代码中添加ListContainer的数据，并适配其数据结构。 @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_page_listcontainer); initListContainer(); } private void initListContainer() { ListContainer listContainer = (ListContainer) findComponentById(ResourceTable.Id_list_container); List list = getData(); SampleItemProvider sampleItemProvider = new SampleItemProvider(list, this); listContainer.setItemProvider(sampleItemProvider); } private ArrayList getData() { ArrayList list = new ArrayList<>(); for (int i = 0; i 图1 ListContainer的界面显示效果 ListContainer的常用接口 设置响应点击事件。 listContainer.setItemClickedListener((container, component, position, id) -> { SampleItem item = (SampleItem) listContainer.getItemProvider().getItem(position); new ToastDialog(this) .setText(\"you clicked:\" + item.getName()) // Toast显示在界面中间 .setAlignment(LayoutAlignment.CENTER) .show();}); 图2 响应点击事件效果 设置响应长按事件。 listContainer.setItemLongClickedListener((container, component, position, id) -> { SampleItem item = (SampleItem) listContainer.getItemProvider().getItem(position); new ToastDialog(this) .setText(\"you long clicked:\" + item.getName()) .setAlignment(LayoutAlignment.CENTER) .show(); return false;}); 图3 响应长按事件效果 ListContainer的样式设置 ListContainer的样式设置相关的接口如下： 属性 Java方法 作用 orientation setOrientation(int orientation) 设置布局方向 - setContentStartOffSet(int startOffset)setContentEndOffSet(int endOffset)setContentOffSet(int startOffset, int endOffset) 设置列表容器的开始和结束偏移量 rebound_effect setReboundEffect(boolean enabled) 设置是否启用回弹效果 - setReboundEffectParams(int overscrollPercent, float overscrollRate, int remainVisiblePercent)setReboundEffectParams(ListContainer.ReboundEffectParams reboundEffectParams) 设置回弹效果参数 shader_color setShaderColor(Color color) 设置着色器颜色 设置ListContainer的布局方向：orientation设置为“horizontal”，表示横向布局；orientation设置为“vertical”，表示纵向布局。默认为纵向布局。 在xml中设置： 在Java代码中设置： listContainer.setOrientation(Component.HORIZONTAL); 图4 设置布局方向为horizontal的效果 设置ListContainer的开始和结束偏移量。 listContainer.setContentOffSet(32, 16); 为了便于观察，分别在子布局和ListContainer布局中添加背景色： 在item_sample.xml的根布局中添加背景色。 ... 在ListContainer布局文件中添加背景色。 图5 设置列表容器的开始偏移量为32，结束偏移量为16效果 设置回弹效果。 在xml中设置： 在Java代码中设置 listContainer.setReboundEffect(true); 图6 回弹效果 在开启回弹效果后，可以调用setReboundEffectParams()方法调整回弹效果。 listContainer.setReboundEffectParams(40, 0.6f, 20); 设置着色器颜色。 在xml中设置： 在Java代码中设置： listContainer.setShaderColor(new Color(Color.getIntColor(\"#90EE90\"))); 图7 设置着色器效果 ListContainer性能优化 在适配ListContainer的数据时，无论是新创建的列表项实例，还是从缓存中获取到的，都需要调用方法findComponentById()获取所有子组件并进行数据填充，大量调用该方法，会损耗ListContainer的性能。比较好的解决方案是在创建列表项实例时进行调用，将获取到的所有子组件绑定到列表项的实例中，当从缓存中获取到列表项实例后，直接使用绑定的的子组件填充新数据。完整示例代码如下： 创建数据包装类 public class SettingItem { private int imageId; private String settingName; private boolean isChecked; public SettingItem(int imageId, String settingName, boolean isChecked) { this.imageId = imageId; this.settingName = settingName; this.isChecked = isChecked; } public int getImageId() { return imageId; } public void setImageId(int imageId) { this.imageId = imageId; } public String getSettingName() { return settingName; } public void setSettingName(String settingName) { this.settingName = settingName; } public boolean isChecked() { return isChecked; } public void setChecked(boolean checked) { isChecked = checked; }} 创建列表项布局layout_item_setting.xml 创建SettingProvider.java public class SettingProvider extends BaseItemProvider{ // ListContainer的数据集合 private List settingList; private AbilitySlice slice; public SettingProvider(List list, AbilitySlice slice) { this.settingList = list; this.slice = slice; } // 用于保存列表项中的子组件信息 public class SettingHolder { Image settingIma; Text settingText; Switch settingSwitch; SettingHolder(Component component) { settingIma = (Image) component.findComponentById(ResourceTable.Id_ima_setting); settingText = (Text) component.findComponentById(ResourceTable.Id_text_setting); settingSwitch = (Switch) component.findComponentById(ResourceTable.Id_switch_setting); settingSwitch.setTrackElement(trackElementInit( new ShapeElement(slice, ResourceTable.Graphic_track_on_element), new ShapeElement(slice, ResourceTable.Graphic_track_off_element))); settingSwitch.setThumbElement(thumbElementInit( new ShapeElement(slice, ResourceTable.Graphic_thumb_on_element), new ShapeElement(slice, ResourceTable.Graphic_thumb_off_element))); } private StateElement trackElementInit(ShapeElement on, ShapeElement off) { StateElement trackElement = new StateElement(); trackElement.addState(new int[]{ComponentState.COMPONENT_STATE_CHECKED}, on); trackElement.addState(new int[]{ComponentState.COMPONENT_STATE_EMPTY}, off); return trackElement; } private StateElement thumbElementInit(ShapeElement on, ShapeElement off) { StateElement thumbElement = new StateElement(); thumbElement.addState(new int[]{ComponentState.COMPONENT_STATE_CHECKED}, on); thumbElement.addState(new int[]{ComponentState.COMPONENT_STATE_EMPTY}, off); return thumbElement; } } @Override public int getCount() { return settingList == null ? 0 : settingList.size(); } @Override public Object getItem(int position) { if (settingList != null && position >= 0 && position 其中使用到的graphic资源文件如下： thumb_off_element.xml： thumb_on_element.xml: track_off_element.xml: track_on_element.xml: 在layout文件夹下，创建ListContainerSlice对应的布局文件layout_listcontainer.xml，并添加ListContainer ListContainer添加数据 public class ListContainerSlice extends AbilitySlice { @Override protected void onStart(Intent intent) { super.onStart(intent); setUIContent(ResourceTable.Layout_layout_listcontainer); ListContainer listContainer = (ListContainer) findComponentById(ResourceTable.Id_list_container); SettingProvider provider = new SettingProvider(getData(), this); listContainer.setItemProvider(provider); } private List getData() { ArrayList data = new ArrayList<>(); for (int i = 0; i 图8 效果如下： 相关实例 针对ListContainer组件开发，有以下示例工程可供参考： List 本示例以长列表联系人为例，演示ListContainer 组件的基本使用方法。 "},"java-component-pageslider.html":{"url":"java-component-pageslider.html","title":"PageSlider","keywords":"","body":"PageSlider PageSlider是用于页面之间切换的组件，它通过响应滑动事件完成页面间的切换。 支持的XML属性 PageSlider无自有的XML属性，共有XML属性继承自：StackLayout PageSlider的使用方法 在layout目录下的xml文件中创建PageSlider。 每个页面可能需要呈现不同的数据，因此需要适配不同的数据结构，创建TestPageProvider.java，需继承PageSliderProvider.java，必须重写以下方法： | 方法名 | 作用 | | ------------------------------------------------------------ | ---------------------- | | getCount() | 获取可用视图的数量。 | | createPageInContainer(ComponentContainer componentContainer, int position) | 在指定位置创建页面。 | | destroyPageFromContainer(ComponentContainer componentContainer, int i, Object o) | 销毁容器中的指定页面。 | | isPageMatchToObject(Component component, Object o) | 视图是否关联指定对象。 | Java代码示例： import ohos.agp.colors.RgbColor;import ohos.agp.components.*;import ohos.agp.components.element.ShapeElement;import ohos.agp.utils.Color;import ohos.agp.utils.TextAlignment;import java.util.List;public class TestPagerProvider extends PageSliderProvider { // 数据源，每个页面对应list中的一项 private List list; public TestPagerProvider(List list) { this.list = list; } @Override public int getCount() { return list.size(); } @Override public Object createPageInContainer(ComponentContainer componentContainer, int i) { final DataItem data = list.get(i); Text label = new Text(null); label.setTextAlignment(TextAlignment.CENTER); label.setLayoutConfig( new StackLayout.LayoutConfig( ComponentContainer.LayoutConfig.MATCH_PARENT, ComponentContainer.LayoutConfig.MATCH_PARENT )); label.setText(data.mText); label.setTextColor(Color.BLACK); label.setTextSize(50); ShapeElement element = new ShapeElement(); element.setRgbColor(RgbColor.fromArgbInt(Color.getIntColor(\"#AFEEEE\"))); label.setBackground(element); componentContainer.addComponent(label); return label; } @Override public void destroyPageFromContainer(ComponentContainer componentContainer, int i, Object o) { componentContainer.removeComponent((Component) o); } @Override public boolean isPageMatchToObject(Component component, Object o) { return true; } //数据实体类 public static class DataItem{ String mText; public DataItem(String txt) { mText = txt; } }} 在Java代码中添加数据，并适配PageSlider的数据结构。 @Override protected void onStart(Intent intent) { ... initPageSlider(); } private void initPageSlider() { PageSlider pageSlider = (PageSlider) findComponentById(ResourceTable.Id_page_slider); pageSlider.setProvider(new TestPagerProvider(getData())); } private ArrayList getData() { ArrayList dataItems = new ArrayList<>(); dataItems.add(new TestPagerProvider.DataItem(\"Page A\")); dataItems.add(new TestPagerProvider.DataItem(\"Page B\")); dataItems.add(new TestPagerProvider.DataItem(\"Page C\")); dataItems.add(new TestPagerProvider.DataItem(\"Page D\")); return dataItems; } 图1 PageSlider的使用效果 常用方法 常用方法表 | 方法名 | 作用 | | ------------------------------------------------------------ | -------------------------------------------- | | setProvider(PageSliderProvider provider) | 设置Provider，用于配置PageSlider的数据结构。 | | addPageChangedListener(PageChangedListener listener) | 响应页面切换事件。 | | removePageChangedListener(PageChangedListener listener) | 移除页面切换的响应。 | | setOrientation(int orientation) | 设置布局方向。 | | setPageCacheSize(int count) | 设置要保留当前页面两侧的页面数。 | | setCurrentPage(int itemPos) | 设置当前展示页面。 | | setCurrentPage(int itemPos, boolean smoothScroll) | 设置当前展示界面，并确定是否需要平滑滚动。 | | setSlidingPossible(boolean enable) | 是否启用页面滑动。 | | setReboundEffect(boolean enabled) | 是否启用回弹效果。 | | setReboundEffectParams(int overscrollPercent, float overscrollRate,int remainVisiblePercent)setReboundEffectParams(ReboundEffectParams reboundEffectParams) | 配置回弹效果参数。 | | setPageSwitchTime(int durationMs) | 设置页面切换时间。 | 响应页面切换事件 pageSlider.addPageChangedListener(new PageSlider.PageChangedListener() { @Override public void onPageSliding(int itemPos, float itemPosOffset, int itemPosPixles) { } @Override public void onPageSlideStateChanged(int state) { } @Override public void onPageChosen(int itemPos) { } }); 设置布局方向，默认为横向布局 在xml中设置： 在代码中设置： pageSlider.setOrientation(Component.VERTICAL); 图2 设置布局方向为纵向布局 设置保留当前页面两侧的页面数 在xml中设置： 在代码中设置： pageSlider.setPageCacheSize(2); 设置当前展示页面 pageSlider.setCurrentPage(2); 平滑滚动到指定页面 pageSlider.setCurrentPage(2,true); 图3 平滑滚动到页面C效果 设置是否启用页面滑动 pageSlider.setSlidingPossible(false); 设置回弹效果 pageSlider.setReboundEffect(true); 图4 回弹效果 设置页面切换时间，单位：ms pageSlider.setPageSwitchTime(2000); "},"java-component-pagesliderindicator.html":{"url":"java-component-pagesliderindicator.html","title":"PageSliderIndicator","keywords":"","body":"PageSliderIndicator PageSliderIndicator，需配合PageSlider使用，指示在PageSlider中展示哪个界面。 PageSliderIndicator的用法 在布局文件中创建PageSliderIndicator。 在Java代码中配置导航点。 PageSliderIndicator indicator = (PageSliderIndicator)findComponentById(ResourceTable.Id_indicator); ShapeElement normalElement = new ShapeElement(); normalElement.setRgbColor(RgbColor.fromArgbInt(0xADD8E6)); normalElement.setAlpha(168); normalElement.setShape(ShapeElement.OVAL); normalElement.setBounds(0, 0, 32, 32); ShapeElement selectedElement = new ShapeElement(); selectedElement.setRgbColor(RgbColor.fromArgbInt(0x00BFFF)); selectedElement.setAlpha(168); selectedElement.setShape(ShapeElement.OVAL); selectedElement.setBounds(0, 0, 48, 48); indicator.setItemElement(normalElement, selectedElement); indicator.setItemOffset(60); indicator.setPageSlider(pageSlider); 图1 搭配PageSlider效果 常用方法 关联PageSlider indicator.setPageSlider(pageSlider); 响应页面更改事件 indicator.addOnSelectionChangedListener(new PageSlider.PageChangedListener() { @Override public void onPageSliding(int i, float v, int i1) { } @Override public void onPageSlideStateChanged(int i) { } @Override public void onPageChosen(int i) { } }); 设置所选指导航点的位置 indicator.setSelected(2); 此方法也会改变关联的PageSlider对象中的页面。 设置导航点的背景 除了上述使用Java创建背景外，也可以使用XML方式创建。 在graphic文件夹下创建selected_page_bg_element.xml。 在graphic文件夹下创建unselected_page_bg_element.xml。 在Java代码中调用，设置导航点背景。 ShapeElement normalElement = new ShapeElement(this, ResourceTable.Graphic_unselected_page_bg_element); ShapeElement selectedElement = new ShapeElement(this, ResourceTable.Graphic_selected_page_bg_element); indicator.setItemElement(normalElement, selectedElement); 图2 导航点背景设置效果 设置导航点之间的偏移量 indicator.setItemOffset(60); "},"java-component-webview.html":{"url":"java-component-webview.html","title":"WebView","keywords":"","body":"WebView WebView提供在应用中集成Web页面的能力。 说明 请使用真机或模拟器运行查看WebView效果，预览器不支持WebView显示。 只有预置WebView能力的真机设备才支持WebView功能。具体请以实际设备支持情况为准。智能穿戴设备不支持WebView。 WebView的使用方法 WebView派生于通用组件Component，可以像普通组件一样进行使用。 方式一： 在layout目录下的xml文件中创建WebView。 在MainAbility.java文件中，使用load方法加载Web页面。 WebView webView = (WebView) findComponentById(ResourceTable.Id_webview);webView.getWebConfig() .setJavaScriptPermit(true); // 如果网页需要使用JavaScript，增加此行；如何使用JavaScript下文有详细介绍final String url = EXAMPLE_URL; // EXAMPLE_URL由开发者自定义webView.load(url); 方式二： 在ComponentContainer中创建WebView。 WebView webView = new WebView(getContext());webView.setWidth(ComponentContainer.LayoutConfig.MATCH_PARENT);webView.setHeight(ComponentContainer.LayoutConfig.MATCH_PARENT);webView.getWebConfig() .setJavaScriptPermit(true); // 如果网页需要使用JavaScript，增加此行；如何使用JavaScript下文有详细介绍addComponent(webView); 加载Web页面。 final String url = EXAMPLE_URL; // EXAMPLE_URL由开发者自定义webView.load(url); 定制网址加载行为 当Web页面进行链接跳转时，WebView默认会打开目标网址，通过以下方式可以定制该行为。 自定义WebAgent对象。 private class ExampleWebAgent extends WebAgent { @Override public boolean isNeedLoadUrl(WebView webView, ResourceRequest request) { Uri uri = request.getRequestUrl(); if (EXAMPLE_URL.equals(uri.getDecodedHost())) { // 由WebView通过默认方式处理 return false; } // 增加开发者自定义逻辑 return super.isNeedLoadUrl(webView, request); }} 设置自定义WebAgent至WebView。 webView.setWebAgent(new ExampleWebAgent()); 浏览网页历史记录 通过getNavigator方法获取Navigator对象。 Navigator navigator = webView.getNavigator(); 使用canGoBack()或canGoForward()检查是否可以向后或向前浏览，使用goBack()或goForward()向后或向前浏览。 if (navigator.canGoBack()) { navigator.goBack();}if (navigator.canGoForward()) { navigator.goForward();} 使用JavaScript 通过以下方式，可以建立应用和页面间的JavaScript调用。 通过WebConfig启用JavaScript。 webView.getWebConfig().setJavaScriptPermit(true); 根据实际需要选择调用方式。 注入回调对象到页面内容，并在页面中调用该对象。 final String jsName = \"JsCallbackToApp\";webview.addJsCallback(jsName, new JsCallback() { @Override public String onCallback(String msg) { // 增加自定义处理 return \"jsResult\"; }}); 在页面内通过JavaScript代码调用注入对象。 function callToApp() { if (window.JsCallbackToApp && window.JsCallbackToApp.call) { var result = JsCallbackToApp.call(\"message from web\"); }} 在应用内调用页面内的JavaScript方法。 webview.executeJs(\"javascript:callFuncInWeb()\", new AsyncCallback() { @Override public void onReceive(String msg) { // 在此确认返回结果 }}); 观测Web状态 通过setWebAgent方法设置自定义WebAgent对象，以观测页面状态变更等事件： webview.setWebAgent(new WebAgent() { @Override public void onLoadingPage(WebView webView, String url, PixelMap favicon) { super.onLoadingPage(webView, url, favicon); // 页面开始加载时自定义处理 } @Override public void onPageLoaded(WebView webView, String url) { super.onPageLoaded(webView, url); // 页面加载结束后自定义处理 } @Override public void onLoadingContent(WebView webView, String url) { super.onLoadingContent(webView, url); // 加载资源时自定义处理 } @Override public void onError(WebView webView, ResourceRequest request, ResourceError error) { super.onError(webView, request, error); // 发生错误时自定义处理 }}); 观测浏览事件 通过setBrowserAgent方法设置自定义BrowserAgent对象，以观测JavaScript事件及通知等： webview.setBrowserAgent(new BrowserAgent(this) { @Override public void onTitleUpdated(WebView webView, String title) { super.onTitleUpdated(webView, title); // 标题变更时自定义处理 } @Override public void onProgressUpdated(WebView webView, int newProgress) { super.onProgressUpdated(webView, newProgress); // 加载进度变更时自定义处理 }}); 加载资源文件或本地文件 出于安全考虑，WebView不支持直接通过File协议加载资源文件或本地文件，如应用需实现相关业务，可参考如下方式实现。 方式一：**通过processResourceRequest方法**访问文件 通过setWebAgent方法设置自定义WebAgent对象，覆写processResourceRequest方法。 webview.setWebAgent(new WebAgent() { @Override public ResourceResponse processResourceRequest(WebView webView, ResourceRequest request) { final String authority = \"example.com\"; final String rawFile = \"/rawfile/\"; final String local = \"/local/\"; Uri requestUri = request.getRequestUrl(); if (authority.equals(requestUri.getDecodedAuthority())) { String path = requestUri.getDecodedPath(); if (TextTool.isNullOrEmpty(path)) { return super.processResourceRequest(webView, request); } if (path.startsWith(rawFile)) { // 根据自定义规则访问资源文件 String rawFilePath = \"entry/resources/rawfile/\" + path.replace(rawFile, \"\"); String mimeType = URLConnection.guessContentTypeFromName(rawFilePath); try { Resource resource = getResourceManager().getRawFileEntry(rawFilePath).openRawFile(); ResourceResponse response = new ResourceResponse(mimeType, resource, null); return response; } catch (IOException e) { HiLog.info(TAG, \"open raw file failed\"); } } if (path.startsWith(local)) { // 根据自定义规则访问本地文件 String localFile = getContext().getFilesDir() + path.replace(local, \"/\"); HiLog.info(TAG, \"open local file \" + localFile); File file = new File(localFile); if (!file.exists()) { HiLog.info(TAG, \"file not exists\"); return super.processResourceRequest(webView, request); } String mimeType = URLConnection.guessContentTypeFromName(localFile); try { InputStream inputStream = new FileInputStream(file); ResourceResponse response = new ResourceResponse(mimeType, inputStream, null); return response; } catch (IOException e) { HiLog.info(TAG, \"open local file failed\"); } } } return super.processResourceRequest(webView, request); }}); 加载资源文件或本地文件。 // 加载资源文件 resources/rawfile/example.htmlwebView.load(\"https://example.com/rawfile/example.html\"); // 加载本地文件 /data/data/com.example.dataability/files/example.htmlwebView.load(\"https://example.com/local/example.html\"); 方式二：**通过Data Ability访问文件** 创建Data Ability。 public class ExampleDataAbility extends Ability { private static final String PLACEHOLDER_RAW_FILE = \"/rawfile/\"; private static final String PLACEHOLDER_LOCAL_FILE = \"/local/\"; private static final String ENTRY_PATH_PREFIX = \"entry/resources\"; @Override public RawFileDescriptor openRawFile(Uri uri, String mode) throws FileNotFoundException { final int splitChar = '/'; if (uri == null) { throw new FileNotFoundException(\"Invalid Uri\"); } // path will be like /com.example.dataability/rawfile/example.html String path = uri.getEncodedPath(); final int splitIndex = path.indexOf(splitChar, 1); if (splitIndex 在config.json中注册Data Ability。 {\"name\": \"com.example.webview.ExampleDataAbility\",\"type\": \"data\",\"uri\": \"dataability://com.example.dataability\",\"metaData\": { \"customizeData\": [ { \"name\": \"com.example.provider\", \"extra\": \"$profile:path\" } ]}} 以及在resources/base/profile目录新增path.xml： 配置支持访问Data Ability资源。 webConfig.setDataAbilityPermit(true); 通过dataability协议加载资源文件或本地文件。 // 加载资源文件 resources/rawfile/example.htmlwebView.load(\"dataability://com.example.dataability/rawfile/example.html\"); // 加载本地文件 /data/data/com.example.dataability/files/example.htmlwebView.load(\"dataability://com.example.dataability/local/example.html\"); 相关实例 针对组件WebView的开发，有以下实例可供参考： WebView组件 使用WebView组件实现应用与Web页面间的通信。 "},"java-component-common-xml.html":{"url":"java-component-common-xml.html","title":"组件通用XML属性","keywords":"","body":"组件通用XML属性 Component是所有组件的基类，Component支持的XML属性，其他组件都支持。 Component支持的XML属性如下表。 属性分类 属性名称 中文描述 取值 取值说明 使用案例 基础属性 id 控件identity，用以识别不同控件对象，每个控件唯一 integer类型 仅可用于配置控件的id。 ohos:id=\"$+id:component_id\" theme 样式 引用 仅可引用pattern资源。 ohos:theme=\"$pattern:button_pattern\" width 宽度，必填项 float类型 可以配置表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:width=\"20\"ohos:width=\"10vp\"ohos:width=\"$float:size_value\" match_parent 表示控件宽度与其父控件去掉内部边距后的宽度相同。 ohos:width=\"match_parent\" match_content 表示控件宽度由其包含的内容决定，包括其内容的宽度以及内部边距的总和。 ohos:width=\"match_content\" height 高度，必填项 float类型 可以配置表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:height=\"20\" ohos:height=\"20vp\" ohos:height=\"$float:size_value\" match_parent 表示控件高度与其父控件去掉内部边距后的高度相同。 ohos:height=\"match_parent\" match_content 表示控件高度由其包含的内容决定，包括其内容的高度以及内部边距的总和。 ohos:height=\"match_content\" min_width 最小宽度 float类型 可以配置表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:min_width=\"20\"ohos:min_width=\"20vp\"ohos:min_width=\"$float:size_value\" min_height 最小高度 float类型 可以配置表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:min_height=\"20\"ohos:min_height=\"20vp\"ohos:min_height=\"$float:size_value\" alpha 透明度 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。取值范围在0~1。 ohos:alpha=\"0.86\"ohos:alpha=\"$float:value\" clickable 是否可点击 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:clickable=\"true\"ohos:clickable=\"$boolean:true\" long_click_enabled 是否支持长点击 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:long_click_enabled=\"true\"ohos:long_click_enabled=\"$boolean:true\" enabled 是否启用 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:enabled=\"true\"ohos:enabled=\"$boolean:true\" visibility 可见性 visible 表示控件可见。 ohos:visibility=\"visible\" invisible 表示控件不可见，但仍然占用布局空间。 ohos:visibility=\"invisible\" hide 表示控件不可见，且不占用布局空间。 ohos:visibility=\"hide\" layout_direction 定义水平布局方向 ltr 表示布局方向为水平方向从左到右。 ohos:layout_direction=\"ltr\" rtl 表示布局方向为水平方向从右到左。 ohos:layout_direction=\"rtl\" inherit 表示继承水平布局方向。 ohos:layout_direction=\"inherit\" locale 表示布局方向跟随系统设置。 ohos:layout_direction=\"locale\" background_element 背景图层 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:background_element=\"#FF000000\"ohos:background_element=\"$color:black\"ohos:background_element=\"$media:media_src\"ohos:background_element=\"$graphic:graphic_src\" foreground_element 前景图层 Element类型 可直接配置色值，也可引用color资源或引用media/graphic下的图片资源。 ohos:foreground_element=\"#FF000000\"ohos:foreground_element=\"$color:black\"ohos:foreground_element=\"$media:media_src\"ohos:foreground_element=\"$graphic:graphic_src\" component_description 描述 string类型 可以直接设置文本字串，也可以引用string资源。 ohos:component_description=\"test\"ohos:component_description=\"$string:test_str\" 间距 padding 内间距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。说明padding与left_padding、right_padding、start_padding、end_padding、top_padding、bottom_padding属性有冲突，不建议一起使用。在同时配置时，left_padding、right_padding、start_padding、end_padding、top_padding、bottom_padding优先级高于padding属性。 ohos:padding=\"20\"ohos:padding=\"20vp\"ohos:padding=\"$float:padding_value\" left_padding 左间距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。说明left_padding与start_padding、end_padding属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，left_padding会与start_padding属性冲突；在“水平布局方向为从右到左”时，left_padding会与end_padding属性冲突。同时配置时，start_padding、end_padding优先级高于left_padding属性。 ohos:left_padding=\"20\"ohos:left_padding=\"20vp\"ohos:left_padding=\"$float:padding_value\" start_padding 前内间距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。说明start_padding与left_padding、right_padding属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，start_padding会与left_padding属性冲突；在“水平布局方向为从右到左”时，start_padding会与right_padding属性冲突。同时配置时，start_padding优先级高于left_padding、right_padding属性。 ohos:start_padding=\"20\"ohos:start_padding=\"20vp\"ohos:start_padding=\"$float:padding_value\" right_padding 右内间距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。说明right_padding与start_padding、end_padding属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，right_padding会与end_padding属性冲突；在“水平布局方向为从右到左”时，right_padding会与start_padding属性冲突。同时配置时，start_padding、end_padding优先级高于right_padding属性。 ohos:right_padding=\"20\"ohos:right_padding=\"20vp\"ohos:right_padding=\"$float:padding_value\" end_padding 后内间距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。说明end_padding与left_padding、right_padding属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，end_padding会与right_padding属性冲突；在“水平布局方向为从右到左”时，end_padding会与left_padding属性冲突。同时配置时，end_padding优先级高于left_padding、right_padding属性。 ohos:end_padding=\"20\"ohos:end_padding=\"20vp\"ohos:end_padding=\"$float:padding_value\" top_padding 上内间距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:top_padding=\"20\"ohos:top_padding=\"20vp\"ohos:top_padding=\"$float:padding_value\" bottom_padding 下内间距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:bottom_padding=\"20\"ohos:bottom_padding=\"20vp\"ohos:bottom_padding=\"$float:padding_value\" margin 外边距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。说明margin与left_margin、right_margin、start_margin、end_margin、top_margin、bottom_margin属性有冲突，不建议一起使用。同时配置时，margin优先级高于left_margin、right_margin、start_margin、end_margin、top_margin、bottom_margin属性。 ohos:margin=\"20\"ohos:margin=\"20vp\"ohos:margin=\"$float:margin_value\" left_margin 左外边距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。与margin同时配置时，margin优先级高于left_margin。说明left_margin与start_margin、end_margin属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，left_margin会与start_margin属性冲突；在“水平布局方向为从右到左”时，left_margin会与end_margin属性冲突。同时配置时，start_margin、end_margin优先级高于left_margin属性。 ohos:left_margin=\"20\"ohos:left_margin=\"20vp\"ohos:left_margin=\"$float:margin_value\" start_margin 前外边距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。与margin同时配置时，margin优先级高于start_margin。说明start_margin与left_margin、right_margin属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，start_margin会与left_margin属性冲突；在“水平布局方向为从右到左”时，start_margin会与right_margin属性冲突。同时配置时，start_margin优先级高于left_margin、right_margin属性。 ohos:start_margin=\"20\"ohos:start_margin=\"20vp\"ohos:start_margin=\"$float:margin_value\" right_margin 右外边距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。与margin同时配置时，margin优先级高于right_margin。说明right_margin与start_margin、end_margin属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，right_margin会与end_margin属性冲突；在“水平布局方向为从右到左”时，right_margin会与start_margin属性冲突。同时配置时，start_margin、end_margin优先级高于right_margin属性。 ohos:right_margin=\"20\"ohos:right_margin=\"20vp\"ohos:right_margin=\"$float:margin_value\" end_margin 后外边距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。与margin同时配置时，margin优先级高于end_margin。说明end_margin与left_margin、right_margin属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，end_margin会与right_margin属性冲突；在“水平布局方向为从右到左”时，end_margin会与left_margin属性冲突。同时配置时，end_margin优先级高于left_margin、right_margin属性。 ohos:end_margin=\"20\"ohos:end_margin=\"20vp\"ohos:end_margin=\"$float:margin_value\" top_margin 上外边距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。与margin同时配置时，margin优先级高于top_margin。 ohos:top_margin=\"20\"ohos:top_margin=\"20vp\"ohos:top_margin=\"$float:margin_value\" bottom_margin 下外边距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。与margin同时配置时，margin优先级高于bottom_margin。 ohos:bottom_margin=\"20\"ohos:bottom_margin=\"20vp\"ohos:bottom_margin=\"$float:margin_value\" 滚动条 scrollbar_thickness 滚动条的厚度 float类型 表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:scrollbar_thickness=\"30\"ohos:scrollbar_thickness=\"10vp\"ohos:scrollbar_thickness=\"$float:size_value\" scrollbar_start_angle 滚动条的起始角度 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:scrollbar_start_angle=\"30\"ohos:scrollbar_start_angle=\"$float:value\" scrollbar_sweep_angle 滚动条的扫描角度 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:scrollbar_sweep_angle=\"30\"ohos:scrollbar_sweep_angle=\"$float:value\" scrollbar_background_color 滚动条背景颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:scrollbar_background_color=\"#A8FFFFFF\"ohos:scrollbar_background_color=\"$color:black\" scrollbar_color 滚动条颜色 color类型 可以直接设置色值，也可以引用color资源。 ohos:scrollbar_color=\"#A8FFFFFF\"ohos:scrollbar_color=\"$color:black\" scrollbar_fading_enabled 滚动条是否会渐隐 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:scrollbar_fading_enabled=\"true\"ohos:scrollbar_fading_enabled=\"$boolean:true\" scrollbar_overlap_enabled 滚动条是否可以重叠 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:scrollbar_overlap_enabled=\"true\"ohos:scrollbar_overlap_enabled=\"$boolean:true\" scrollbar_fading_delay 滚动条渐隐前的延迟时间，单位ms integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:scrollbar_fading_delay=\"1000\"ohos:scrollbar_fading_delay=\"$integer:delay\" scrollbar_fading_duration 滚动条渐隐时长，单位ms integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:scrollbar_fading_duration=\"1000\"ohos:scrollbar_fading_duration=\"$integer:duration\" 旋转缩放 pivot_x 旋转点X位置 float类型 可以配置表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:pivot_x=\"20\"ohos:pivot_x=\"$float:value\" pivot_y 旋转点Y位置 float类型 可以配置表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:pivot_y=\"20\"ohos:pivot_y=\"$float:value\" rotate 围绕其中心点旋转的角度 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:rotate=\"30\" ohos:rotate=\"$float:value\" scale_x X方向的缩放级别 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:scale_x=\"1.2\"ohos:scale_x=\"$float:value\" scale_y Y方向的缩放级别 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:scale_y=\"1.2\"ohos:scale_y=\"$float:value\" translation_x X方向移动的距离 float类型 可以配置表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:translation_x=\"20\"ohos:translation_x=\"20vp\"ohos:translation_x=\"$float:value\" translation_y Y方向移动的距离 float类型 可以配置表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:translation_y=\"20\"ohos:translation_y=\"20vp\"ohos:translation_y=\"$float:value\" 获焦 focusable 是否可获焦 focus_disable 表示控件不可获焦。 ohos:focusable=\"focus_disable\" focus_adaptable 表示控件获焦状态跟随控件自身默认特性。 ohos:focusable=\"focus_adaptable\" focus_enable 表示控件可以获焦。 ohos:focusable=\"focus_enable\" focus_border_radius 焦点边框圆角半径 float类型 可以配置表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:focus_border_radius=\"10\"ohos:focus_border_radius=\"10vp\"ohos:focus_border_radius=\"$float:value\" focus_border_enable 是否有焦点边框 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:focus_border_enable=\"true\"ohos:focus_border_enable=\"$boolean:true\" focus_border_width 焦点边框宽度 float类型 可以配置表示尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:focus_border_width=\"20\"ohos:focus_border_width=\"10vp\"ohos:focus_border_width=\"$float:size_value\" focus_border_padding 焦点边框的边距 float类型 表示间距尺寸的float类型。可以是浮点数值，其默认单位为px；也可以是带px/vp/fp单位的浮点数值；也可以引用float资源。 ohos:focus_border_padding=\"20\"ohos:focus_border_padding=\"20vp\"ohos:focus_border_padding=\"$float:padding_value\" focusable_in_touch 触摸状态下 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:focusable_in_touch=\"true\"ohos:focusable_in_touch=\"$boolean:true\" "},"java-layout-directionallayout.html":{"url":"java-layout-directionallayout.html","title":"DirectionalLayout","keywords":"","body":"DirectionalLayout DirectionalLayout是Java UI中的一种重要组件布局，用于将一组组件(Component)按照水平或者垂直方向排布，能够方便地对齐布局内的组件。该布局和其他布局的组合，可以实现更加丰富的布局方式。 图1 DirectionalLayout示意图 支持的XML属性 DirectionalLayout的共有XML属性继承自：Component DirectionalLayout的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 alignment 对齐方式 left 表示左对齐。 可以设置取值项如表中所列，也可以使用“\\ ”进行多项组合。ohos:alignment=\"top\\ left\"ohos:alignment=\"left\" top 表示顶部对齐。 right 表示右对齐。 bottom 表示底部对齐。 horizontal_center 表示水平居中对齐。 vertical_center 表示垂直居中对齐。 center 表示居中对齐。 start 表示靠起始端对齐。 end 表示靠结束端对齐。 orientation 子布局排列方向 horizontal 表示水平方向布局。 ohos:orientation=\"horizontal\" vertical 表示垂直方向布局。 ohos:orientation=\"vertical\" total_weight 所有子视图的权重之和 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:total_weight=\"2.5\"ohos:total_weight=\"$float:total_weight\" DirectionalLayout所包含组件可支持的XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 layout_alignment 对齐方式 left 表示左对齐。 可以设置取值项如表中所列，也可以使用“\\ ”进行多项组合。ohos:layout_alignment=\"top\"ohos:layout_alignment=\"top\\ left\" top 表示顶部对齐。 right 表示右对齐。 bottom 表示底部对齐。 horizontal_center 表示水平居中对齐。 vertical_center 表示垂直居中对齐。 center 表示居中对齐。 weight 比重 float类型 可以直接设置浮点数值，也可以引用float浮点数资源。 ohos:weight=\"1\"ohos:weight=\"$float:weight\" 排列方式 DirectionalLayout的排列方向（orientation）分为水平（horizontal）或者垂直（vertical）方向。使用orientation设置布局内组件的排列方式，默认为垂直排列。 垂直排列 垂直方向排列三个按钮，效果如下： 图2 三个垂直排列的按钮 color_cyan_element.xml： 水平排列 水平方向排列三个按钮，效果如下： 图3 三个水平排列的按钮 color_cyan_element.xml： DirectionalLayout不会自动换行，其子组件会按照设定的方向依次排列，若超过布局本身的大小，超出布局大小的部分将不会被显示，例如： color_cyan_element.xml： 此布局包含了三个按钮，但由于DirectionalLayout不会自动换行，超出布局大小的组件部分无法显示。界面显示如下： 图4 DirectionalLayout不自动换行示例 对齐方式 DirectionalLayout中的组件使用layout_alignment控制自身在布局中的对齐方式，当对齐方式与排列方式方向一致时，对齐方式不会生效，如设置了水平方向的排列方式，则左对齐、右对齐将不会生效。 三种对齐方式的示例代码： color_cyan_element.xml： 图5 三种对齐方式效果示例 权重 权重（weight）就是按比例来分配组件占用父组件的大小，在水平布局下计算公式为： 父布局可分配宽度=父布局宽度-所有子组件width之和； 组件宽度=组件weight/所有组件weight之和*父布局可分配宽度； 实际使用过程中，建议使用width=0来按比例分配父布局的宽度，1:1:1效果如下： color_cyan_element.xml： color_gray_element.xml： 场景示例 源码示例： color_light_gray_element.xml： color_cyan_element.xml： color_gray_element.xml： "},"java-layout-dependentlayout.html":{"url":"java-layout-dependentlayout.html","title":"DependentLayout","keywords":"","body":"DependentLayout DependentLayout是Java UI系统里的一种常见布局。与DirectionalLayout相比，拥有更多的排布方式，每个组件可以指定相对于其他同级元素的位置，或者指定相对于父组件的位置。 图1 DependentLayout示意图 支持的XML属性 DependentLayout的共有XML属性继承自：Component DependentLayout的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 alignment 对齐方式 left 表示左对齐。 可以设置取值项如表中所列，也可以使用“\\ ”进行多项组合。ohos:alignment=\"top\\ left\"ohos:alignment=\"left\" top 表示顶部对齐。 right 表示右对齐。 bottom 表示底部对齐。 horizontal_center 表示水平居中对齐。 vertical_center 表示垂直居中对齐。 center 表示居中对齐。 DependentLayout所包含组件可支持的XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 left_of 将右边缘与另一个子组件的左边缘对齐 引用 仅可引用DependentLayout中包含的其他组件的id。说明left_of与start_of、end_of属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，left_of会与start_of属性冲突；在“水平布局方向为从右到左”时，left_of会与end_of属性冲突。同时配置时，start_of、end_of优先级高于left_of属性。 ohos:left_of=\"$id:component_id\" right_of 将左边缘与另一个子组件的右边缘对齐 引用 仅可引用DependentLayout中包含的其他组件的id。说明right_of与start_of、end_of属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，right_of会与end_of属性冲突；在“水平布局方向为从右到左”时，right_of会与start_of属性冲突。同时配置时，start_of、end_of优先级高于right_of属性。 ohos:right_of=\"$id:component_id\" start_of 将结束边与另一个子组件的起始边对齐 引用 仅可引用DependentLayout中包含的其他组件的id。说明start_of与left_of、right_of属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，start_of会与left_of属性冲突；在“水平布局方向为从右到左”时，start_of会与right_of属性冲突。同时配置时，start_of优先级高于left_of、right_of属性。 ohos:start_of=\"$id:component_id\" end_of 将起始边与另一个子组件的结束边对齐 引用 仅可引用DependentLayout中包含的其他组件的id。说明end_of与left_of、right_of属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，end_of会与right_of属性冲突；在“水平布局方向为从右到左”时，end_of会与left_of属性冲突。同时配置时，end_of优先级高于left_of、right_of属性。 ohos:end_of=\"$id:component_id\" above 将下边缘与另一个子组件的上边缘对齐 引用 仅可引用DependentLayout中包含的其他组件的id ohos:above=\"$id:component_id\" below 将上边缘与另一个子组件的下边缘对齐 引用 仅可引用DependentLayout中包含的其他组件的id ohos:below=\"$id:component_id\" align_baseline 将子组件的基线与另一个子组件的基线对齐 引用 仅可引用DependentLayout中包含的其他组件的id ohos:align_baseline=\"$id:component_id\" align_left 将左边缘与另一个子组件的左边缘对齐 引用 仅可引用DependentLayout中包含的其他组件的id。说明align_left与align_start、align_end属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，align_left会与align_start属性冲突；在“水平布局方向为从右到左”时，align_left会与align_end属性冲突。同时配置时，align_start、align_end优先级高于align_left属性。 ohos:align_left=\"$id:component_id\" align_top 将上边缘与另一个子组件的上边缘对齐 引用 仅可引用DependentLayout中包含的其他组件的id ohos:align_top=\"$id:component_id\" align_right 将右边缘与另一个子组件的右边缘对齐 引用 仅可引用DependentLayout中包含的其他组件的id。说明align_right与align_start、align_end属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，align_right会与align_end属性冲突；在“水平布局方向为从右到左”时，align_right会与align_start属性冲突。同时配置时，align_start、align_end优先级高于align_right属性。 ohos:align_right=\"$id:component_id\" align_bottom 将底边与另一个子组件的底边对齐 引用 仅可引用DependentLayout中包含的其他组件的id ohos:align_bottom=\"$id:component_id\" align_start 将起始边与另一个子组件的起始边对齐 引用 仅可引用DependentLayout中包含的其他组件的id。说明align_start与align_left、align_right属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，align_start会与align_left属性冲突；在“水平布局方向为从右到左”时，align_start会与align_right属性冲突。同时配置时，align_start优先级高于align_left、align_right属性。 ohos:align_start=\"$id:component_id\" align_end 将结束边与另一个子组件的结束边对齐 引用 仅可引用DependentLayout中包含的其他组件的id。说明align_end与align_left、align_right属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，align_end会与align_right属性冲突；在“水平布局方向为从右到左”时，align_end会与align_left属性冲突。同时配置时，align_end优先级高于align_left、align_right属性。 ohos:align_end=\"$id:component_id\" align_parent_left 将左边缘与父组件的左边缘对齐 boolean类型 可以直接设置true/false，也可以引用boolean资源。说明align_parent_left与align_parent_start、align_parent_end属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，align_parent_left会与align_parent_start属性冲突；在“水平布局方向为从右到左”时，align_parent_left会与align_parent_end属性冲突。同时配置时，align_parent_start、align_parent_end优先级高于align_parent_left属性。 ohos:align_parent_left=\"true\"ohos:align_parent_left=\"$boolean:true\" align_parent_top 将上边缘与父组件的上边缘对齐 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:align_parent_top=\"true\"ohos:align_parent_top=\"$boolean:true\" align_parent_right 将右边缘与父组件的右边缘对齐 boolean类型 可以直接设置true/false，也可以引用boolean资源。说明align_parent_right与align_parent_start、align_parent_end属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，align_parent_right会与align_parent_end属性冲突；在“水平布局方向为从右到左”时，align_parent_right会与align_parent_start属性冲突。同时配置时，align_parent_start、align_parent_end优先级高于align_parent_right属性。 ohos:align_parent_right=\"true\"ohos:align_parent_right=\"$boolean:true\" align_parent_bottom 将底边与父组件的底边对齐 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:align_parent_bottom=\"true\"ohos:align_parent_bottom=\"$boolean:true\" align_parent_start 将起始边与父组件的起始边对齐 boolean类型 可以直接设置true/false，也可以引用boolean资源。说明align_parent_start与align_parent_left、align_parent_right属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，align_parent_start会与align_parent_left属性冲突；在“水平布局方向为从右到左”时，align_parent_start会与align_parent_right属性冲突。同时配置时，align_parent_start优先级高于align_parent_left、align_parent_right属性。 ohos:align_parent_start=\"true\"ohos:align_parent_start=\"$boolean:true\" align_parent_end 将结束边与父组件的结束边对齐 boolean类型 可以直接设置true/false，也可以引用boolean资源。说明align_parent_end与align_parent_left、align_parent_right属性有冲突，不建议一起使用。在“水平布局方向为从左到右”时，align_parent_end会与align_parent_right属性冲突；在“水平布局方向为从右到左”时，align_parent_end会与align_parent_left属性冲突。同时配置时，align_parent_end优先级高于align_parent_left、align_parent_right属性。 ohos:align_parent_end=\"true\"ohos:align_parent_end=\"$boolean:true\" center_in_parent 将子组件保持在父组件的中心 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:center_in_parent=\"true\"ohos:center_in_parent=\"$boolean:true\" horizontal_center 将子组件保持在父组件水平方向的中心 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:horizontal_center=\"true\"ohos:horizontal_center=\"$boolean:true\" vertical_center 将子组件保持在父组件垂直方向的中心 boolean类型 可以直接设置true/false，也可以引用boolean资源。 ohos:vertical_center=\"true\"ohos:vertical_center=\"$boolean:true\" 排列方式 DependentLayout的排列方式是相对于其他同级组件或者父组件的位置进行布局。 相对于同级组件 end_of： color_light_gray_element.xml： color_cyan_element.xml： below： color_light_gray_element.xml： color_cyan_element.xml： 其他的above、start_of、left_of、right_of等参数可分别实现类似的布局。 相对于父组件 以上位置布局可以组合，形成处于左上角、左下角、右上角、右下角的布局。 color_background_gray_element.xml： color_cyan_element.xml： 场景示例 使用DependentLayout可以轻松实现内容丰富的布局。 源码示例： color_background_gray_element.xml： color_gray_element.xml： "},"java-layout-stacklayout.html":{"url":"java-layout-stacklayout.html","title":"StackLayout","keywords":"","body":"StackLayout StackLayout直接在屏幕上开辟出一块空白的区域，添加到这个布局中的视图都是以层叠的方式显示，而它会把这些视图默认放到这块区域的左上角，第一个添加到布局中视图显示在最底层，最后一个被放在最顶层。上一层的视图会覆盖下一层的视图。 图1 StackLayout示意图 支持的XML属性 StackLayout无自有的XML属性，共有XML属性继承自：Component StackLayout所包含组件可支持的XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 layout_alignment 对齐方式 left 表示左对齐。 可以设置取值项如表中所列，也可以使用“\\ ”进行多项组合。ohos:layout_alignment=\"top\"ohos:layout_alignment=\"top\\ left\" top 表示顶部对齐。 right 表示右对齐。 bottom 表示底部对齐。 horizontal_center 表示水平居中对齐。 vertical_center 表示垂直居中对齐。 center 表示居中对齐。 创建StackLayout 使用默认布局添加组件 StackLayout中组件的布局默认在区域的左上角，并且以后创建的组件会在上层。 xml布局： 图2 多个视图排列效果 使用相对位置添加组件 使用layout_alignment属性可以指定组件在StackLayout中的相对位置，如下表示Button组件位于StackLayout的右面。 xml布局： 图3 右边布局 场景展示 将子视图从后面移到前面显示 图4 将某个视图移到前面的效果 Java示例代码： ComponentContainer stackLayout = (ComponentContainer) findComponentById(ResourceTable.Id_stack_layout); Text textFirst = (Text) findComponentById(ResourceTable.Id_text_blue); textFirst.setClickedListener(new Component.ClickedListener() { @Override public void onClick(Component component) { stackLayout.moveChildToFront(component); }}); "},"java-layout-tablelayout.html":{"url":"java-layout-tablelayout.html","title":"TableLayout","keywords":"","body":"TableLayout TableLayout使用表格的方式划分子组件。 图1 表格布局示意图 支持的XML属性 TableLayout的共有XML属性继承自：Component TableLayout的自有XML属性见下表： 属性名称 中文描述 取值 取值说明 使用案例 alignment_type 对齐方式 align_edges 表示TableLayout内的组件按边界对齐。 ohos:alignment_type=\"align_edges\" align_contents 表示TableLayout内的组件按边距对齐。 ohos:alignment_type=\"align_contents\" column_count 列数 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:column_count=\"3\"ohos:column_count=\"$integer:count\" row_count 行数 integer类型 可以直接设置整型数值，也可以引用integer资源。 ohos:row_count=\"2\"ohos:row_count=\"$integer:count\" orientation 排列方向 horizontal 表示水平方向布局。 ohos:orientation=\"horizontal\" vertical 表示垂直方向布局。 ohos:orientation=\"vertical\" 在XML文件中创建TableLayout 添加组件 在XML创建Text的背景table_text_bg_element.xml。 在TableLayout布局中添加组件。 图2 TableLayout默认一列多行 设置行数和列数 图3 设置TableLayout的行为2，列为2效果 设置对齐方式 在XML中设置对齐方式，以”align_contents“为例： ... "},"java-layout-positionlayout.html":{"url":"java-layout-positionlayout.html","title":"PositionLayout","keywords":"","body":"PositionLayout 在PositionLayout中，子组件通过指定准确的x/y坐标值在屏幕上显示。(0, 0)为左上角；当向下或向右移动时，坐标值变大；允许组件之间互相重叠。 图1 PositionLayout示意图 布局方式 PositionLayout以坐标的形式控制组件的显示位置，允许组件相互重叠。 在layout目录下的XML文件中创建PositionLayout并添加多个组件，并通过position_x和position_y属性设置子组件的坐标。 图2 使用PositionLayout的布局效果 示例代码： 设置子组件的坐标时（position_x和position_y属性），除了上述示例中的XML方式，还可以在对应的AbilitySlice中通过setPosition(int x, int y)接口设置，Java示例代码如下： Text title = (Text)findComponentById(ResourceTable.Id_position_text_1); Text content1 = (Text)findComponentById(ResourceTable.Id_position_text_2); Text content2 = (Text)findComponentById(ResourceTable.Id_position_text_3); title.setPosition(100, 20); content1.setPosition(20, 150); content2.setPosition(180, 400); 对于超过布局本身大小的组件，超出部分将不显示。 图3 Right组件右侧超出部分将不显示 示例代码： ... 相关实例 针对PositionLayout开发，有以下示例工程可供参考： PositionLayout 本示例演示了PositionLayout的一些特性，包括子组件位置的影响和超越屏幕大小后子组件的显示规则。 "},"java-layout-adaptiveboxlayout.html":{"url":"java-layout-adaptiveboxlayout.html","title":"AdaptiveBoxLayout","keywords":"","body":"AdaptiveBoxLayout AdaptiveBoxLayout是自适应盒子布局，该布局提供了在不同屏幕尺寸设备上的自适应布局能力，主要用于相同级别的多个组件需要在不同屏幕尺寸设备上自动调整列数的场景。 该布局中的每个子组件都用一个单独的“盒子”装起来，子组件设置的布局参数都是以盒子作为父布局生效，不以整个自适应布局为生效范围。 该布局中每个盒子的宽度固定为布局总宽度除以自适应得到的列数，高度为match_content，每一行中的所有盒子按高度最高的进行对齐。 该布局水平方向是自动分块，因此水平方向不支持match_content，布局水平宽度仅支持match_parent或固定宽度。 自适应仅在水平方向进行了自动分块，纵向没有做限制，因此如果某个子组件的高设置为match_parent类型，可能导致后续行无法显示。 图1 AdaptiveBoxLayout示意图 常用方法 AdaptiveBoxLayout布局常用方法如下。 方法 功能 addAdaptiveRule(int minWidth, int maxWidth, int columns) 添加一个自适应盒子布局规则。 removeAdaptiveRule(int minWidth, int maxWidth, int columns) 移除一个自适应盒子布局规则。 clearAdaptiveRules() 移除所有自适应盒子布局规则。 场景示例 在AdaptiveBoxLayout中添加和删除自适应盒子布局规则的效果对比如下。 图2 添加和删除一个规则的效果对比 XML布局示例代码： Java关键代码： AdaptiveBoxLayout adaptiveBoxLayout = (AdaptiveBoxLayout)findComponentById(ResourceTable.Id_adaptive_box_layout); findComponentById(ResourceTable.Id_add_rule_btn).setClickedListener((component-> { // 添加规则 adaptiveBoxLayout.addAdaptiveRule(100, 2000, 3); // 更新布局 adaptiveBoxLayout.postLayout();})); findComponentById(ResourceTable.Id_remove_rule_btn).setClickedListener((component-> { // 移除规则 adaptiveBoxLayout.removeAdaptiveRule(100, 2000, 3); // 更新布局 adaptiveBoxLayout.postLayout();})); "},"java-custom-component-layout-overview.html":{"url":"java-custom-component-layout-overview.html","title":"自定义组件与布局概述","keywords":"","body":"自定义组件与布局概述 HarmonyOS提供了一套复杂且强大的Java UI框架，其中Component提供内容显示，是界面中所有组件的基类。ComponentContainer作为容器容纳Component或ComponentContainer对象，并对它们进行布局。 Java UI框架也提供了一部分Component和ComponentContainer的具体子类，即常用的组件（比如：Text、Button、Image等）和常用的布局（比如：DirectionalLayout、DependentLayout等）。如果现有的组件和布局无法满足设计需求，例如仿遥控器的圆盘按钮、可滑动的环形控制器等，可以通过自定义组件和自定义布局来实现。 自定义组件是由开发者定义的具有一定特性的组件，通过扩展Component或其子类实现，可以精确控制屏幕元素的外观，也可响应用户的点击、触摸、长按等操作。 自定义布局是由开发者定义的具有特定布局规则的容器类组件，通过扩展ComponentContainer或其子类实现，可以将各子组件摆放到指定的位置，也可响应用户的滑动、拖拽等事件。 "},"java-custom-components.html":{"url":"java-custom-components.html","title":"自定义组件","keywords":"","body":"自定义组件 当Java UI框架提供的组件无法满足设计需求时，可以创建自定义组件，根据设计需求添加绘制任务，并定义组件的属性及事件响应，完成组件的自定义。 常用接口 接口名 作用 setEstimateSizeListener 设置测量组件的侦听器。 onEstimateSize 测量组件的大小以确定宽度和高度。 setEstimatedSize 将测量的宽度和高度设置给组件。 EstimateSpec.getChildSizeWithMode 基于指定的大小和模式为子组件创建度量规范。 EstimateSpec.getSize 从提供的度量规范中提取大小。 EstimateSpec.getMode 获取该组件的显示模式。 addDrawTask 添加绘制任务。 onDraw 通过绘制任务更新组件时调用。 如何实现自定义组件 下面以自定义圆环组件为例，介绍自定义组件的通用配置方法：在屏幕中绘制蓝色圆环，并实现点击变化圆环颜色的功能。 图1 在界面中显示的自定义圆环组件 创建自定义组件的类，并继承Component或其子类，添加构造方法。 示例代码如下： public class CustomComponent extends Component{ public CustomComponent(Context context) { super(context); }} 实现Component.EstimateSizeListener接口，在onEstimateSize方法中进行组件测量，并通过setEstimatedSize方法将测量的宽度和高度设置给组件。 示例代码如下： public class CustomComponent extends Component implements Component.EstimateSizeListener { public CustomComponent(Context context) { super(context); ... // 设置测量组件的侦听器 setEstimateSizeListener(this); } ... @Override public boolean onEstimateSize(int widthEstimateConfig, int heightEstimateConfig) { int width = Component.EstimateSpec.getSize(widthEstimateConfig); int height = Component.EstimateSpec.getSize(heightEstimateConfig); setEstimatedSize( Component.EstimateSpec.getChildSizeWithMode(width, width, Component.EstimateSpec.NOT_EXCEED), Component.EstimateSpec.getChildSizeWithMode(height, height, Component.EstimateSpec.NOT_EXCEED)); return true; }} 注意事项 自定义组件测量出的大小需通过setEstimatedSize设置给组件，并且必须返回true使测量值生效。 setEstimatedSize方法的入参携带模式信息，可使用Component.EstimateSpec.getChildSizeWithMode方法进行拼接。 测量模式 测量组件的宽高需要携带模式信息，不同测量模式下的测量结果也不相同，需要根据实际需求选择适合的测量模式。 | 模式 | 作用 | | ------------ | -------------------------------------------------- | | UNCONSTRAINT | 父组件对子组件没有约束，表示子组件可以任意大小。 | | PRECISE | 父组件已确定子组件的大小。 | | NOT_EXCEED | 已为子组件确定了最大大小，子组件不能超过指定大小。 | 实现Component.DrawTask接口，在onDraw方法中执行绘制任务，该方法提供的画布Canvas，可以精确控制屏幕元素的外观。在执行绘制任务之前，需要定义画笔Paint。 示例代码如下： public class CustomComponent extends Component implements Component.DrawTask,Component.EstimateSizeListener { // 圆环宽度 private static final float CIRCLE_STROKE_WIDTH = 100f; // 绘制圆环的画笔 private Paint circlePaint; public CustomComponent(Context context) { super(context); // 初始化画笔 initPaint(); // 添加绘制任务 addDrawTask(this); } private void initPaint(){ circlePaint = new Paint(); circlePaint.setColor(Color.BLUE); circlePaint.setStrokeWidth(CIRCLE_STROKE_WIDTH); circlePaint.setStyle(Paint.Style.STROKE_STYLE); } @Override public void onDraw(Component component, Canvas canvas) { // 在界面中绘制一个圆心坐标为(500,500),半径为400的圆 canvas.drawCircle(500,500,400,circlePaint); } ...} 实现Component.TouchEventListener或其他事件的接口，使组件可响应用户输入。 示例代码如下： public class CustomComponent extends Component implements Component.DrawTask, Component.EstimateSizeListener, Component.TouchEventListener { ... public CustomComponent(Context context) { ... // 设置TouchEvent响应事件 setTouchEventListener(this); } ... @Override public boolean onTouchEvent(Component component, TouchEvent touchEvent) { switch (touchEvent.getAction()) { case TouchEvent.PRIMARY_POINT_DOWN: circlePaint.setColor(Color.GREEN); invalidate(); break; case TouchEvent.PRIMARY_POINT_UP: circlePaint.setColor(Color.YELLOW); invalidate(); break; } return false; }} 注意事项 需要更新UI显示时，可调用invalidate()方法。 示例中展示TouchEventListener为响应触摸事件，除此之外还可实现ClickedListener响应点击事件、LongClickedListener响应长按事件等。 在onStart()方法中，将自定义组件添加至UI界面中。 @Overrideprotected void onStart(Intent intent) { super.onStart(intent); DirectionalLayout.LayoutConfig config = new DirectionalLayout.LayoutConfig( DirectionalLayout.LayoutConfig.MATCH_PARENT, DirectionalLayout.LayoutConfig.MATCH_PARENT); myLayout.setLayoutConfig(config); CustomComponent customComponent = new CustomComponent(this); DirectionalLayout.LayoutConfig layoutConfig = new DirectionalLayout.LayoutConfig(1080, 1000); customComponent.setLayoutConfig(layoutConfig); myLayout.addComponent(customComponent); super.setUIContent(myLayout);} 场景示例 利用自定义组件，绘制环形进度控制器，可通过滑动改变当前进度，也可响应进度的改变，UI显示的样式也可通过设置属性进行调整。 图2 自定义环形进度控制器 示例代码如下： public class CustomControlBar extends Component implements Component.DrawTask, Component.EstimateSizeListener, Component.TouchEventListener { private final static float CIRCLE_ANGLE = 360.0f; private final static int DEF_UNFILL_COLOR = 0xFF808080; private final static int DEF_FILL_COLOR = 0xFF1E90FF; // 圆环轨道颜色 private Color unFillColor; // 圆环覆盖颜色 private Color fillColor; // 圆环宽度 private int circleWidth; // 画笔 private Paint paint; // 个数 private int count; // 当前进度 private int currentCount; // 间隙值 private int splitSize; // 内圆的正切方形 private RectFloat centerRectFloat; // 中心绘制的图片 private PixelMap image; // 原点坐标 private Point centerPoint; // 进度改变的事件响应 private ProgressChangeListener listener; public CustomControlBar(Context context) { super(context); paint = new Paint(); initData(); setEstimateSizeListener(this); setTouchEventListener(this); addDrawTask(this); } // 初始化属性值 private void initData() { unFillColor = new Color(DEF_UNFILL_COLOR); fillColor = new Color(DEF_FILL_COLOR); count = 10; currentCount = 2; splitSize = 15; circleWidth = 60; centerRectFloat = new RectFloat(); image = Utils.createPixelMapByResId(ResourceTable.Media_icon, getContext()).get(); listener = null; } @Override public boolean onEstimateSize(int widthEstimateConfig, int heightEstimateConfig) { int width = Component.EstimateSpec.getSize(widthEstimateConfig); int height = Component.EstimateSpec.getSize(heightEstimateConfig); setEstimatedSize( Component.EstimateSpec.getChildSizeWithMode(width, width, Component.EstimateSpec.PRECISE), Component.EstimateSpec.getChildSizeWithMode(height, height, Component.EstimateSpec.PRECISE) ); return true; } @Override public void onDraw(Component component, Canvas canvas) { paint.setAntiAlias(true); paint.setStrokeWidth(circleWidth); paint.setStrokeCap(Paint.StrokeCap.ROUND_CAP); paint.setStyle(Paint.Style.STROKE_STYLE); int width = getWidth(); int center = width / 2; centerPoint = new Point(center, center); int radius = center - circleWidth / 2; drawCount(canvas, center, radius); int inRadius = center - circleWidth; double length = inRadius - Math.sqrt(2) * 1.0f / 2 * inRadius; centerRectFloat.left = (float) (length + circleWidth); centerRectFloat.top = (float) (length + circleWidth); centerRectFloat.bottom = (float) (centerRectFloat.left + Math.sqrt(2) * inRadius); centerRectFloat.right = (float) (centerRectFloat.left + Math.sqrt(2) * inRadius); // 如果图片比较小，那么根据图片的尺寸放置到正中心 Size imageSize = image.getImageInfo().size; if (imageSize.width 0.4) { currentCount = (int) multiple + 1; } else { currentCount = (int) multiple; } if (listener != null) { listener.onProgressChangeListener(currentCount); } invalidate(); break; } } return false; } public interface ProgressChangeListener { void onProgressChangeListener(int Progress); } // 计算centerPt到targetPt的夹角，单位为度。返回范围为[0, 360)，顺时针旋转。 private double calcRotationAngleInDegrees(Point centerPt, Point targetPt) { double theta = Math.atan2(targetPt.getPointY() - centerPt.getPointY(), targetPt.getPointX() - centerPt.getPointX()); theta += Math.PI / 2.0; double angle = Math.toDegrees(theta); if (angle 在绘制图片时使用到Utils工具类： public class Utils { private static final HiLogLabel TAG = new HiLogLabel(3, 0xD001100, \"Utils\"); private static byte[] readResource(Resource resource) { final int bufferSize = 1024; final int ioEnd = -1; byte[] byteArray; byte[] buffer = new byte[bufferSize]; try (ByteArrayOutputStream output = new ByteArrayOutputStream()) { while (true) { int readLen = resource.read(buffer, 0, bufferSize); if (readLen == ioEnd) { HiLog.error(TAG, \"readResource finish\"); byteArray = output.toByteArray(); break; } output.write(buffer, 0, readLen); } } catch (IOException e) { HiLog.debug(TAG, \"readResource failed \" + e.getLocalizedMessage()); return new byte[0]; } HiLog.debug(TAG, \"readResource len: \" + byteArray.length); return byteArray; } /** * Creates a {@code PixelMap} object based on the image resource ID. * * This method only loads local image resources. If the image file does not exist or the loading fails, * {@code null} is returned. * * @param resourceId Indicates the image resource ID. * @param slice Indicates the Context. * @return Returns the image. */ public static Optional createPixelMapByResId(int resourceId, Context slice) { ResourceManager manager = slice.getResourceManager(); if (manager == null) { return Optional.empty(); } try (Resource resource = manager.getResource(resourceId)) { if (resource == null) { return Optional.empty(); } ImageSource.SourceOptions srcOpts = new ImageSource.SourceOptions(); srcOpts.formatHint = \"image/png\"; ImageSource imageSource = ImageSource.create(readResource(resource), srcOpts); if (imageSource == null) { return Optional.empty(); } ImageSource.DecodingOptions decodingOpts = new ImageSource.DecodingOptions(); decodingOpts.desiredSize = new Size(0, 0); decodingOpts.desiredRegion = new Rect(0, 0, 0, 0); decodingOpts.desiredPixelFormat = PixelFormat.ARGB_8888; return Optional.of(imageSource.createPixelmap(decodingOpts)); } catch (NotExistException | IOException e) { return Optional.empty(); } }} 在onStart()方法里将此组件添加到界面中，并可自由设置其事件响应、颜色、大小等属性。 @Overrideprotected void onStart(Intent intent) { super.onStart(intent); DirectionalLayout.LayoutConfig config = new DirectionalLayout.LayoutConfig( DirectionalLayout.LayoutConfig.MATCH_PARENT, DirectionalLayout.LayoutConfig.MATCH_PARENT); myLayout.setLayoutConfig(config); // 在此创建自定义组件，并可设置其属性 CustomControlBar controlBar = new CustomControlBar(this); controlBar.setClickable(true); DirectionalLayout.LayoutConfig layoutConfig = new DirectionalLayout.LayoutConfig( 600, 600); controlBar.setLayoutConfig(layoutConfig); ShapeElement element = new ShapeElement(); element.setRgbColor(new RgbColor(0, 0, 0)); controlBar.setBackground(element); // 将此组件添加至布局，并在界面中显示 myLayout.addComponent(controlBar); super.setUIContent(myLayout);} 相关实例 针对自定义组件开发，有以下实例可供参考： 自定义组件 通过一个圆形抽奖转盘演示HarmonyOS自定义组件的实现。 分布式地图导航 基于分布式能力，实现地图导航信息在手机-车机-智能穿戴设备之间流转。 "},"java-custom-layouts.html":{"url":"java-custom-layouts.html","title":"自定义布局","keywords":"","body":"自定义布局 当Java UI框架提供的布局无法满足设计需求时，可以创建自定义布局，根据需求自定义布局规则。 常用接口 Component类相关接口 | 接口名称 | 作用 | | --------------------------------- | ------------------------------------------ | | setEstimateSizeListener | 设置测量组件的侦听器。 | | onEstimateSize | 测量组件的大小以确定宽度和高度。 | | setEstimatedSize | 将测量的宽度和高度设置给组件。 | | EstimateSpec.getChildSizeWithMode | 基于指定的大小和模式为子组件创建度量规范。 | | EstimateSpec.getSize | 从提供的度量规范中提取大小。 | | EstimateSpec.getMode | 获取该组件的显示模式。 | | arrange | 相对于容器组件设置组件的位置和大小。 | ComponentContainer类相关接口 | 接口名称 | 作用 | | ------------------ | -------------------------------------------- | | setArrangeListener | 设置容器组件布局子组件的侦听器。 | | onArrange | 通知容器组件在布局时设置子组件的位置和大小。 | 如何实现自定义布局 使用自定义布局，将各子组件摆放到指定的位置。 图1 自定义布局的使用效果 创建自定义布局的类，并继承ComponentContainer，添加构造方法。 public class CustomLayout extends ComponentContainer { public CustomLayout(Context context) { super(context); }} 实现ComponentContainer.EstimateSizeListener接口，在onEstimateSize方法中进行测量。 public class CustomLayout extends ComponentContainer implements ComponentContainer.EstimateSizeListener { ... public CustomLayout(Context context) { ... setEstimateSizeListener(this); } @Override public boolean onEstimateSize(int widthEstimatedConfig, int heightEstimatedConfig) { // 通知子组件进行测量 measureChildren(widthEstimatedConfig, heightEstimatedConfig); int width = Component.EstimateSpec.getSize(widthEstimatedConfig); // 关联子组件的索引与其布局数据 for (int idx = 0; idx 注意事项 容器类组件在自定义测量过程不仅要测量自身，也要递归的通知各子组件进行测量。 测量出的大小需通过setEstimatedSize设置给组件，并且必须返回true使测量值生效。 测量时，需要确定每个子组件大小和位置的数据，并保存这些数据。 private int xx = 0; private int yy = 0; private int maxWidth = 0; private int maxHeight = 0; private int lastHeight = 0; // 子组件索引与其布局数据的集合 private final Map axis = new HashMap<>(); private static class Layout { int positionX = 0; int positionY = 0; int width = 0; int height = 0; } ... private void invalidateValues() { xx = 0; yy = 0; maxWidth = 0; maxHeight = 0; axis.clear(); } private void addChild(Component component, int id, int layoutWidth) { Layout layout = new Layout(); layout.positionX = xx + component.getMarginLeft(); layout.positionY = yy + component.getMarginTop(); layout.width = component.getEstimatedWidth(); layout.height = component.getEstimatedHeight(); if ((xx + layout.width) > layoutWidth) { xx = 0; yy += lastHeight; lastHeight = 0; layout.positionX = xx + component.getMarginLeft(); layout.positionY = yy + component.getMarginTop(); } axis.put(id, layout); lastHeight = Math.max(lastHeight, layout.height + component.getMarginBottom()); xx += layout.width + component.getMarginRight(); maxWidth = Math.max(maxWidth, layout.positionX + layout.width); maxHeight = Math.max(maxHeight, layout.positionY + layout.height); } 实现ComponentContainer.ArrangeListener接口，在onArrange方法中排列子组件。 public class CustomLayout extends ComponentContainer implements ComponentContainer.EstimateSizeListener, ComponentContainer.ArrangeListener { ... public CustomLayout(Context context) { ... setArrangeListener(this); } @Override public boolean onArrange(int left, int top, int width, int height) { // 对各个子组件进行布局 for (int idx = 0; idx 在onStart方法中添加此布局，在布局中添加若干子组件，并在界面中显示。 @Overrideprotected void onStart(Intent intent) { super.onStart(intent); DirectionalLayout.LayoutConfig config = new DirectionalLayout.LayoutConfig( DirectionalLayout.LayoutConfig.MATCH_PARENT, DirectionalLayout.LayoutConfig.MATCH_PARENT); myLayout.setLayoutConfig(config); CustomLayout customLayout = new CustomLayout(this); for (int idx = 0; idx "},"java-animation.html":{"url":"java-animation.html","title":"动画开发指导","keywords":"","body":"动画开发指导 动画是组件的基础特性之一，精心设计的动画使UI变化更直观，有助于改进应用程序的外观并改善用户体验。Java UI框架提供了帧动画、数值动画和属性动画，并提供了将多个动画同时操作的动画集合。 帧动画 帧动画是利用视觉暂留现象，将一系列静止的图片按序播放，给用户产生动画的效果。 在“Project”窗口，打开“entry > src > main > resources > base > media”，添加一系列图片至“media”目录下。 在“graphic”目录下，新建“animation_element.xml”文件，在XML文件中使用animation-list标签来配置图片资源，duration用来设置显示时长，单位为毫秒。oneshot表示是否只播放一次。 在Java代码中，获取动画资源。 FrameAnimationElement frameAnimationElement = new FrameAnimationElement(getContext(), ResourceTable.Graphic_animation_element); 创建一个组件用于承载帧动画。 Component component = new Component(getContext());component.setWidth(500);component.setHeight(500);component.setBackground(frameAnimationElement); 启动动画。 frameAnimationElement.start(); 动画效果如图所示： 图1 帧动画效果 数值动画 AnimatorValue数值从0到1变化，本身与Component无关。开发者可以设置0到1变化过程的属性，例如：时长、变化曲线、重复次数等，并通过值的变化改变组件的属性，实现组件的动画效果。 声明AnimatorValue。 Java方式： AnimatorValue animatorValue = new AnimatorValue(); XML方式：在resource/base/animation文件夹下声明名为“animator_value.xml”的XML文件。但是，目前XML方式只支持delay和duration属性，其他属性均需通过Java代码设置，因此建议采用Java方式。 使用数值动画。 Java方式：设置变化属性。 animatorValue.setDuration(2000);animatorValue.setDelay(1000);animatorValue.setLoopedCount(2);animatorValue.setCurveType(Animator.CurveType.BOUNCE); XML方式：解析XML数值动画文件并使用。 AnimatorScatter scatter = AnimatorScatter.getInstance(getContext());Animator animator = scatter.parse(ResourceTable.Animation_animator_value);if (animator instanceof AnimatorValue) { AnimatorValue animatorValue = (AnimatorValue) animator; animatorValue.setLoopedCount(2); animatorValue.setCurveType(Animator.CurveType.BOUNCE);} 添加回调事件。 animatorValue.setValueUpdateListener(new AnimatorValue.ValueUpdateListener() { @Override public void onUpdate(AnimatorValue animatorValue, float value) { button.setContentPosition((int) (800 * value), button.getContentPositionY()); }}); 启动动画或对动画做其他操作。 animatorValue.start(); 动画效果如图所示： 图2 数值动画效果 属性动画 为Component的属性设置动画是非常常见的需求，Java UI框架可以为Component设置某个属性或多个属性的动画。 声明AnimatorProperty。 Java方式： AnimatorProperty animatorProperty = image.createAnimatorProperty(); XML方式：在resource/base/animation文件夹下声明名为“animator_property.xml”的XML文件。但是，目前XML方式只支持delay和duration属性，其他属性均需通过Java代码设置，因此建议采用Java方式。 使用属性动画。 Java方式：设置变化属性，可链式调用。 animatorProperty.moveFromX(50).moveToX(1000).rotate(90).alpha(0).setDuration(2500).setDelay(500).setLoopedCount(5); XML方式：解析XML属性动画文件并使用。 AnimatorScatter scatter = AnimatorScatter.getInstance(getContext());Animator animator = scatter.parse(ResourceTable.Animation_animator_property);if (animator instanceof AnimatorProperty) { AnimatorProperty animatorProperty = (AnimatorProperty) animator; animatorProperty.setTarget(component); animatorProperty.moveFromX(50).moveToX(1000).rotate(90).alpha(0).setLoopedCount(5);} 启动动画或对动画做其他操作。 在页面显示时启动动画 image.setBindStateChangedListener(new Component.BindStateChangedListener() { @Override public void onComponentBoundToWindow(Component component) { animatorProperty.start(); } @Override public void onComponentUnboundFromWindow(Component component) { animatorProperty.stop();}}); 在点击事件中启动动画 image.setClickedListener(component -> animatorProperty.start()); 动画效果如图所示： 图3 属性动画效果 动画集合 如果需要使用一个组合动画，可以把多个动画对象进行组合，并添加到使用AnimatorGroup中。AnimatorGroup提供了两个方法：runSerially() 和 runParallel()，分别表示动画按顺序开始和动画同时开始。（注：动画集合暂不支持XML使用方式。） 声明AnimatorGroup。 AnimatorGroup animatorGroup = new AnimatorGroup(); 添加要按顺序或同时开始的动画。 // 4个动画按顺序播放animatorGroup.runSerially(am1, am2, am3, am4);// 4个动画同时播放animatorGroup.runParallel(am1, am2, am3, am4); 启动动画或对动画做其他操作。 animatorGroup.start(); 为了更加灵活处理多个动画的播放顺序，例如一些动画顺序播放，一些动画同时播放，Java UI框架提供了更方便的动画Builder接口： 声明AnimatorGroup.Builder。 AnimatorGroup.Builder animatorGroupBuilder = animatorGroup.build(); 按播放顺序添加多个动画。 // 4个动画的顺序为: am1 -> am2/am3 -> am4animatorGroupBuilder.addAnimators(am1).addAnimators(am2, am3).addAnimators(am4) 启动动画或对动画做其他操作。 animatorGroup.start(); 动画集合的动画效果如下： 图4 动画集合效果 相关实例 针对动画开发，有以下示例工程可供参考： Animation 本示例演示了帧动画、数值动画、属性动画和组合动画的实现。 "},"java-hot-words.html":{"url":"java-hot-words.html","title":"可见即可说开发指导","keywords":"","body":"可见即可说开发指导 可见即可说是要求Component中通过与热词关联，从而达到指定的效果。例如：在浏览图片时，说出图片的名字或角标序号，从而实现打开图片的效果。 说明 该功能目前仅在智慧屏产品上支持。 热词注册 开发者首先需要进行Component的热词注册，即告诉设备，哪些热词是这个Component所需要响应的。 构建Component.VoiceEvent对象，需要设置热词，中英文都可以。 Component.VoiceEvent eventKeys = new Component.VoiceEvent(\"ok\"); 如果一个Component的同一VoiceEvent存在多个热词匹配，可以通过addSynonyms方法增加eventKeys的热词。 eventKeys.addSynonyms(\"确定\"); 当Component.VoiceEvent对象操作完成后，使用Component的subscribeVoiceEvents方法来发起注册。 Component.subscribeVoiceEvents(eventKeys); 如果一个Component有多个事件需要响应，需要创建不同的事件来进行注册。 事件响应 开发者完成热词注册后，需要关注的是对应于不同热词所需要处理的事件。事件响应回调的SpeechEvent对象仅包含一个热词。 首先需要实现SpeechEventListener接口。 private Component.SpeechEventListener speechEventListener = new Component.SpeechEventListener( @Override public boolean onSpeechEvent(Component v, SpeechEvent event) { if (event.getActionProperty().equals(\"ok\")) { ... // 检测注册的热词，进行相应的处理 }}); 通过setSpeechEventListener方法实现回调注册。 Component.setSpeechEventListener(speechEventListener); "},"js-overview.html":{"url":"js-overview.html","title":"JS UI框架概述","keywords":"","body":"JS UI框架概述 JS UI框架是一种跨设备的高性能UI开发框架，支持声明式编程和跨设备多态UI。 关于组件和接口的详细参考文档请参见JS API参考。 说明 本文档适用于手机（Phone）、平板（Tablet）、智慧屏（TV）和智能穿戴（Wearable）应用开发，针对轻量级智能穿戴（Lite Wearable）请参考轻量级智能穿戴开发。 基础能力 声明式编程 JS UI框架采用类HTML和CSS声明式编程语言作为页面布局和页面样式的开发语言，页面业务逻辑则支持ECMAScript规范的JavaScript语言。JS UI框架提供的声明式编程，可以让开发者避免编写UI状态切换的代码，视图配置信息更加直观。 跨设备 开发框架架构上支持UI跨设备显示能力，运行时自动映射到不同设备类型，开发者无感知，降低开发者多设备适配成本。 高性能 开发框架包含了许多核心的控件，如列表、图片和各类容器组件等，针对声明式语法进行了渲染流程的优化。 整体架构 JS UI框架包括应用层（Application）、前端框架层（Framework）、引擎层（Engine）和平台适配层（Porting Layer）。 Application 应用层表示开发者使用JS UI框架开发的FA应用，这里的FA应用特指JS FA应用。使用Java开发FA应用请参考Java UI框架。 Framework 前端框架层主要完成前端页面解析，以及提供MVVM（Model-View-ViewModel）开发模式、页面路由机制和自定义组件等能力。 Engine 引擎层主要提供动画解析、DOM（Document Object Model）树构建、布局计算、渲染命令构建与绘制、事件管理等能力。 Porting Layer 适配层主要完成对平台层进行抽象，提供抽象接口，可以对接到系统平台。比如：事件对接、渲染管线对接和系统生命周期对接等。 "},"js-fa-overview.html":{"url":"js-fa-overview.html","title":"JS FA概述","keywords":"","body":"JS FA概述 JS UI框架支持纯JavaScript、JavaScript和Java混合语言开发。JS FA指基于JavaScript或JavaScript和Java混合开发的FA，下面主要介绍：JS FA在HarmonyOS上运行时需要的基类AceAbility、加载JS FA主体的方法、JS FA开发目录。 AceAbility AceAbility类是JS FA在HarmonyOS上运行环境的基类，继承自Ability。开发者的应用运行入口类应该从该类派生，代码示例如下： public class MainAbility extends AceAbility { @Override public void onStart(Intent intent) { super.onStart(intent); } @Override public void onStop() { super.onStop(); }} 如何加载JS FA JS FA生命周期事件分为应用生命周期和页面生命周期，应用通过AceAbility类中setInstanceName()接口设置该Ability的实例资源，并通过AceAbility窗口进行显示以及全局应用生命周期管理。 setInstanceName(String name)的参数“name”指实例名称，实例名称与config.json文件中module.js.name的值对应。若开发者未修改实例名，而使用了缺省值default，则无需调用此接口。若开发者修改了实例名，则需在应用Ability实例的onStart()中调用此接口，并将参数“name”设置为修改后的实例名称。 说明 多实例应用的module.js字段中有多个实例项，使用时请选择相应的实例名称。 setInstanceName()接口使用方法：在MainAbility的onStart()中的super.onStart()前调用此接口。以JSComponentName作为实例名称，代码示例如下： public class MainAbility extends AceAbility { @Override public void onStart(Intent intent) { setInstanceName(\"JSComponentName\"); // config.json配置文件中module.js.name的标签值。 super.onStart(intent); }} 说明 需在super.onStart(Intent)前调用此接口。 JS FA开发目录 新建工程的JS目录如下图所示。 在工程目录中：i18n下存放多语言的json文件；pages文件夹下存放多个页面，每个页面由hml、css和js文件组成。 main > js > default > i18n > en-US.json： 此文件定义了在英文模式下页面显示的变量内容。同理，zh-CN.json中定义了中文模式下的页面内容。 { \"strings\": { \"hello\": \"Hello\", \"world\": \"World\" }} main > js > default > pages > index > index.hml： 此文件定义了index页面的布局、index页面中用到的组件，以及这些组件的层级关系。例如：index.hml文件中包含了一个text组件，内容为 “Hello World” 文本。 strings.hello main > js > default > pages > index > index.css： 此文件定义了index页面的样式。例如：index.css文件定义了 “container” 和 “title” 的样式。 .container { flex-direction: column; justify-content: center; align-items: center;}.title { font-size: 100px;} main > js > default > pages > index > index.js： 此文件定义了index页面的业务逻辑，比如数据绑定、事件处理等。例如：变量 “title” 赋值为字符串 “World” 。 export default { data: { title: '', }, onInit() { this.title = this.$t('strings.world'); }, } "},"js-fa-developing.html":{"url":"js-fa-developing.html","title":"开发一个JS FA应用","keywords":"","body":"开发一个JS FA应用 本章节主要介绍如何开发一个JS FA应用。此应用相对于上一节的Hello World应用模板具备更复杂的页面布局、页面样式和页面逻辑。该应用通过media query同时适配了手机和TV，通过点击或者将焦点移动到食物的缩略图来选择不同的食物图片，也可以进行添加到购物车操作，应用效果图如下。 图1 手机应用效果图 图2 TV应用效果图 构建页面布局 开发者在index.hml文件中构建页面布局。在进行代码开发之前，首先要对页面布局进行分析，将页面分解为不同的部分，用容器组件来承载。根据JS FA应用效果图，此页面一共分成三个部分：标题区、展示区和详情区。值得关注的是，展示区和详情区在手机和TV上分别是按列排列和按行排列。 标题区较为简单，由两个按列排列的text组件构成。展示区由包含了四个image组件的swiper组件构成，详情区由image组件和text组件构成，具体构成如下（以手机效果图为例）： 图3 展示区和详情区布局 根据布局结构的分析，实现页面基础布局的代码示例如下（其中四个image组件是通过for指令来循环创建）： Food Choose What You Like {{descriptionFirstParagraph}} {{cartText}} 说明 swiper组件里展示的图片需要开发者自行添加图片资源，放置到“js > default > common”目录下，common目录需自行创建，详细的目录结构见目录结构。 构建页面样式 index.css文件中通过media query管控手机和TV不同页面样式，具体用法可参考媒体查询。此外，该页面样式还采用了css伪类的写法，当点击时或者焦点移动到image组件上，image组件由半透明变成不透明，以此来实现选中的效果。 .container { flex-direction: column;}/* tv */@media screen and (device-type: tv) { .title { align-items:flex-start; flex-direction: column; padding-left: 60px; padding-right: 160px; margin-top:15px; } .name { font-size: 20px; } .sub-title { font-size: 15px; color: #7a787d; margin-top: 10px; } .swiper-style { height: 300px; width: 350px; indicator-color: #4682b4; indicator-selected-color: #f0e68c; indicator-size: 10px; margin-left: 50px; } .image-mode { object-fit: contain; } .selection-bar { flex-direction: row; align-content: center; margin-top: 20px; margin-left: 10px; } .option-mode { height: 40px; width: 40px; margin-left: 50px; opacity: 0.5; border-radius: 20px; } .option-mode:focus { opacity: 1; } .description-first-paragraph { padding-left: 60px; padding-right: 60px; padding-top: 30px; } .description { color: #7a787d; font-size: 15px; } .cart { padding-left: 60px; margin-top: 30px; } .cart-text { font-size: 20px; text-align: center; width: 300px; height: 50px; background-color: #6495ed; color: white; } .cart-text-focus { font-size: 20px; text-align: center; width: 300px; height: 50px; background-color: #4169e1; color: white; } .add-cart-text { font-size: 20px; text-align: center; width: 300px; height: 50px; background-color: #ffd700; color: white; }} /* phone */@media screen and (device-type: phone) { .title { align-items:flex-start; flex-direction: column; padding-left: 60px; padding-right: 160px; padding-top: 20px; } .name { font-size: 50px; color: #000000; } .sub-title { font-size: 30px; color: #7a787d; margin-top: 10px; } .display-style { flex-direction: column; align-items:center; } .swiper-style { height: 600px; indicator-color: #4682b4; indicator-selected-color: #ffffff; indicator-size: 20px; margin-top: 15px; } .image-mode { object-fit: contain; } .selection-bar-container { height: 90px; justify-content: center; } .selection-bar { height: 90px; width: 500px; margin-top: 30px; justify-content: center; align-items:center; } .option-mode { object-fit: contain; opacity: 0.5; } .option-mode:active { opacity: 1; } .description { color: #7a787d; } .description-first-paragraph { padding-left: 60px; padding-top: 50px; padding-right: 60px; } .color-column { flex-direction: row; align-content: center; margin-top: 20px; } .color-item { height: 50px; width: 50px; margin-left: 50px; padding-left: 10px; } .cart { justify-content: center; margin-top: 30px; } .cart-text { font-size: 35px; text-align: center; width: 600px; height: 100px; background-color: #6495ed; color: white; } .add-cart-text { font-size: 35px; text-align: center; width: 600px; height: 100px; background-color: #ffd700; color: white; }} 构建页面逻辑 开发者在index.js文件中构建页面逻辑，主要实现的是两个逻辑功能： 当点击时或者焦点移动到不同的缩略图，swiper滑动到相应的图片； 当焦点移动到购物车区时，“Add To Cart”背景颜色从浅蓝变成深蓝，点击后文字变化为“Cart + 1”，背景颜色由深蓝色变成黄色。添加购物车不可重复操作。 逻辑页面代码示例如下： // index.jsexport default { data: { cartText: 'Add To Cart', cartStyle: 'cart-text', isCartEmpty: true, descriptionFirstParagraph: 'This is a food page containing fresh fruits, snacks and etc. You can pick whatever you like and add it to your cart. Your order will arrive within 48 hours. We guarantee that our food is organic and healthy. Feel free to access our 24h online service for more information about our platform and products.', imageList: ['/common/food_000.JPG', '/common/food_001.JPG', '/common/food_002.JPG', '/common/food_003.JPG'], }, swipeToIndex(index) { this.$element('swiperImage').swipeTo({index: index}); }, addCart() { if (this.isCartEmpty) { this.cartText = 'Cart + 1'; this.cartStyle = 'add-cart-text'; this.isCartEmpty = false; } }, getFocus() { if (this.isCartEmpty) { this.cartStyle = 'cart-text-focus'; } }, lostFocus() { if (this.isCartEmpty) { this.cartStyle = 'cart-text'; } },} 配置设备类型 在config.json的\"deviceType\"字段中添加手机和TV的设备类型： { ... \"module\": { ... \"deviceType\": [ \"phone\", \"tv\" ], ... }} 效果示例 实现此实例后，效果示例如下图所示。 图4 手机运行效果 图5 TV运行效果 相关实例 开发一个JS FA应用，有以下示例工程可供参考： JsApp 本示例演示了如何开发一个 JS FA。 JsGallery 本示例为一个仿图库的JS应用，模拟多图片场景，开发者可自行添加或者更换图片资源，构建自己的多图场景。 JsShopping 本示例为一个仿购物类的JS应用，使用了混合的布局，包含图片、视频、文本等资源。 "},"js-building-ui-component.html":{"url":"js-building-ui-component.html","title":"组件介绍","keywords":"","body":"组件介绍 组件（Component）是构建页面的核心，每个组件通过对数据和方法的简单封装，实现独立的可视、可交互功能单元。组件之间相互独立，随取随用，也可以在需求相同的地方重复使用。关于组件的详细参考文档请参见组件。 开发者还可以通过组件间合理的搭配定义满足业务需求的新组件，减少开发量，自定义组件的开发方法请参见自定义组件。 组件分类 根据组件的功能，可以分为以下四大类： 组件类型 主要组件 基础组件 text、image、progress、rating、span、marquee、image-animator、divider、search、menu、chart 容器组件 div、list、list-item、stack、swiper、tabs、tab-bar、tab-content、list-item-group、refresh、dialog 媒体组件 video 画布组件 canvas 相关实例 针对JS组件开发，有以下示例工程可供参考： JsComponents 本示例演示了如何使用JS基础组件开发一个应用界面。 UserRegistration 本示例以用户注册为例，演示JS FA基本控件的使用，包含文本输入框、日期选择控件、单选按钮、下拉菜单和普通按钮等。 针对JS组件开发，有以下Codelabs可供参考： JS组件购物应用演示 使用JS实现一款简单的HarmonyOS购物应用。 "},"js-building-ui-layout-intro.html":{"url":"js-building-ui-layout-intro.html","title":"布局说明","keywords":"","body":"布局说明 JS UI框架中手机和智慧屏以720px（px指逻辑像素，非物理像素）为基准宽度，根据实际屏幕宽度进行缩放，例如当width设为100px时，在宽度为1440物理像素的屏幕上，实际显示的宽度为200物理像素。智能穿戴的基准宽度为454px，换算逻辑同理。 一个页面的基本元素包含标题区域、文本区域、图片区域等，每个基本元素内还可以包含多个子元素，开发者根据需求还可以添加按钮、开关、进度条等组件。在构建页面布局时，需要对每个基本元素思考以下几个问题： 该元素的尺寸和排列位置 是否有重叠的元素 是否需要设置对齐、内间距或者边界 是否包含子元素及其排列位置 是否需要容器组件及其类型 将页面中的元素分解之后再对每个基本元素按顺序实现，可以减少多层嵌套造成的视觉混乱和逻辑混乱，提高代码的可读性，方便对页面做后续的调整。以下图为例进行分解： 图1 页面布局分解 图2 留言区布局分解 "},"js-building-ui-layout-text.html":{"url":"js-building-ui-layout-text.html","title":"添加标题行和文本区域","keywords":"","body":"添加标题行和文本区域 实现标题和文本区域最常用的是基础组件text。text组件用于展示文本，可以设置不同的属性和样式，文本内容需要写在标签内容区，完整属性和样式信息请参考text。在页面中插入标题和文本区域的示例如下： {{headTitle}} {{paragraphFirst}} {{paragraphSecond}} /* xxx.css */.container { flex-direction: column; margin-top: 20px; margin-left: 30px;}.title-text { color: #1a1a1a; font-size: 50px; margin-top: 40px; margin-bottom: 20px;}.paragraph-text { color: #000000; font-size: 35px; line-height: 60px;} // xxx.jsexport default { data: { headTitle: 'Capture the Beauty in This Moment', paragraphFirst: 'Capture the beauty of light during the transition and fusion of ice and water. At the instant of movement and stillness, softness and rigidity, force and beauty, condensing moving moments.', paragraphSecond: 'Reflecting the purity of nature, the innovative design upgrades your visual entertainment and ergonomic comfort. Effortlessly capture what you see and let it speak for what you feel.', },} "},"js-building-ui-layout-image.html":{"url":"js-building-ui-layout-image.html","title":"添加图片区域","keywords":"","body":"添加图片区域 添加图片区域通常用image组件来实现，使用的方法和text组件类似。 图片资源建议放在“js > default > common”目录下，common目录需自行创建，详细的目录结构见目录结构。代码示例如下： /* xxx.css */.img { margin-top: 30px; margin-bottom: 30px; height: 385px;} // xxx.jsexport default { data: { middleImage: '/common/ice.png', },} "},"js-building-ui-layout-comment.html":{"url":"js-building-ui-layout-comment.html","title":"添加留言区域","keywords":"","body":"添加留言区域 留言框的功能为：用户输入留言后点击完成，留言区域即显示留言内容；用户点击右侧的删除按钮可删除当前留言内容并重新输入。 留言区域由div、text、input关联click事件实现。开发者可以使用input组件实现输入留言的部分，使用text组件实现留言完成部分，使用commentText的状态标记此时显示的组件（通过if属性控制）。在包含文本“完成”和“删除”的text组件中关联click事件，更新commentText状态和inputValue的内容。具体的实现示例如下： Comment Done {{inputValue}} Delete /* xxx.css */.container { margin-top: 24px; background-color: #ffffff;}.comment-title { font-size: 40px; color: #1a1a1a; font-weight: bold; margin-top: 40px; margin-bottom: 10px;}.comment { width: 550px; height: 100px; background-color: lightgrey;}.comment-key { width: 150px; height: 100px; margin-left: 20px; font-size: 32px; color: #1a1a1a; font-weight: bold;}.comment-key:focus { color: #007dff;}.comment-text { width: 550px; height: 100px; text-align: left; line-height: 35px; font-size: 30px; color: #000000; border-bottom-color: #bcbcbc; border-bottom-width: 0.5px;} // xxx.jsexport default { data: { inputValue: '', commentText: false, }, update() { this.commentText = !this.commentText; }, updateValue(e) { this.inputValue = e.text; },} "},"js-building-ui-layout-external-container.html":{"url":"js-building-ui-layout-external-container.html","title":"添加容器","keywords":"","body":"添加容器 要将页面的基本元素组装在一起，需要使用容器组件。在页面布局中常用到三种容器组件，分别是div、list和tabs。在页面结构相对简单时，可以直接用div作为容器，因为div作为单纯的布局容器，可以支持多种子组件，使用起来更为方便。 List组件 当页面结构较为复杂时，如果使用div循环渲染，容易出现卡顿，因此推荐使用list组件代替div组件实现长列表布局，从而实现更加流畅的列表滚动体验。需要注意的是，list仅支持list-item作为子组件，具体的使用示例如下： {{$item.value}} /* xxx.css */.desc-text { width: 683.3px; font-size: 35.4px;} // xxx.jsexport default { data: { textList: [{value: 'JS FA'}], },} 为避免示例代码过长，以上示例的list中只包含一个list-item，list-item中只有一个text组件。在实际应用中可以在list中加入多个list-item，同时list-item下可以包含多个其他子组件。 Tabs组件 当页面经常需要动态加载时，推荐使用tabs组件。tabs组件支持change事件，在页签切换后触发。tabs组件仅支持一个tab-bar和一个tab-content。具体的使用示例如下： Home Index Detail // xxx.jsexport default { data: { homeImage: '/common/home.png', indexImage: '/common/index.png', detailImage: '/common/detail.png', },} tab-content组件用来展示页签的内容区，高度默认充满tabs剩余空间。tab-content支持scrollable属性，详见tab-content。 "},"js-building-ui-interactions.html":{"url":"js-building-ui-interactions.html","title":"添加交互","keywords":"","body":"添加交互 添加交互可以通过在组件上关联事件实现。本节将介绍如何用div、text、image组件关联click事件，构建一个如下图所示的点赞按钮。 图1 点赞按钮效果 点赞按钮通过一个div组件关联click事件实现。div组件包含一个image组件和一个text组件： image组件用于显示未点赞和点赞的效果。click事件函数会交替更新点赞和未点赞图片的路径。 text组件用于显示点赞数，点赞数会在click事件的函数中同步更新。 click事件作为一个函数定义在js文件中，可以更改isPressed的状态，从而更新显示的image组件。如果isPressed为真，则点赞数加1。该函数在hml文件中对应的div组件上生效，点赞按钮各子组件的样式设置在css文件当中。具体的实现示例如下： {{total}} /* xxx.css */.like { width: 104px; height: 54px; border: 2px solid #bcbcbc; justify-content: space-between; align-items: center; margin-left: 72px; border-radius: 8px;}.like-img { width: 33px; height: 33px; margin-left: 14px;}.like-num { color: #bcbcbc; font-size: 20px; margin-right: 17px;} // xxx.jsexport default { data: { likeImage: '/common/unLike.png', isPressed: false, total: 20, }, likeClick() { var temp; if (!this.isPressed) { temp = this.total + 1; this.likeImage = '/common/like.png'; } else { temp = this.total - 1; this.likeImage = '/common/unLike.png'; } this.total = temp; this.isPressed = !this.isPressed; },} JS UI框架还提供了很多表单组件，例如开关、标签、滑动选择器等，以便于开发者在页面布局时灵活使用和提高交互性，详见容器组件。 "},"js-building-ui-animation.html":{"url":"js-building-ui-animation.html","title":"动画","keywords":"","body":"动画 动画分为静态动画和连续动画。 静态动画 静态动画的核心是transform样式，主要可以实现以下三种变换类型，一次样式设置只能实现一种类型变换。 translate：沿水平或垂直方向将指定组件移动所需距离。 scale：横向或纵向将指定组件缩小或放大到所需比例。 rotate：将指定组件沿横轴或纵轴或中心点旋转指定的角度。 具体的使用示例如下，更多信息请参考组件方法。 hello hello hello /* xxx.css */.container { flex-direction: column; align-items: center;}.translate { height: 150px; width: 300px; font-size: 50px; background-color: #008000; transform: translate(200px);}.rotate { height: 150px; width: 300px; font-size: 50px; background-color: #008000; transform-origin: 200px 100px; transform: rotateX(45deg);}.scale { height: 150px; width: 300px; font-size: 50px; background-color: #008000; transform: scaleX(1.5);} 图1 静态动画效果图 连续动画 静态动画只有开始状态和结束状态，没有中间状态，如果需要设置中间的过渡状态和转换效果，需要使用连续动画实现。 连续动画的核心是animation样式，它定义了动画的开始状态、结束状态以及时间和速度的变化曲线。通过animation样式可以实现的效果有： animation-name：设置动画执行后应用到组件上的背景颜色、透明度、宽高和变换类型。 animation-delay和animation-duration：分别设置动画执行后元素延迟和持续的时间。 animation-timing-function：描述动画执行的速度曲线，使动画更加平滑。 animation-iteration-count：定义动画播放的次数。 animation-fill-mode：指定动画执行结束后是否恢复初始状态。 animation样式需要在css文件中先定义keyframe，在keyframe中设置动画的过渡效果，并通过一个样式类型在hml文件中调用。animation-name的使用示例如下： animation-name color opacity /* xxx.css */.item-container { margin-right: 60px; margin-left: 60px; flex-direction: column;}.header { margin-bottom: 20px;}.item { background-color: #f76160;}.txt { text-align: center; width: 200px; height: 100px;}.button { width: 200px; font-size: 30px; background-color: #09ba07;}.color { animation-name: Color; animation-duration: 8000ms;}.opacity { animation-name: Opacity; animation-duration: 8000ms;}@keyframes Color { from { background-color: #f76160; } to { background-color: #09ba07; }}@keyframes Opacity { from { opacity: 0.9; } to { opacity: 0.1; }} // xxx.jsexport default { data: { colorParam: '', opacityParam: '', }, showAnimation: function () { this.colorParam = ''; this.opacityParam = ''; this.colorParam = 'color'; this.opacityParam = 'opacity'; },} 图2 连续动画效果图 相关实例 针对动画开发，有以下示例工程可供参考： JsAnimation 本示例演示了组件动效的基础能力，包含组件的旋转、平移、显隐切换，以及组件阴影等，其中动效负载可调节。 Image 本示例演示了JS FA中图片组件常见的几种动画效果，例如：缩放、旋转、平移、渐变等。 "},"js-building-ui-event.html":{"url":"js-building-ui-event.html","title":"事件","keywords":"","body":"事件 事件主要为手势事件和按键事件。手势事件主要用于智能穿戴等具有触摸屏的设备，按键事件主要用于智慧屏设备。 手势事件 手势表示由单个或多个事件识别的语义动作（例如：点击、拖动和长按）。一个完整的手势也可能由多个事件组成，对应手势的生命周期。JS UI框架支持的手势事件有： 触摸 touchstart：手指触摸动作开始。 touchmove：手指触摸后移动。 touchcancel：手指触摸动作被打断，如来电提醒、弹窗。 touchend：手指触摸动作结束。 点击 click：用户快速轻敲屏幕。 长按 longpress：用户在相同位置长时间保持与屏幕接触。 具体的使用示例如下： {{onClick}} {{touchstart}} {{touchmove}} {{touchend}} {{touchcancel}} {{onLongPress}} /* xxx.css */.container { flex-direction: column; justify-content: center; align-items: center;}.text-container { margin-top: 10px; flex-direction: column; width: 750px; height: 50px; background-color: #09ba07;}.text-style { width: 100%; line-height: 50px; text-align: center; font-size: 24px; color: #ffffff;} // xxx.jsexport default { data: { touchstart: 'touchstart', touchmove: 'touchmove', touchend: 'touchend', touchcancel: 'touchcancel', onClick: 'onclick', onLongPress: 'onlongpress', }, touchCancel: function (event) { this.touchcancel = 'canceled'; }, touchEnd: function(event) { this.touchend = 'ended'; }, touchMove: function(event) { this.touchmove = 'moved'; }, touchStart: function(event) { this.touchstart = 'touched'; }, longPress: function() { this.onLongPress = 'longpressed'; }, click: function() { this.onClick = 'clicked'; },} 按键事件 按键事件是智慧屏上特有的手势事件，当用户操作遥控器按键时触发。用户点击一个遥控器按键，通常会触发两次key事件：先触发action为0，再触发action为1，即先触发按下事件，再触发抬起事件。action为2的场景比较少见，一般为用户按下按键且不松开，此时repeatCount将返回次数。每个物理按键对应各自的按键值（keycode）以实现不同的功能，常用的按键值请参考组件通用事件。具体的使用示例如下： {{up}} {{down}} /* xxx.css */.card-box { flex-direction: column; justify-content: center;}.content-box { align-items: center; height: 200px; flex-direction: column; margin-left: 200px; margin-right: 200px;}.content-text { font-size: 40px; text-align: center;} // xxx.jsexport default { data: { up: 'up', down: 'down', }, focusUp: function() { this.up = 'up focused'; }, blurUp: function() { this.up = 'up'; }, keyUp: function() { this.up = 'up keyed'; }, focusDown: function() { this.down = 'down focused'; }, blurDown: function() { this.down = 'down'; }, keyDown: function() { this.down = 'down keyed'; },} 按键事件通过获焦事件向下分发，因此示例中使用了focus事件和blur事件明确当前焦点的位置。点按上下键选中up或down按键，即相应的focused状态，失去焦点的按键恢复正常的up或down按键文本。按确认键后该按键变为keyed状态。 "},"js-building-ui-routes.html":{"url":"js-building-ui-routes.html","title":"页面路由","keywords":"","body":"页面路由 很多应用由多个页面组成，比如用户可以从音乐列表页面点击歌曲，跳转到该歌曲的播放界面。开发者需要通过页面路由将这些页面串联起来，按需实现跳转。 页面路由router根据页面的uri来找到目标页面，从而实现跳转。以最基础的两个页面之间的跳转为例，具体实现步骤如下： 在“Project”窗口，打开“entry > src > main > js > default”，右键点击“pages”文件夹，选择“New > JS Page”，创建一个详情页。 调用router.push()路由到详情页。 调用router.back()回到首页。 构建页面布局 index和detail这两个页面均包含一个text组件和button组件：text组件用来指明当前页面，button组件用来实现两个页面之间的相互跳转。hml文件代码示例如下： This is the index page. This is the detail page. 构建页面样式 构建index和detail页面的页面样式，text组件和button组件居中显示，两个组件之间间距为50px。css代码如下（两个页面样式代码一致）： /* index.css *//* detail.css */.container { flex-direction: column; justify-content: center; align-items: center;} .title { font-size: 50px; margin-bottom: 50px;} 实现跳转 为了使button组件的launch方法生效，需要在页面的js文件中实现跳转逻辑。调用router.push()接口将uri指定的页面添加到路由栈中，即跳转到uri指定的页面。在调用router方法之前，需要导入router模块。代码示例如下： // index.jsimport router from '@system.router';export default { launch() { router.push ({ uri: 'pages/detail/detail', }); },} // detail.jsimport router from '@system.router';export default { launch() { router.back(); },} 运行效果如下图所示： 图1 页面路由效果 "},"js-building-ui-focus.html":{"url":"js-building-ui-focus.html","title":"焦点逻辑","keywords":"","body":"焦点逻辑 焦点移动是智慧屏的主要交互方式，本节将介绍焦点逻辑的主要规则。 容器组件焦点分发逻辑 ： 容器组件在第一次获焦时焦点一般都落在第一个可获焦的子组件上，再次获焦时焦点落在上一次失去焦点时获焦的子组件上。容器组件一般都有特定的焦点分发逻辑，以下分别说明常用容器组件的焦点分发逻辑。 div组件通过按键移动获焦时，焦点会移动到在移动方向上与当前获焦组件布局中心距离最近的可获焦叶子节点上。如 图1 中焦点在上方的横向div的第二个子组件上，当点击down按键时，焦点要移动到下方的横向div中。这时下方的横向div中的子组件会与当前焦点所在的子组件进行布局中心距离的计算，其中距离最近的子组件获焦。 图1 div焦点移动时距离计算示例 list组件包含list-item与list-item-group，list组件每次获焦时会使第一个可获焦的item获焦。list-item-group为特殊的list-item，且两者都与div的焦点逻辑相同。 stack组件只能由自顶而下的第一个可获焦的子组件获焦。 swiper的每个页面和refresh的页面的焦点逻辑都与div的相同。 tabs组件包含tab-bar与tab-content，tab-bar中的子组件默认都能获焦，与是否有可获焦的叶子结点无关。tab-bar与tab-content的每个页面都与div的焦点逻辑相同。 dialog的button可获焦，若有多个button，默认初始焦点落在第二个button上。 popup无法获焦。 focusable属性使用 通用属性focusable主要用于控制组件能否获焦，本身不支持焦点的组件在设置此属性后可以拥有获取焦点的能力。如text组件本身不能获焦，焦点无法移动到它上面，设置text的focusable属性为true后，text组件便可以获焦。特别的是，如果在没有使用focusable属性的情况下，使用了focus，blur或key事件，会默认添加focusable属性为true。 容器组件是否可获焦依赖于是否拥有可获焦的子组件。如果容器组件内没有可以获焦的子组件，即使设置了focusable为true，依然不能获焦。当容器组件focusable属性设置为false，则它本身和它所包含的所有组件都不可获焦。 "},"js-custom-components.html":{"url":"js-custom-components.html","title":"自定义组件","keywords":"","body":"自定义组件 JS UI框架支持自定义组件，用户可根据业务需求将已有的组件进行扩展，增加自定义的私有属性和事件，封装成新的组件，方便在工程中多次调用，提高页面布局代码的可读性。具体的封装方法示例如下： 构建自定义组件 点击这里查看隐藏文本 hello world /* comp.css */ .item { width: 700px; flex-direction: column; height: 300px; align-items: center; margin-top: 100px; } .text-style { width: 100%; text-align: center; font-weight: 500; font-family: Courier; font-size: 36px; } .title-style { font-weight: 500; font-family: Courier; font-size: 50px; color: #483d8b; } // comp.js export default { props: { title: { default: 'title', }, showObject: {}, }, data() { return { showObj: this.showObject, }; }, childClicked () { this.$emit('eventType1', {text: '收到子组件参数'}); this.showObj = !this.showObj; }, } 引入自定义组件 父组件： /* xxx.css */ .container { background-color: #f8f8ff; flex: 1; flex-direction: column; align-content: center; } // xxx.js export default { data: { text: '开始', isShow: false, }, textClicked (e) { this.text = e.detail.text; }, } 本示例中父组件通过添加自定义属性向子组件传递了名称为title的参数，子组件在props中接收。同时子组件也通过事件绑定向上传递了参数text，接收时通过e.detail获取。要绑定子组件事件，父组件事件命名必须遵循事件绑定规则，详见自定义组件开发规范。自定义组件效果如下图所示： 图1 自定义组件的效果 "},"js-fa-call-pa.html":{"url":"js-fa-call-pa.html","title":"JS FA如何调用PA","keywords":"","body":"JS FA如何调用PA JS UI框架提供了JS FA（Feature Ability）调用Java PA（Particle Ability）的机制，该机制提供了一种通道来传递方法调用、处理数据返回以及订阅事件上报。 当前提供Ability和Internal Ability两种调用方式，开发者可以根据业务场景选择合适的调用方式进行开发。 Ability：拥有独立的Ability生命周期，FA使用远端进程通信拉起并请求PA服务，适用于基本服务供多FA调用或者服务在后台独立运行的场景。 Internal Ability：与FA共进程，采用内部函数调用的方式和FA进行通信，适用于对服务响应时延要求较高的场景。该方式下PA不支持其他FA访问调用。 JS端与Java端通过bundleName和abilityName来进行关联。在系统收到JS调用请求后，根据开发者在JS接口中设置的参数来选择对应的处理方式。开发者在onRemoteRequest()中实现PA提供的业务逻辑。详细信息请参考JS FA调用Java PA机制。 FA调用PA接口 FA端提供以下三个JS接口： FeatureAbility.callAbility(OBJECT)：调用PA能力。 FeatureAbility.subscribeAbilityEvent(OBJECT, Function)：订阅PA能力。 FeatureAbility.unsubscribeAbilityEvent(OBJECT)：取消订阅PA能力。 PA端提供以下两类接口： IRemoteObject.onRemoteRequest(int, MessageParcel, MessageParcel, MessageOption)：Ability调用方式，FA使用远端进程通信拉起并请求PA服务。 AceInternalAbility.AceInternalAbilityHandler.onRemoteRequest(int, MessageParcel, MessageParcel, MessageOption)：Internal Ability调用方式，采用内部函数调用的方式和FA进行通信。 FA调用PA常见问题 callAbility返回报错：\"Internal ability not register.\" 返回该错误说明JS接口调用请求未在系统中找到对应的InternalAbilityHandler进行处理，因此需要检查以下几点是否正确执行： 在AceAbility继承类中对AceInternalAbility继承类执行了register方法，具体注册可参考Internal Ability的示例代码。 JS侧填写的bundleName和abilityName与AceInternalAbility继承类构造函数中填写的名称保持相同，大小写敏感。 检查JS端填写的abilityType（0：Ability; 1：Internal Ability），确保没有将AbilityType缺省或误填写为Ability方式。 Ability和Internal Ability是两种不同的FA调用PA的方式。表1列举了在开发时各方面的差异，供开发者参考，避免开发时将两者混淆使用： 差异项 Ability InternalAbility JS端（abilityType） 0 1 是否需要在config.json的abilities中为PA添加声明 需要（有独立的生命周期） 不需要（和FA共生命周期） 是否需要在FA中注册 不需要 需要 继承的类 ohos.aafwk.ability.Ability ohos.ace.ability.AceInternalAbility 是否允许被其他FA访问调用 是 否 FeatureAbility.callAbility中syncOption参数说明： 对于JS FA侧，返回的结果都是Promise对象，因此无论该参数取何值，都采用异步方式等待PA侧响应。 对于JAVA PA侧，在Internal Ability方式下收到FA的请求后，根据该参数的取值来选择：通过同步的方式获取结果后返回；或者异步执行PA逻辑，获取结果后使用remoteObject.sendRequest的方式将结果返回FA。 使用await方式调用时IDE编译报错，需引入babel-runtime/regenerator，具体请参见接口通用规则。 示例参考 JS端调用FeatureAbility接口，传入两个Number参数，Java端接收后返回两个数的和。 FA JavaScript端 使用Internal Ability方式时，需要将对应的action.abilityType值改为ABILITY_TYPE_INTERNAL。 // abilityType: 0-Ability; 1-Internal Abilityconst ABILITY_TYPE_EXTERNAL = 0;const ABILITY_TYPE_INTERNAL = 1;// syncOption(Optional, default sync): 0-Sync; 1-Asyncconst ACTION_SYNC = 0;const ACTION_ASYNC = 1;const ACTION_MESSAGE_CODE_PLUS = 1001;export default { plus: async function() { var actionData = {}; actionData.firstNum = 1024; actionData.secondNum = 2048; var action = {}; action.bundleName = 'com.example.hiaceservice'; action.abilityName = 'com.example.hiaceservice.ComputeServiceAbility'; action.messageCode = ACTION_MESSAGE_CODE_PLUS; action.data = actionData; action.abilityType = ABILITY_TYPE_EXTERNAL; action.syncOption = ACTION_SYNC; var result = await FeatureAbility.callAbility(action); var ret = JSON.parse(result); if (ret.code == 0) { console.info('plus result is:' + JSON.stringify(ret.abilityResult)); } else { console.error('plus error code:' + JSON.stringify(ret.code)); } }} PA端（Ability方式） 功能代码实现： 在java目录下新建一个Service Ability，文件命名为ComputeServiceAbility.java package com.example.hiaceservice; // ohos相关接口包import ohos.aafwk.ability.Ability;import ohos.aafwk.content.Intent;import ohos.hiviewdfx.HiLog;import ohos.hiviewdfx.HiLogLabel;import ohos.rpc.IRemoteBroker;import ohos.rpc.IRemoteObject;import ohos.rpc.RemoteObject;import ohos.rpc.MessageParcel;import ohos.rpc.MessageOption;import ohos.utils.zson.ZSONObject; import java.util.HashMap;import java.util.Map; public class ComputeServiceAbility extends Ability { // 定义日志标签 private static final HiLogLabel LABEL = new HiLogLabel(HiLog.LOG_APP, 0, \"MY_TAG\"); private MyRemote remote = new MyRemote(); // FA在请求PA服务时会调用Ability.connectAbility连接PA，连接成功后，需要在onConnect返回一个remote对象，供FA向PA发送消息 @Override protected IRemoteObject onConnect(Intent intent) { super.onConnect(intent); return remote.asObject(); } class MyRemote extends RemoteObject implements IRemoteBroker { private static final int SUCCESS = 0; private static final int ERROR = 1; private static final int PLUS = 1001; MyRemote() { super(\"MyService_MyRemote\"); } @Override public boolean onRemoteRequest(int code, MessageParcel data, MessageParcel reply, MessageOption option) { switch (code) { case PLUS: { String dataStr = data.readString(); RequestParam param = new RequestParam(); try { param = ZSONObject.stringToClass(dataStr, RequestParam.class); } catch (RuntimeException e) { HiLog.error(LABEL, \"convert failed.\"); } // 返回结果当前仅支持String，对于复杂结构可以序列化为ZSON字符串上报 Map result = new HashMap(); result.put(\"code\", SUCCESS); result.put(\"abilityResult\", param.getFirstNum() + param.getSecondNum()); reply.writeString(ZSONObject.toZSONString(result)); break; } default: { Map result = new HashMap(); result.put(\"abilityError\", ERROR); reply.writeString(ZSONObject.toZSONString(result)); return false; } } return true; } @Override public IRemoteObject asObject() { return this; } }} 请求参数代码： RequestParam.java public class RequestParam { private int firstNum; private int secondNum; public int getFirstNum() { return firstNum; } public void setFirstNum(int firstNum) { this.firstNum = firstNum; } public int getSecondNum() { return secondNum; } public void setSecondNum(int secondNum) { this.secondNum = secondNum; }} PA端（Internal Ability方式） 功能代码实现： 在java目录下新建一个Service Ability，文件命名为ComputeInternalAbility.java package com.example.hiaceservice; // ohos相关接口包import ohos.ace.ability.AceInternalAbility;import ohos.app.AbilityContext;import ohos.hiviewdfx.HiLog;import ohos.hiviewdfx.HiLogLabel;import ohos.rpc.IRemoteObject;import ohos.rpc.MessageOption;import ohos.rpc.MessageParcel;import ohos.rpc.RemoteException;import ohos.utils.zson.ZSONObject; import java.util.HashMap;import java.util.Map; public class ComputeInternalAbility extends AceInternalAbility { private static final String BUNDLE_NAME = \"com.example.hiaceservice\"; private static final String ABILITY_NAME = \"com.example.hiaceservice.ComputeInternalAbility\"; private static final int SUCCESS = 0; private static final int ERROR = 1; private static final int PLUS = 1001; // 定义日志标签 private static final HiLogLabel LABEL = new HiLogLabel(HiLog.LOG_APP, 0, \"MY_TAG\"); private static ComputeInternalAbility instance; private AbilityContext abilityContext; // 如果多个Ability实例都需要注册当前InternalAbility实例，需要更改构造函数，设定自己的bundleName和abilityName public ComputeInternalAbility() { super(BUNDLE_NAME, ABILITY_NAME); } public boolean onRemoteRequest(int code, MessageParcel data, MessageParcel reply, MessageOption option) { switch (code) { case PLUS: { String dataStr = data.readString(); RequestParam param = new RequestParam(); try { param = ZSONObject.stringToClass(dataStr, RequestParam.class); } catch (RuntimeException e) { HiLog.error(LABEL, \"convert failed.\"); } // 返回结果当前仅支持String，对于复杂结构可以序列化为ZSON字符串上报 Map result = new HashMap(); result.put(\"code\", SUCCESS); result.put(\"abilityResult\", param.getFirstNum() + param.getSecondNum()); // SYNC if (option.getFlags() == MessageOption.TF_SYNC) { reply.writeString(ZSONObject.toZSONString(result)); } else { // ASYNC MessageParcel responseData = MessageParcel.obtain(); responseData.writeString(ZSONObject.toZSONString(result)); IRemoteObject remoteReply = reply.readRemoteObject(); try { remoteReply.sendRequest(0, responseData, MessageParcel.obtain(), new MessageOption()); } catch (RemoteException exception) { return false; } finally { responseData.reclaim(); } } break; } default: { Map result = new HashMap(); result.put(\"abilityError\", ERROR); reply.writeString(ZSONObject.toZSONString(result)); return false; } } return true; } /** * Internal ability 注册接口。 */ public static void register(AbilityContext abilityContext) { instance = new ComputeInternalAbility(); instance.onRegister(abilityContext); } private void onRegister(AbilityContext abilityContext) { this.abilityContext = abilityContext; this.setInternalAbilityHandler((code, data, reply, option) -> { return this.onRemoteRequest(code, data, reply, option); }); } /** * Internal ability 注销接口。 */ public static void unregister() { instance.onUnregister(); } private void onUnregister() { abilityContext = null; this.setInternalAbilityHandler(null); }} Internal Ability注册：修改继承AceAbility工程中的代码 public class MainAbility extends AceAbility { @Override public void onStart(Intent intent) { // 注册, 如果需要在Page初始化(onInit或之前)时调用AceInternalAbility的能力，注册操作需要在super.onStart之前进行 ComputeInternalAbility.register(this); ... super.onStart(intent); } @Override public void onStop() { // 注销 ComputeInternalAbility.unregister(); super.onStop(); }} 相关实例 针对JS FA如何调用PA，有以下示例工程可供参考： JsCallJava 本示例以JS端调用Java端实时获取电池电量为例，帮助开发者了解JS FA调用Java PA的机制。 "},"multimodal-overview.html":{"url":"multimodal-overview.html","title":"多模输入开发概述","keywords":"","body":"多模输入开发概述 HarmonyOS旨在为开发者提供NUI（Natural User Interface）的交互方式。有别于传统操作系统的输入划分方式，在HarmonyOS上，我们将多种维度的输入整合在一起，开发者可以借助应用程序框架、系统自带的UI组件或API接口轻松地实现具有多维、自然交互特点的应用程序。 具体来说，HarmonyOS目前不仅支持传统的输入交互方式，例如按键、触控、键盘、鼠标等，同时提供多模输入融合框架，可以支持语音等新型的输入交互方式。 约束与限制 多模输入事件在不同形态产品支持的情况如下表。 | 多模输入事件 | 手机 | 平板 | 智慧屏 | 车机 | 智能穿戴 | | ------------ | -------- | -------- | -------- | ------ | -------- | | 按键输入事件 | 支持 | 支持 | 支持 | 支持 | 支持 | | 触屏输入事件 | 支持 | 支持 | 支持 | 支持 | 支持 | | 鼠标事件 | 部分支持 | 部分支持 | 部分支持 | 不支持 | 不支持 | | 语音事件 | 不支持 | 不支持 | 支持 | 不支持 | 不支持 | 说明 手机、平板、智慧屏产品对鼠标事件只支持鼠标左键事件，鼠标右键以及滚轮等事件暂不支持。 目前多模输入不支持注入事件（即开发者无法模拟注入事件验证应用程序功能），仅支持KeyEvent事件的生成。 使用多模输入相关功能需要获取多模输入权限：ohos.permission.MULTIMODAL_INTERACTIVE。 多模输入子系统提供多模态输入的融合框架，所融合的输入能力需要对接到输入能力感知模块上。 "},"multimodal-guidelines.html":{"url":"multimodal-guidelines.html","title":"多模输入开发指导","keywords":"","body":"多模输入开发指导 场景介绍 多模输入使用HarmonyOS的UI组件能够响应多种输入事件，事件来源于用户的按键、点击、触屏、语音等，并且提供创建事件能力和获取输入设备信息能力。 接口说明 多模输入提供了多模事件基类（MultimodalEvent），以及其派生的操作事件类（ManipulationEvent）、按键事件类（KeyEvent）、语音事件类（SpeechEvent）等，另外提供创建事件类（EventCreator）和获取输入设备信息类（InputDevice）。 图1 多模输入事件类 MultimodalEvent是所有事件的基类，该类中定义了一系列高级事件类型，这些事件类型通常是对某种行为或意图的抽象。 | 功能分类 | 接口名 | 描述 | | -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | | 设备信息相关 | getDeviceId() | 获取输入设备所在的承载设备id，如当同时有两个鼠标连接到一个机器上，该机器为这两个鼠标的承载设备。 | | getInputDeviceId() | 获取产生当前事件的输入设备id，该id是该输入设备的唯一标识，如两个鼠标同时输入时，它们会分别产生输入事件，且从事件中获取到的deviceid是不同的，开发者可以将此id用来区分实际的输入设备源。 | | | getSourceDevice() | 获取产生当前事件的输入设备类型。 | | | 时间 | getOccurredTime() | 获取产生当前事件的时间。 | | 事件 | getUuid() | 获取事件的UUID。 | | isSameEvent(UUID id) | 判断当前事件与传入id的事件是否为同一事件。 | | CompositeEvent处理常用设备对应的事件，当前只有MouseEvent事件继承该类。 SpeechEvent处理语音事件，开发者可以通过该类获取语音识别结果。 | 功能分类 | 接口名 | 描述 | | ------------------- | ------------------------------------------------------------ | -------------------------------------- | | 构造函数 | Optional createEvent(long occurTime, int action, String value) | SpeechEvent创建函数。 | | 获取语音事件参数值 | getAction() | 获取当前动作，如打开、关闭、命中热词。 | | getScene() | 获取当前动作的场景。 | | | getActionProperty() | 获取动作所携带的属性值。 | | | getMatchMode() | 获取语音识别的模式。 | | ManipulationEvent操作类事件是对手指触摸等事件的抽象。该事件会持有事件发生的位置信息和发生的阶段等信息。通常情况下，该事件主要是作为操作回调接口的入参，开发者通过回调接口捕获及处理事件。回调接口分为操作开始、操作过程和操作结束。例如对于一次手指触控，手指接触屏幕是操作开始，手指在屏幕上移动是操作过程，手指抬起是操作结束。 | 功能分类 | 接口名 | 描述 | | --------------------------------------------- | ------------------------------------------------------------ | ---------------------------------------- | | 手指信息 | getPointerCount() | 获取一次事件中触控或轨迹追踪的指针数量。 | | getPointerId(int index) | 获取一次事件中，指针的唯一标识Id。 | | | setScreenOffset(float offsetX, float offsetY) | 设置相对屏幕坐标原点的偏移位置。 | | | getPointerPosition(int index) | 获取一次事件中触控或轨迹追踪的某个指针相对于偏移位置的坐标。 | | | getPointerScreenPosition(int index) | 获取一次事件中触控或轨迹追踪的某个指针相对屏幕坐标原点的坐标。 | | | getRadius(int index) | 返回指定index手指与屏幕接触的半径值。 | | | getForce(int index) | 获取指定index手指触控的压力值。 | | | 时间 | getStartTime() | 获取操作开始时间。 | | 阶段 | getPhase() | 获取事件所属阶段。 | KeyEvent对所有按键类事件的定义，该类继承MultimodalEvent类，并对按键类事件做了专属的keycode定义以及方法封装。 | 功能分类 | 接口名 | 描述 | | --------------- | --------------------------------------- | ------------------------------- | | KeyCode | getKeyCode() | 获取当前按键类事件的keycode值。 | | getMaxKeyCode() | 获取当前定义的按键事件的最大keycode值。 | | | 按键按下状态 | getKeyDownDuration() | 获取当前按键被按下的持续时长。 | | isKeyDown() | 获取当前按键事件是否是按下状态。 | | TouchEvent处理手指触控相关事件。 | 功能分类 | 接口名 | 描述 | | ---------- | ------------------------ | ------------------ | | 触控行为 | getAction() | 获取当前触摸行为。 | | getIndex() | 获取当前触摸行为的指针。 | | KeyBoardEvent处理键盘类设备的事件。 | 功能分类 | 接口名 | 描述 | | ------------------------------------------------------------ | ------------------------------------------------- | ----------------------------------------------- | | 输入法编辑器 | enableIme() | 启动输入法编辑器。 | | disableIme() | 关闭输入法编辑器。 | | | isHandledByIme() | 判断输入法编辑器是否在使用。 | | | NoncharacterKey行为 | isNoncharacterKeyPressed(int keycode) | 判定输入的单个NoncharacterKey是否处于按下状态。 | | isNoncharacterKeyPressed(int keycode1, int keycode2) | 判定输入的两个NoncharacterKey是否都处于按下状态。 | | | isNoncharacterKeyPressed(int keycode1, int keycode2, int keycode3) | 判定输入的三个NoncharacterKey是否都处于按下状态。 | | | 按键Unicode码 | getUnicode() | 获取按键对应的Unicode码。 | 说明 NoncharacterKey为除了文本可见字符（A-Z，0-9，空格，逗号，句号等）以外的按键码，例如：Ctrl，Alt，Shift等。 MouseEvent处理鼠标的事件。 | 功能分类 | 接口名 | 描述 | | --------------------------------------------- | ---------------------------------- | ---------------------------- | | 鼠标行为 | getAction() | 获取鼠标设备产生事件的行为。 | | 鼠标按键 | getActionButton() | 获取状态发生变化的鼠标按键。 | | getPressedButtons() | 获取所有按下状态的鼠标按键。 | | | 鼠标指针/位置 | getCursor() | 获取鼠标指针的位置。 | | getCursorDelta(int axis) | 获取鼠标指针位置相对上次的变化值。 | | | setCursorOffset(float offsetX, float offsetY) | 设置相对屏幕的偏移位置信息。 | | | 鼠标滚轮 | getScrollingDelta(int axis) | 获取滚轮的滚动值。 | MmiPoint处理在指定坐标系中的坐标。 | 功能分类 | 接口名 | 描述 | | -------------------------------------- | --------------------------------------- | -------------------------------------- | | 构造函数 | MmiPoint(float px, float py) | 创建一个只包含x和y坐标的MmiPoint对象。 | | MmiPoint(float px, float py, float pz) | 创建一个包含x，y和z坐标的MmiPoint对象。 | | | 坐标值 | getX() | 获取x坐标值。 | | getY() | 获取y坐标值。 | | | getZ() | 获取z坐标值。 | | | toString() | 返回包含x、y、z坐标值信息的字符串 | | EventCreator提供创建事件的方法，当前仅提供创建KeyEvent事件的能力。 | 功能分类 | 接口名 | 描述 | | -------- | ------------------------------------------------------------ | --------------------------------------- | | 创建事件 | Optional createKeyEvent(int action, int keyCode) | 根据指定的action和keycode创建KeyEvent。 | InputDevice提供获取承载设备上输入设备信息的方法，当前支持获取所有输入设备的ID。 | 功能分类 | 接口名 | 描述 | | -------- | --------------------- | ------------------------------------------------------------ | | 设备ID | getAllInputDeviceID() | 获取承载设备上所有输入设备的ID，例如承载设备为智慧屏，其中有键盘、鼠标和遥控器作为智慧屏的输入设备，该方法用于获取键盘、鼠标和遥控器的ID。 | 开发步骤 处理按钮事件 参考HarmonyOS的Component的API创建KeyEventListener。 重写实现KeyEventListener类中的onKeyEvent(Component component, KeyEvent event)方法。 开发者根据需要实现按键被按下后的处理逻辑。 private Component.KeyEventListener onKeyEvent = new Component.KeyEventListener() { @Override public boolean onKeyEvent(Component component, KeyEvent keyEvent) { if (keyEvent.isKeyDown()) { ... // 检测到按键被按下，开发者根据需求实现 } int keycode = keyEvent.getKeyCode(); switch (keycode) { case KeyEvent.KEY_DPAD_CENTER: ... // 检测到KEY_DPAD_CENTER被按下，开发者根据需求实现 break; case KeyEvent.KEY_DPAD_LEFT: ... // 检测到KEY_DPAD_LEFT被按下，开发者根据需求实现 break; case KeyEvent.KEY_DPAD_UP: ... // 检测到KEY_DPAD_UP被按下，开发者根据需求实现 break; case KeyEvent.KEY_DPAD_RIGHT: ... // 检测到KEY_DPAD_RIGHT被按下，开发者根据需求实现 break; case KeyEvent.KEY_DPAD_DOWN: ... // 检测到KEY_DPAD_DOWN被按下，开发者根据需求实现 break; default: break; } ... }}; 处理语音事件 使用多模输入的语音事件实现“可见即可说”的效果，简易开发样例参考可见即可说开发指导。 "},"multimodal-standard-event-overview.html":{"url":"multimodal-standard-event-overview.html","title":"多模输入事件标准化概述","keywords":"","body":"多模输入事件标准化概述 概述 随着用户输入的多样化发展，一个应用程序需要响应多种输入事件，以支持用户使用不同的输入设备（方式）与其进行交互（例如使用遥控器、语音等同时操控智慧屏）。同时，开发者针对同一输入动作的处理，存在不同的设计，这就给用户造成了体验上的差异。 多模输入在已支持的输入事件的基础上，将用户常用的一些输入动作定义为一组标准化事件，将不同输入设备的输入事件映射到标准化事件上。使用户在使用多种输入设备操作不同的终端设备或应用时，能够得到统一的体验。 输入事件类型 输入事件，即用户为了控制终端设备，通过输入设备做出的一个或一组输入动作。HarmonyOS的输入系统将事件分为原始事件、基础事件、标准化事件。 原始事件 原始事件，即由输入设备产生的、未经过任何含义转换的输入事件，用于表示用户在输入设备上操作时所做出的原始输入动作。 基础事件 将手指在触屏上操作产生的原始事件定义为基础事件，为了统一体验，简化开发，HarmonyOS输入系统会将其他输入设备的输入事件映射到基础事件上。将每种基础事件进一步细化成为基本交互事件与高级交互事件。 基本交互事件 基本交互事件对应用户在输入设备上的一个输入动作，由输入系统上报，包括：手指触摸屏幕、手指触摸后移动、手指抬起。 高级交互事件 高级交互事件则是多个基本交互事件的组合，包括：单指点击、单指双击、单指长按、单指滑动、单指长按后滑动、双指缩放、双指旋转等。高级交互事件的操作对象是具体的UI控件，需要结合HarmonyOS的UI控件使用。 标准化事件 标准化事件是用于表示用户通用意图的事件，其定义与输入设备的类型无关。标准化事件分为通用标准化事件（CommonEventHandle），媒体类标准化事件（MediaEventHandle）,系统类标准化事件（SystemEventHandle），通话类标准化事件（TelephoneEventHandle）。 通用标准化事件 提供标准公共事件的处理方法。常见事件包括显示菜单、发送、复制、粘贴、剪切、撤销、刷新、启动拖拽、取消、确认、转到上一个或下一个元素、打印和返回。 | 场景 | 方法 | 键盘 | 鼠标 | 遥控器 | 表冠/旋钮 | 耳机 | | -------------------- | ------------------------------------------------------------ | ---------------------------- | ---------------- | -------------- | --------- | --------- | | 显示菜单 | boolean onShowMenu(MultimodalEvent multimodalEvent) | Shift+F10Menu键 | 右键单击 | 菜单键 | 不支持 | 不支持 | | 发送 | boolean onSend(MultimodalEvent multimodalEvent) | Enter | 不支持 | 确认键 | 不支持 | 不支持 | | 复制 | boolean onCopy(MultimodalEvent multimodalEvent) | Ctrl+C | 不支持 | 不支持 | 不支持 | 不支持 | | 粘贴 | boolean onPaste(MultimodalEvent multimodalEvent) | Ctrl+V | 不支持 | 不支持 | 不支持 | 不支持 | | 剪切 | boolean onCut(MultimodalEvent multimodalEvent) | Ctrl+X | 不支持 | 不支持 | 不支持 | 不支持 | | 撤销 | boolean onUndo(MultimodalEvent multimodalEvent) | Ctrl+Z | 不支持 | 不支持 | 不支持 | 不支持 | | 刷新 | boolean onRefresh(MultimodalEvent multimodalEvent) | F5Ctrl+R | 不支持 | 不支持 | 不支持 | 不支持 | | 启动拖拽 | boolean onStartDrag(MultimodalEvent multimodalEvent) | 不支持 | 左键短按 | 不支持 | 不支持 | 不支持 | | 取消 | boolean onCancel(MultimodalEvent multimodalEvent) | Esc | 不支持 | 不支持 | 不支持 | 不支持 | | 确定/进入 | boolean onEnter(MultimodalEvent multimodalEvent) | Enter | 不支持 | 确认键 | 不支持 | 不支持 | | 下一个/上一个 / 翻页 | boolean onPrevious(MultimodalEvent multimodalEvent)/boolean onNext(MultimodalEvent multimodalEvent) | PageUpPageDown上下左右方向键 | 滑动滚轮 | 上下左右方向键 | 旋转表冠 | 双击/三击 | | 打印 | boolean onPrint(MultimodalEvent multimodalEvent) | Ctrl+P | 不支持 | 不支持 | 不支持 | 不支持 | | Back/上一级 | boolean onBack(MultimodalEvent multimodalEvent) | ESC | 某键（中键）单击 | Back键 | 不支持 | 不支持 | 媒体类标准化事件 提供处理标准媒体事件的方法。媒体事件包括播放和暂停。 | 场景 | 方法 | 键盘 | 鼠标 | 遥控器 | 表冠/旋钮 | 耳机 | | ------------------------------------------------------------ | ----------------------------------------------- | ----------- | ------ | ------ | --------- | ---- | | 暂停/播放 | boolean onPlay(MultimodalEvent multimodalEvent) | Space空格键 | 不支持 | 确认键 | 不支持 | 单击 | | boolean onPause(MultimodalEvent multimodalEvent)/boolean onMediaControl(MultimodalEvent multimodalEvent) | | | | | | | 系统类标准化事件 提供处理标准系统事件的方法。标准系统事件包括关闭页面和静音。 | 场景 | 方法 | 键盘 | 鼠标 | 遥控器 | 表冠/旋钮 | 耳机 | | -------- | ---------------------------------------------------- | ------------ | ------ | ------ | --------- | ------ | | 关闭界面 | boolean onClosePage(MultimodalEvent multimodalEvent) | Alt+F4Ctrl+W | 不支持 | 返回键 | 不支持 | 不支持 | | 静音 | boolean onMute(MultimodalEvent multimodalEvent) | 静音键 | 不支持 | 不支持 | 不支持 | 不支持 | 通话类标准化事件 提供处理标准呼叫事件的方法。呼叫事件包括应答、拒绝和挂断呼叫。 | 场景 | 方法 | 键盘 | 鼠标 | 遥控器 | 表冠/旋钮 | 耳机 | | ---- | ------------------------------------------------- | ------ | ------ | ------ | --------- | --------- | | 接听 | boolean onAnswer(MultimodalEvent multimodalEvent) | 不支持 | 不支持 | 不支持 | 不支持 | 单击/长按 | | 拒接 | boolean onRefuse(MultimodalEvent multimodalEvent) | 不支持 | 不支持 | 不支持 | 不支持 | 单击/长按 | | 挂断 | boolean onHangup(MultimodalEvent multimodalEvent) | 不支持 | 不支持 | 不支持 | 不支持 | 单击/长按 | 除了以上标准化事件外，为了提供完整的事件处理能力，多模输入提供按键和触屏事件的回调接口类KeyEventHandle和TouchEventHandle。其处理逻辑为： 在收到按键、触屏等原始输入事件时，会优先判断是否需要映射为通用标准化事件（CommonEventHandle），媒体类标准化事件（MediaEventHandle）,系统类标准化事件（SystemEventHandle），通话类标准化事件（TelephoneEventHandle）。如果注册了以上四种标准化事件中的一种，且原始输入事件满足该标准事件中某一场景，就会执行该标准化事件提供的回调。 如果不需要映射为上述四种标准化事件，则会继续判断是否需要映射为按键标准化事件（KeyEventHandle）和触摸标准化事件（TouchEventHandle）。只要注册了这两种标准化事件，分别执行这两种标准化事件中对应的回调。 如果没有注册标准化事件，或者传统输入事件没有对应的标准化事件，则会由Ability继续分发给传统输入事件。 开发者可以根据自己的需求选择是否使用标准化事件。如果标准化事件不能满足需求时，建议使用Java UI框架提供的监听事件进行开发。 说明 不建议开发者同时使用标准化事件、Java UI框架提供的监听事件进行开发，避免增加开发难度。 "},"multimodal-standard-event-guidelines.html":{"url":"multimodal-standard-event-guidelines.html","title":"多模输入事件标准化开发指导","keywords":"","body":"多模输入事件标准化开发指导 场景介绍 多模输入结合UI框架实现了交互事件映射框架，可将多种输入设备的原始事件自动映射为标准化事件；进一步将标准化事件映射成统一的UI交互功能，实现统一的用户交互体验。 接口说明 多模输入事件标准化提供了标准化基类（StandardizedEventHandle），以及其派生的通用类标准化事件（CommonEventHandle）、媒体类标准化事件（MediaEventHandle）、系统类标准化事件（SystemEventHandle）、通话类标准化事件（TelephoneEventHandle）等，另外提供处理标准化事件的类（MultimodalEventHandle），包括注册和去注册标准化事件。 图1 多模输入事件标准化类 StandardizedEventHandle是所有事件的基类。 CommonEventHandle处理标准公共事件。 | 功能分类 | 接口名 | 描述 | | ---------------------------------------------------- | --------------------------------------------------- | ---------------- | | 事件回调 | boolean onShowMenu(MultimodalEvent multimodalEvent) | 显示菜单时调用。 | | boolean onSend(MultimodalEvent multimodalEvent) | 发送事件发生时调用。 | | | boolean onCopy(MultimodalEvent multimodalEvent) | 发生复制事件时调用。 | | | boolean onPaste(MultimodalEvent multimodalEvent) | 发生粘贴事件时调用。 | | | boolean onCut(MultimodalEvent multimodalEvent) | 发生剪切事件时调用。 | | | boolean onUndo(MultimodalEvent multimodalEvent) | 发生撤销事件时调用。 | | | boolean onRefresh(MultimodalEvent multimodalEvent) | 发生刷新事件时调用。 | | | boolean onStartDrag(MultimodalEvent multimodalEvent) | 启动拖动时调用。 | | | boolean onCancel(MultimodalEvent multimodalEvent) | 发生取消事件时调用。 | | | boolean onEnter(MultimodalEvent multimodalEvent) | 发生确认事件时调用。 | | | boolean onPrevious(MultimodalEvent multimodalEvent) | 发生转到上一个元素的事件时调用。 | | | boolean onNext(MultimodalEvent multimodalEvent) | 发生转到下一个元素的事件时调用。 | | | boolean onBack(MultimodalEvent multimodalEvent) | 返回事件发生时调用。 | | | boolean onPrint(MultimodalEvent multimodalEvent) | 发生打印事件时调用。 | | KeyEventHandle处理标准按键事件。 | 功能分类 | 接口名 | 描述 | | -------- | ----------------------------- | -------------------- | | 事件回调 | boolean onKey(KeyEvent event) | 按键事件发生时调用。 | MediaEventHandle处理标准媒体事件。 | 功能分类 | 接口名 | 描述 | | ------------------------------------------------------- | ----------------------------------------------- | ---------------- | | 事件回调 | boolean onPlay(MultimodalEvent multimodalEvent) | 播放媒体时调用。 | | boolean onPause(MultimodalEvent multimodalEvent) | 暂停播放时调用。 | | | boolean onMediaControl(MultimodalEvent multimodalEvent) | 在媒体控制事件发生时调用，可以播放或暂停。 | | SystemEventHandle处理标准系统事件。 | 功能分类 | 接口名 | 描述 | | ----------------------------------------------- | ---------------------------------------------------- | ------------------ | | 事件回调 | boolean onClosePage(MultimodalEvent multimodalEvent) | 当页面关闭时调用。 | | boolean onMute(MultimodalEvent multimodalEvent) | 音量静音时调用。 | | TelephoneEventHandle处理标准呼叫事件。 | 功能分类 | 接口名 | 描述 | | ----------------------------------------------------------- | ------------------------------------------------- | ---------------- | | 事件回调 | boolean onAnswer(MultimodalEvent multimodalEvent) | 应答呼叫时调用。 | | boolean onRefuse(MultimodalEvent multimodalEvent) | 呼叫被拒绝时调用。 | | | boolean onHangup(MultimodalEvent multimodalEvent) | 挂断呼叫时调用。 | | | boolean onTelephoneControl(MultimodalEvent multimodalEvent) | 呼叫控制事件发生时调用。 | | TouchEventHandle处理标准触摸事件。 | 功能分类 | 接口名 | 描述 | | -------- | --------------------------------- | -------------------- | | 事件回调 | boolean onTouch(TouchEvent event) | 触摸事件发生时调用。 | MultimodalEventHandle处理标准事件的注册和去注册。 | 功能分类 | 接口名 | 描述 | | ---------- | ------------------------------------------------------------ | ------------------ | | 事件注册 | static int registerStandardizedEventHandle(Ability ability,StandardizedEventHandle standardizedEventHandle) | 注册标准化事件。 | | 事件去注册 | static int unregisterStandardizedEventHandle(Ability ability,StandardizedEventHandle standardizedEventHandle) | 去注册标准化事件。 | 开发步骤 重写TouchEventHandle接口类中的boolean onTouch(TouchEvent event)方法，作为处理标准触摸事件的回调。 调用MultimodalEventHandle的静态方法registerStandardizedEventHandle注册事件。 TouchEventHandle touchEventHandle = new TouchEventHandle() { @Override public boolean onTouch(TouchEvent multimodalEvent) { ... // 检测到onTouch，开发者根据需求实现 return true; // 如果事件已处理，则返回true；否则返回false }};MultimodalEventHandle.registerStandardizedEventHandle(getAbility(), touchEventHandle); 当程序退出或不需要监听标准化事件时，调用MultimodalEventHandle的静态方法unregisterStandardizedEventHandle去注册事件。 MultimodalEventHandle.unregisterStandardizedEventHandle(getAbility(), touchEventHandle); "},"media-video-overview.html":{"url":"media-video-overview.html","title":"视频开发概述","keywords":"","body":"视频开发概述 HarmonyOS视频模块支持视频业务的开发和生态开放，开发者可以通过已开放的接口很容易地实现视频媒体的播放、操作和新功能开发。视频媒体的常见操作有视频编解码、视频合成、视频提取、视频播放以及视频录制等。 基本概念 编码 编码是信息从一种形式或格式转换为另一种形式的过程。用预先规定的方法将文字、数字或其他对象编成数码，或将信息、数据转换成规定的电脉冲信号。在本模块中，编码是指编码器将原始的视频信息压缩为另一种格式的过程。 解码 解码是一种用特定方法，把数码还原成它所代表的内容或将电脉冲信号、光信号、无线电波等转换成它所代表的信息、数据等的过程。在本模块中，解码是指解码器将接收到的数据还原为视频信息的过程，与编码过程相对应。 帧率 帧率是以帧为单位的位图图像连续出现在显示器上的频率（速率），以赫兹（Hz）为单位。 "},"media-video-codec-query.html":{"url":"media-video-codec-query.html","title":"媒体编解码能力查询开发指导","keywords":"","body":"媒体编解码能力查询开发指导 场景介绍 媒体编解码能力查询主要指查询设备所支持的编解码器的MIME（Multipurpose Internet Mail Extensions，媒体类型）列表，并判断设备是否支持指定MIME对应的编码器/解码器。 接口说明 接口名 功能描述 getSupportedMimes() 获取某设备所支持的编解码器的MIME列表。 isDecodeSupportedByMime(String mime) 判断某设备是否支持指定MIME对应的解码器。 isEncodeSupportedByMime(String mime) 判断某设备是否支持指定MIME对应的编码器。 isDecoderSupportedByFormat(Format format) 判断某设备是否支持指定媒体格式对应的解码器。 isEncoderSupportedByFormat(Format format) 判断某设备是否支持指定媒体格式对应的编码器。 开发步骤 调用CodecDescriptionList类的静态getSupportedMimes()方法，获取某设备所支持的编解码器的MIME列表。代码示例如下： List mimes = CodecDescriptionList.getSupportedMimes(); 调用CodecDescriptionList类的静态isDecodeSupportedByMime方法，判断某设备是否支持指定MIME对应的解码器，支持返回true，否则返回false。代码示例如下： boolean result = CodecDescriptionList.isDecodeSupportedByMime(Format.VIDEO_VP9); 调用CodecDescriptionList类的静态isEncodeSupportedByMime方法，判断某设备是否支持指定MIME对应的编码器，支持返回true，否则返回false。代码示例如下： boolean result = CodecDescriptionList.isEncodeSupportedByMime(Format.AUDIO_FLAC); 调用CodecDescriptionList类的静态isDecoderSupportedByFormat/isEncoderSupportedByFormat方法，判断某设备是否支持指定Format的编解码器，支持返回true，否则返回false。代码示例如下： Format format = new Format();format.putStringValue(Format.MIME, Format.VIDEO_AVC); format.putIntValue(Format.WIDTH, 2560); format.putIntValue(Format.HEIGHT, 1440); format.putIntValue(Format.FRAME_RATE, 30); format.putIntValue(Format.FRAME_INTERVAL, 1); boolean result = CodecDescriptionList.isDecoderSupportedByFormat(format); result = CodecDescriptionList.isEncoderSupportedByFormat(format); "},"media-video-codec.html":{"url":"media-video-codec.html","title":"视频编解码开发指导","keywords":"","body":"视频编解码开发指导 场景介绍 视频编解码的主要工作是将视频进行编码和解码。 接口说明 接口名 功能描述 createDecoder() 创建解码器Codec实例。 createEncoder() 创建编码器Codec实例。 registerCodecListener(ICodecListener listener) 注册侦听器用来异步接收编码或解码后的数据。 setSource(Source source, TrackInfo trackInfo) 根据解码器的源轨道信息设置数据源，对于编码器trackInfo无效。 setSourceFormat(Format format) 编码器的管道模式下，设置编码器编码格式。 setCodecFormat(Format format) 普通模式设置编/解码器参数。 setVideoSurface(Surface surface) 设置解码器的Surface。 getAvailableBuffer(long timeout) 普通模式获取可用ByteBuffer。 writeBuffer(ByteBuffer buffer, BufferInfo info) 推送源数据给Codec。 getBufferFormat(ByteBuffer buffer) 获取输出Buffer数据格式。 start() 启动编/解码。 stop() 停止编/解码。 release() 释放所有资源。 普通模式开发步骤 在普通模式下进行编解码，应用必须持续地传输数据到Codec实例。 编码的具体开发步骤如下： 创建编码Codec实例，可调用createEncoder()创建。 final Codec encoder = Codec.createEncoder(); 构造数据源格式，并设置给Codec实例，调用setCodecFormat()，代码示例如下： Format fmt = new Format();fmt.putStringValue(Format.MIME, Format.VIDEO_AVC);fmt.putIntValue(Format.WIDTH, 1920);fmt.putIntValue(Format.HEIGHT, 1080);fmt.putIntValue(Format.BIT_RATE, 392000);fmt.putIntValue(Format.FRAME_RATE, 30);fmt.putIntValue(Format.FRAME_INTERVAL, -1);codec.setCodecFormat(fmt); 如果需要编码过程中，检测是否读取到Buffer数据以及是否发生异常，可以构造ICodecListener，ICodecListener需要实现两个方法，实现读到Buffer数据时、编码发生异常时做相应的操作。举例中读到buffer时，获取buffer的format格式，异常时抛出运行时异常，代码示例如下： Codec.ICodecListener listener = new Codec.ICodecListener() { @Override public void onReadBuffer(ByteBuffer byteBuffer, BufferInfo bufferInfo, int trackId) { Format fmt = codec.getBufferFormat(byteBuffer); } @Override public void onError(int errorCode, int act, int trackId) { HiLog.error(TAG, \"CodeListener onError errorCode: %{public}d, act: %{public}d\", errorCode, act); }}; 调用start()方法开始编码。 调用getAvailableBuffer()取到一个可用的ByteBuffer，把数据填入ByteBuffer里，然后再调用writeBuffer()把ByteBuffer写入编码器实例。 调用stop()方法停止编码。 编码任务结束后，调用release()释放资源。 解码的具体开发步骤如下： 创建解码Codec实例，可调用createDecoder()创建。 构造数据源格式，并设置给Codec实例，调用setCodecFormat()，代码示例如下： Format fmt = new Format();fmt.putStringValue(Format.MIME, Format.VIDEO_AVC);fmt.putIntValue(Format.WIDTH, 1920);fmt.putIntValue(Format.HEIGHT, 1080);fmt.putIntValue(Format.BIT_RATE, 392000);fmt.putIntValue(Format.FRAME_RATE, 30);fmt.putIntValue(Format.FRAME_INTERVAL, -1);codec.setCodecFormat(fmt); （可选）如果需要解码过程中，检测是否读取到Buffer数据以及是否发生异常，可以构造ICodecListener，ICodecListener需要实现两个方法，实现读到Buffer数据时、解码发生异常时做相应的操作。举例中读到buffer时，获取buffer的format格式，异常时抛出运行时异常，代码示例如下： Codec.ICodecListener listener = new Codec.ICodecListener() { @Override public void onReadBuffer(ByteBuffer byteBuffer, BufferInfo bufferInfo, int trackId) { Format fmt = codec.getBufferFormat(byteBuffer); } @Override public void onError(int errorCode, int act, int trackId) { throw new RuntimeException(); }}; 调用 start()方法开始解码。 调用getAvailableBuffer取到一个可用的ByteBuffer，把数据填入ByteBuffer里，然后再调用writeBuffer把ByteBuffer写入解码器实例。 调用 stop()方法停止解码。 解码任务结束后，调用release()释放资源。 管道模式开发步骤 管道模式下应用只需要调用Source类的setSource()方法，数据会自动解析并传输给Codec实例。管道模式编码支持视频流编码和音频流编码。 编码的具体开发步骤如下： 调用createEncoder()创建编码Codec实例。 调用setSource()设置数据源，支持设定文件路径或者文件File Descriptor。 构造数据源格式或者从Extractor中读取数据源格式，并设置给Codec实例，调用setSourceFormat()，构造数据源格式代码示例如下： Format fmt = new Format();fmt.putStringValue(Format.MIME, Format.VIDEO_AVC);fmt.putIntValue(Format.WIDTH, 1920);fmt.putIntValue(Format.HEIGHT, 1080);fmt.putIntValue(Format.BIT_RATE, 392000);fmt.putIntValue(Format.FRAME_RATE, 30);fmt.putIntValue(Format.FRAME_INTERVAL, -1);codec.setSourceFormat(fmt); （可选）如果需要编码过程中，检测是否读取到Buffer数据以及是否发生异常，可以构造ICodecListener，ICodecListener需要实现两个方法，实现读到Buffer数据时、编码发生异常时做相应的操作。举例中读到buffer时，获取buffer的format格式，异常时抛出运行时异常，代码示例如下： Codec.ICodecListener listener = new Codec.ICodecListener() { @Override public void onReadBuffer(ByteBuffer byteBuffer, BufferInfo bufferInfo, int trackId) { Format fmt = codec.getBufferFormat(byteBuffer); } @Override public void onError(int errorCode, int act, int trackId) { throw new RuntimeException(); }}; 调用start()方法开始编码。 调用stop()方法停止编码。 编码任务结束后，调用release()释放资源。 解码的具体开发步骤如下： 调用createDecoder()创建解码Codec实例。 调用setSource()设置数据源，支持设定文件路径或者文件File Descriptor。 （可选）如果需要解码过程中，检测是否读取到Buffer数据以及是否发生异常，可以构造ICodecListener，ICodecListener需要实现两个方法，实现读到Buffer数据时、解码发生异常时做相应的操作。举例中读到buffer时，获取buffer的format格式，异常时抛出运行时异常，代码示例如下： Codec.ICodecListener listener = new Codec.ICodecListener() { @Override public void onReadBuffer(ByteBuffer byteBuffer, BufferInfo bufferInfo, int trackId) { Format fmt = codec.getBufferFormat(byteBuffer); } @Override public void onError(int errorCode, int act, int trackId) { throw new RuntimeException(); }}; 调用start()方法开始解码。 调用stop()方法停止解码。 解码任务结束后，调用release()释放资源。 "},"media-video-player.html":{"url":"media-video-player.html","title":"视频播放开发指导","keywords":"","body":"视频播放开发指导 场景介绍 视频播放包括播放控制、播放设置和播放查询，如播放的开始/停止、播放速度设置和是否循环播放等。 接口说明 接口名 功能描述 Player(Context context) 创建Player实例。 setSource(Source source) 设置媒体源。 prepare() 准备播放。 play() 开始播放。 pause() 暂停播放。 stop() 停止播放。 rewindTo(long microseconds) 拖拽播放。 setVolume(float volume) 调节播放音量。 setVideoSurface(Surface surface) 设置视频播放的窗口。 enableSingleLooping(boolean looping) 设置为单曲循环。 isSingleLooping() 检查是否单曲循环播放。 isNowPlaying() 检查是否播放。 getCurrentTime() 获取当前播放位置。 getDuration() 获取媒体文件总时长。 getVideoWidth() 获取视频宽度。 getVideoHeight() 获取视频高度。 setPlaybackSpeed(float speed) 设置播放速度。 getPlaybackSpeed() 获取播放速度。 setAudioStreamType(int type) 设置音频类型。 getAudioStreamType() 获取音频类型。 setNextPlayer(Player next) 设置当前播放结束后的下一个播放器。 reset() 重置播放器。 release() 释放播放资源。 setPlayerCallback(IPlayerCallback callback) 注册回调，接收播放器的事件通知或异常通知。 开发步骤 创建Player实例，可调用Player(Context context)，创建本地播放器，用于在本设备播放。 构造数据源对象，并调用Player实例的setSource(Source source)方法，设置媒体源，代码示例如下： Player player = new Player(context);File file = new File(\"/sdcard/test_audio.mp4\"); // 根据实际情况设置文件路径FileInputStream in = new FileInputStream(file);FileDescriptor fd = in.getFD(); // 从输入流获取FD对象Source source = new Source(fd);player.setSource(source); 调用prepare()，准备播放。 （可选）构造IPlayerCallback，IPlayerCallback需要实现onPlayBackComplete和onError(int errorType, int errorCode)两个方法，实现播放完成和播放异常时做相应的操作。代码示例如下： @Overridepublic void onPlayBackComplete() { HiLog.info(TAG, \"PlayerCallback onPlayBackComplete\"); if (player != null) { player.stop(); player = null; }} @Overridepublic void onError(int errorType, int errorCode) { HiLog.error(TAG, \"PlayerCallback onError errorType: %{public}d, errorCode: %{public}d\", errorType, errorCode);} 调用play()方法，开始播放。 （可选）调用pause()方法和play()方法，可以实现暂停和恢复播放。 （可选）调用rewindTo(long microseconds)方法实现播放中的拖拽功能。 （可选）调用getDuration()方法和getCurrentTime()方法，可以实现获取总播放时长以及当前播放位置功能。 调用 stop()方法停止播放。 播放结束后，调用release()释放资源。 相关实例 针对视频播放开发，有以下示例工程可供参考： VideoPlayer 本示例演示了如何操作网络视频和本地MP4、MOV、AVI 等格式的视频，包含设置视频资源、播放、暂停、释放资源等。 针对视频播放开发，有以下Codelabs可供参考： 简易视频播放器 基于HarmonyOS Player，实现视频文件的播放。 跨设备视频播放 基于分布式能力和IDL跨进程通信，实现视频跨设备播放、控制。 "},"media-video-recording.html":{"url":"media-video-recording.html","title":"视频录制开发指导","keywords":"","body":"视频录制开发指导 场景介绍 视频录制的主要工作是选择视频/音频来源后，录制并生成视频/音频文件。 接口说明 接口名 功能描述 Recorder() 创建Recorder实例。 setSource(Source source) 设置音视频源。 setAudioProperty(AudioProperty property) 设置音频属性。 setVideoProperty(VideoProperty property) 设置视频属性。 setStorageProperty(StorageProperty property) 设置音视频存储属性。 prepare() 准备录制资源。 start() 开始录制。 stop() 停止录制。 pause() 暂停录制。 resume() 恢复录制。 reset() 重置录制。 setRecorderLocation(float latitude, float longitude) 设置视频的经纬度。 setOutputFormat(int outputFormat) 设置输出文件格式。 getVideoSurface() 获取视频窗口。 setRecorderProfile(RecorderProfile profile) 设置媒体录制配置信息。 registerRecorderListener(IRecorderListener listener) 注册媒体录制回调。 release() 释放媒体录制资源。 开发步骤 调用Recorder()方法，创建Recorder实例。 构造数据源对象，并调用Recorder实例的setSource(Source source)方法，设置媒体源，代码示例如下： Recorder recorder = new Recorder();Source source = new Source();source.setRecorderAudioSource(Recorder.AudioSource.DEFAULT);recorder.setSource(source); 调用setOutputFormat(int outputFormat)方法，设置录制文件存储格式。 （可选）构造音频属性AudioProperty对象（不设置音频则是只录视频），并调用Recorder实例的setAudioProperty(AudioProperty property)方法，设置录制的音频属性，代码示例如下： final int AUDIO_NUM_CHANNELS_STEREO = 2;final int AUDIO_SAMPLE_RATE_HZ = 8000;AudioProperty audioProperty = new AudioProperty.Builder() .setRecorderNumChannels(AUDIO_NUM_CHANNELS_STEREO) .setRecorderSamplingRate(AUDIO_SAMPLE_RATE_HZ) .setRecorderAudioEncoder(Recorder.AudioEncoder.DEFAULT) .build();recorder.setAudioProperty(audioProperty); 构造存储属性StorageProperty对象，并调用Recorder实例的setStorageProperty(StorageProperty property)方法，设置录制的存储属性，代码示例如下： String path = \"/sdcard/audiotestRecord.mp4\";StorageProperty storageProperty = new StorageProperty.Builder() .setRecorderPath(path) .setRecorderMaxDurationMs(1000000) .setRecorderMaxFileSizeBytes(1000000) .build();recorder.setStorageProperty(storageProperty); （可选）构造视频属性VideoProperty对象，并调用Recorder实例的setVideoProperty(VideoProperty property)方法，设置录制的视频属性，代码示例如下： VideoProperty videoProperty = new VideoProperty.Builder() .setRecorderVideoEncoder(Recorder.VideoEncoder.DEFAULT) .setRecorderWidth(1080) .setRecorderDegrees(0) .setRecorderHeight(800) .setRecorderBitRate(10000000) .setRecorderRate(30) .build();recorder.setVideoProperty(videoProperty); 调用prepare()，准备录制。 （可选）构造录制回调，首先构造对象IRecorderListener，IRecorderListener需要实现onError(int what, int extra)，实现录制过程收到错误信息时做相应的操作。下面的代码例子中录制异常时，打印了相关的日志信息，代码示例如下： class RecorderErrorAndInfoListener implements IRecorderListener { @Override public void onError(int what, int extra) { } @Override public void onMessage(int what, int extra) { }}IRecorderListener listener = new RecorderErrorAndInfoListener() { @Override public void onError(int what, int extra) { HiLog.error(TAG, \"EncodeWriteFileListener onError what:%{public}d, extra:%{public}d\", what, extra); }} 调用start()方法，开始录制。 （可选）调用pause()方法和resume()方法，可以实现暂停和恢复录制。 调用 stop()方法停止录制。 录制结束后，调用release()释放资源。 "},"media-video-extractor.html":{"url":"media-video-extractor.html","title":"视频提取开发指导","keywords":"","body":"视频提取开发指导 场景介绍 视频提取主要工作是将多媒体文件中的音视频数据进行分离，提取出音频、视频数据源。 接口说明 接口名 功能描述 Extractor() 创建Extractor实例。 setSource(Source source) 设置媒体播放源。 getStreamFormat(int id) 获取对应索引的轨道数据的格式。 getTotalStreams() 获取媒体文件中总轨道数。 selectStream(int id) 根据轨道号选择媒体文件中对应的轨道。 unselectStream(int id) 取消轨道选择。 rewindTo(long microseconds, int mode) 根据时间和mode跳转到指定帧。 next() 跳转到下一帧。 readBuffer(ByteBuffer buf, int offset) 读取解复用后的数据。 getStreamId() 获取当前轨道号。 getFrameTimestamp() 获取当前媒体数据帧的时间戳。 getFrameSize() 获取当前媒体数据帧的数据大小。 getFrameType() 获取当前媒体数据帧的flags。 release() 释放资源。 开发步骤 调用Extractor()方法创建Extractor实例。 构造数据源对象，并调用Extractor实例的setSource(Source source)方法，设置媒体源，代码示例如下： Extractor extractor = new Extractor();File file = new File(\"/sdcard/test_audio.mp4\"); // 根据实际情况设置文件路径FileInputStream in = new FileInputStream(file);FileDescriptor fd = in.getFD();Source source = new Source(fd);extractor.setSource(source); 调用getTotalStreams()方法获取媒体的轨道数量。 调用selectStream(int id)方法选择特定轨道的数据，进行提取。 （可选）调用unselectStream(int id)方法取消选择轨道。 （可选）调用rewindTo(long microseconds, int mode)方法实现提取过程中的跳转指定位置。 调用readBuffer(ByteBuffer buf, int offset)方法，可以实现获取提取出来的Buffer数据功能。 调用next()方法，实现提取下一帧的功能。 （可选）调用getMediaStreamId()方法，可以实现获取当前选择的轨道编号的功能。 （可选）调用getFrameTimestamp()方法，可以实现获取当前轨道内媒体数据帧时间戳的功能。 （可选）调用getFrameSize()方法，可以实现获取当前轨道的媒体数据帧大小的功能。 （可选）调用getFrameType()方法，可以实现获取当前轨道的媒体数据帧flags的功能。 提取结束后，调用release()释放资源。 "},"media-video-description.html":{"url":"media-video-description.html","title":"媒体描述信息开发指导","keywords":"","body":"媒体描述信息开发指导 场景介绍 媒体描述信息主要工作是支持多媒体的相关描述信息的存取。 接口说明 接口名 功能描述 getMediaId() 获取媒体标识。 getTitle() 获取媒体标题。 getSubTitle() 获取媒体副标题。 getDescription() 获取媒体描述信息。 getIcon() 获取媒体图标。 getIconUri() 获取媒体图标的Uri。 getExtras() 获取媒体添加的额外信息，例如应用和系统使用的内部信息。 getMediaUri() 获取媒体内容的Uri。 marshalling(Parcel parcel) 将一个AVDescription对象写入到Parcel对象。 unmarshalling(Parcel parcel) 将一个Parcel对象写入到AVDescription对象。 接口名 功能描述 setMediaId(String mediaId) 设置媒体标识。 setTitle(CharSequence title) 设置媒体标题。 setSubTitle(CharSequence subTitle) 设置媒体副标题。 setDescription(String description) 设置媒体描述信息。 setIcon(PixelMap icon) 设置媒体图标。 setIconUri(Uri iconUri) 设置媒体图标的Uri。 setExtras(PacMap extras) 设置媒体的额外信息，例如应用和系统使用的内部信息。 setIMediaUri(Uri mediaUri) 设置媒体的Uri。 build() 构造方法。 开发步骤 调用AVDescription.Builder类的build方法创建AVDescription实例。代码示例如下： AVDescription avDescription = new AVDescription.Builder().setExtras(null) .setMediaId(\"1\") .setDescription(\"Description\") .setIconUri(iconUri) .setIMediaUri(mediaUri) .setExtras(pacMap) .setIcon(pixelMap) .setTitle(\"title\") .setSubTitle(\"subTitle\") .build(); （可选）根据已有的AVDescription对象，可以获取媒体的描述信息，如获取媒体Uri，代码示例如下： Uri uri = avDescription.getMediaUri(); （可选）根据已有的AVDescription对象，可以将媒体的描述信息写入Parcel对象，代码示例如下： Parcel parcel = Parcel.create();boolean result = avDescription.marshalling(parcel); （可选）根据已有的Parcel对象，可以读取到AVDescription对象，实现媒体描述信息的写入，代码示例如下： boolean result = avDescription.unmarshalling(parcel); "},"media-video-metadata.html":{"url":"media-video-metadata.html","title":"媒体元数据开发指导","keywords":"","body":"媒体元数据开发指导 场景介绍 媒体元数据主要用于媒体数据的存放和读取，包含诸如媒体资源的描述、创建日期、作者、封面图片等等。 接口说明 接口名 功能描述 Builder() 媒体元数据构造器的构造函数。 Builder(AVMetadata source) 媒体元数据构造器的带参构造函数。 setText(String key, CharSequence value) 用于存储媒体标题等信息。 setString(String key, String value) 用于存储媒体作者、艺术家、描述等。 setLong(String key, long value) 用于存储媒体ID、媒体时长等信息。 setPixelMap(String key, PixelMap value) 用于存储媒体元数据相关的图片资源。 build() 媒体元数据生成函数。 接口名 功能描述 hasKey(String key) 媒体元数据中是否包含某一个key的数据。 getText(String key) 获取text类型的key的数据，比如获取媒体标题等信息。 getString(String key) 获取String类型key的数据，比如获取媒体作者、艺术家、描述等。 getLong(String key) 获取Long类型key数据，比如获取媒体ID、媒体时长等信息。 getKeysSet() 获取媒体元数据的集合。 getPixelMap(String key) 获取PixelMap类型key数据，获取媒体元数据相关的图片资源。 marshalling(Parcel in) 将一个AVMetadata对象写入到Parcel对象。 getAVDescription() 获取媒体的简要描述信息。 开发步骤 调用AVMetadata.Builder类的build方法创建AVMetadata实例。代码示例如下： AVMetadata avMetadata = new AVMetadata.Builder().setString(AVMetadata.AVTextKey.META_ID, \"illuminate.mp3\") .setString(AVMetadata.AVTextKey.TITLE, \"title\") .setString(AVMetadata.AVTextKey.ARTIST, \"artist\") .setString(AVMetadata.AVTextKey.ALBUM, \"album\") .setString(AVMetadata.AVTextKey.TITLE, \"display_subtitle\") .setPixelMap(AVMetadata.AVPixelMapKey.ICON, pixelmap) .build(); (可选)根据已有的AVMetadata对象，可以获取媒体元数据信息，如获取媒体标题等，代码示例如下： String title = avMetadata.getString(AVMetadata.AVTextKey.TITLE); 我们需要结合AVSession使用，将已有的媒体元数据AVMetadata对象下发给应用，具体参考AVSession使用，示例如下： mediaSession.setAVMetadata(avMetadata); 应用获取媒体元数据一般结合AVControllerCallback相关类使用，通过onAVMetadataChanged回调获取媒体元数据。 Image musicCover;Text musicTitle;public class Callback extends AVControllerCallback { @Override public void onAVMetadataChanged(AVMetadata metadata) { // 歌曲信息回调 AVDescription description = metadata.getAVDescription(); // 获取标题 String title = description.getTitle().toString(); CharSequence sequence = metadata.getText(AVMetadata.AVTextKey.TITLE); if (sequence != null) { title = sequence.toString(); } // 设置媒体title musicTitle.setText(title); // 获取曲目专封面 PixelMap iconPixelMap = description.getIcon(); // 设置歌曲封面图 musicCover.setPixelMap(iconPixelMap); }} "},"media-image-overview.html":{"url":"media-image-overview.html","title":"图像开发概述","keywords":"","body":"图像开发概述 HarmonyOS图像模块支持图像业务的开发，常见功能如图像解码、图像编码、基本的位图操作、图像编辑等。当然，也支持通过接口组合来实现更复杂的图像处理逻辑。 基本概念 图像解码 图像解码就是不同的存档格式图片（如JPEG、PNG等）解码为无压缩的位图格式，以方便在应用或者系统中进行相应的处理。 PixelMap PixelMap是图像解码后无压缩的位图格式，用于图像显示或者进一步的处理。 渐进式解码 渐进式解码是在无法一次性提供完整图像文件数据的场景下，随着图像文件数据的逐步增加，通过多次增量解码逐步完成图像解码的模式。 预乘 预乘时，RGB各通道的值被替换为原始值乘以Alpha通道不透明的比例（0~1）后的值，方便后期直接合成叠加；不预乘指RGB各通道的数值是图像的原始值，与Alpha通道的值无关。 图像编码 图像编码就是将无压缩的位图格式，编码成不同格式的存档格式图片（JPEG、PNG等），以方便在应用或者系统中进行相应的处理。 约束与限制 为及时释放本地资源，建议在图像解码的ImageSource对象、位图图像PixelMap对象或图像编码的ImagePacker对象使用完成后，主动调用ImageSource、PixelMap和ImagePacker的release()方法。 相关实例 针对图像开发，有以下示例工程可供参考： PixelMap 本示例演示了如何通过图像模块相关接口，实现图像编解码、位图操作等功能。 "},"media-image-decoding.html":{"url":"media-image-decoding.html","title":"图像解码开发指导","keywords":"","body":"图像解码开发指导 场景介绍 图像解码就是将所支持格式的存档图片解码成统一的PixelMap图像，用于后续图像显示或其他处理，比如旋转、缩放、裁剪等。当前支持格式包括JPEG、PNG、GIF、HEIF、WebP、BMP。 接口说明 ImageSource主要用于图像解码。 接口名 描述 create(String pathName, SourceOptions opts) 从图像文件路径创建图像数据源。 create(InputStream is, SourceOptions opts) 从输入流创建图像数据源。 create(byte[] data, SourceOptions opts) 从字节数组创建图像源。 create(byte[] data, int offset, int length, SourceOptions opts) 从字节数组指定范围创建图像源。 create(File file, SourceOptions opts) 从文件对象创建图像数据源。 create(FileDescriptor fd, SourceOptions opts) 从文件描述符创建图像数据源。 createIncrementalSource(SourceOptions opts) 创建渐进式图像数据源。 createIncrementalSource(IncrementalSourceOptions opts) 创建渐进式图像数据源，支持设置渐进式数据更新模式。 createPixelmap(DecodingOptions opts) 从图像数据源解码并创建PixelMap图像。 createPixelmap(int index, DecodingOptions opts) 从图像数据源解码并创建PixelMap图像，如果图像数据源支持多张图片的话，支持指定图像索引。 updateData(byte[] data, boolean isFinal) 更新渐进式图像源数据。 updateData(byte[] data, int offset, int length, boolean isFinal) 更新渐进式图像源数据，支持设置输入数据的有效数据范围。 getImageInfo() 获取图像基本信息。 getImageInfo(int index) 根据特定的索引获取图像基本信息。 getSourceInfo() 获取图像源信息。 release() 释放对象关联的本地资源。 普通解码开发步骤 创建图像数据源ImageSource对象，可以通过SourceOptions指定数据源的格式信息，此格式信息仅为给解码器的提示，正确提供能帮助提高解码效率，如果不设置或设置不正确，会自动检测正确的图像格式。不使用该选项时，可以将create接口传入的SourceOptions设置为null。 ImageSource.SourceOptions srcOpts = new ImageSource.SourceOptions();srcOpts.formatHint = \"image/png\";String pathName = \"/sdcard/image.png\";ImageSource imageSource = ImageSource.create(pathName, srcOpts); // 不通过SourceOptions指定数据源格式信息ImageSource imageSourceNoOptions = ImageSource.create(pathName, null); 设置解码参数，解码获取PixelMap图像对象，解码过程中同时支持图像处理操作。 设置desiredSize支持按尺寸缩放，如果设置为全0，则不进行缩放。 设置desiredRegion支持按矩形区域裁剪，如果设置为全0，则不进行裁剪。 设置rotateDegrees支持旋转角度，以图像中心点顺时针旋转。 如果只需要解码原始图像，不使用该选项时，可将给createPixelMap传入的DecodingOptions 设置为null。 // 普通解码叠加缩放、裁剪、旋转ImageSource.DecodingOptions decodingOpts = new ImageSource.DecodingOptions();decodingOpts.desiredSize = new Size(100, 2000);decodingOpts.desiredRegion = new Rect(0, 0, 100, 100);decodingOpts.rotateDegrees = 90;PixelMap pixelMap = imageSource.createPixelmap(decodingOpts); // 普通解码PixelMap pixelMapNoOptions = imageSource.createPixelmap(null); 解码完成获取到PixelMap对象后，可以进行后续处理，比如渲染显示等。 渐进式解码开发步骤 创建渐进式图像数据源ImageSource对象。 可以通过SourceOptions指定数据源的格式信息，此格式信息仅为提示，如果填写不正确，会自动检测正确的图像格式。使用IncrementalSourceOptions指定图像数据的更新方式为渐进式更新。 ImageSource.SourceOptions srcOpts = new ImageSource.SourceOptions();srcOpts.formatHint = \"image/jpeg\";ImageSource.IncrementalSourceOptions incOpts = new ImageSource.IncrementalSourceOptions();incOpts.opts = srcOpts;incOpts.mode = ImageSource.UpdateMode.INCREMENTAL_DATA;imageSource = ImageSource.createIncrementalSource(incOpts); 渐进式更新数据。在未获取到全部图像时，支持先更新部分数据来尝试解码，调用updateData更新数据，将参数isFinal设置为false；当获取到全部数据后，最后一次更新数据时设置isFinal为true，表示数据更新完毕。设置解码参数同普通解码。 // 获取到一定的数据时尝试解码imageSource.updateData(data, 0, bytes, false);ImageSource.DecodingOptions decodingOpts = new ImageSource.DecodingOptions();PixelMap pixelMap = imageSource.createPixelmap(decodingOpts); // 更新数据再次解码，重复调用直到数据全部更新完成imageSource.updateData(data, 0, bytes, false);PixelMap pixelMap = imageSource.createPixelmap(decodingOpts); // 数据全部更新完成时需要传入isFinal为trueimageSource.updateData(data, 0, bytes, true);PixelMap pixelMap = imageSource.createPixelmap(decodingOpts); 解码完成获取到PixelMap对象后，可以进行后续处理，比如渲染显示等。 相关实例 图片常见操作 基于HarmonyOS图像编解码，实现图片的旋转、剪裁、缩放、镜像。 "},"media-image-encoding.html":{"url":"media-image-encoding.html","title":"图像编码开发指导","keywords":"","body":"图像编码开发指导 场景介绍 图像编码就是将PixelMap图像编码成不同存档格式图片，用于后续其他处理，比如保存、传输等。当前仅支持JPEG格式。 接口说明 ImagePacker主要用于图像编码。 接口名 描述 create() 创建图像打包器实例。 initializePacking(byte[] data, PackingOptions opts) 初始化打包任务，将字节数组设置为打包后输出目的。 initializePacking(byte[] data, int offset, PackingOptions opts) 初始化打包任务，将带偏移量的字节数组设置为打包后输出目的。 initializePacking(OutputStream outputStream, PackingOptions opts) 初始化打包任务，将输出流设置为打包后输出目的。 addImage(PixelMap pixelmap) 将PixelMap对象添加到图像打包器中。 addImage(ImageSource source) 将图像数据源ImageSource中图像添加到图像打包器中。 addImage(ImageSource source, int index) 将图像数据源ImageSource中指定图像添加到图像打包器中。 finalizePacking() 完成图像打包任务。 release() 释放对象关联的本地资源。 开发步骤 创建图像编码ImagePacker对象。 ImagePacker imagePacker = ImagePacker.create(); 设置编码输出流和编码参数。设置format为编码的图像格式，当前支持jpeg格式。设置quality为图像质量，范围从0-100，100为最佳质量。 FileOutputStream outputStream = new FileOutputStream(\"/path/to/packed.file\");ImagePacker.PackingOptions packingOptions = new ImagePacker.PackingOptions();packingOptions.format = \"image/jpeg\";packingOptions.quality = 90;boolean result = imagePacker.initializePacking(outputStream, packingOptions); 添加需要编码的PixelMap对象，进行编码操作。 result = imagePacker.addImage(myPixelMap);long dataSize = imagePacker.finalizePacking(); 编码输出完成后，可以进行后续处理，比如保存、传输等。 "},"media-image-pixel-map.html":{"url":"media-image-pixel-map.html","title":"位图操作开发指导","keywords":"","body":"位图操作开发指导 场景介绍 位图操作就是指对PixelMap图像进行相关的操作，比如创建、查询信息、读写像素数据等。 接口说明 接口名 描述 create(InitializationOptions opts) 根据图像大小、像素格式、alpha类型等初始化选项创建PixelMap。 create(int[] colors, InitializationOptions opts) 根据图像大小、像素格式、alpha类型等初始化选项,以像素颜色数组为数据源创建PixelMap。 create(int[] colors, int offset, int stride, InitializationOptions opts) 根据图像大小、像素格式、alpha类型等初始化选项,以像素颜色数组、起始偏移量、行像素大小描述的数据源创建PixelMap。 create(PixelMap source, InitializationOptions opts) 根据图像大小、像素格式、alpha类型等初始化选项,以源PixelMap为数据源创建PixelMap。 create(PixelMap source, Rect srcRegion, InitializationOptions opts) 根据图像大小、像素格式、alpha类型等初始化选项,以源PixelMap、源裁剪区域描述的数据源创建PixelMap。 getBytesNumberPerRow() 获取每行像素数据占用的字节数。 getPixelBytesCapacity() 获取存储Pixelmap像素数据的内存容量。 isEditable() 判断PixelMap是否允许修改。 isSameImage(PixelMap other) 判断两个图像是否相同，包括ImageInfo属性信息和像素数据。 readPixel(Position pos) 读取指定位置像素的颜色值,返回的颜色格式为PixelFormat.ARGB_8888。 readPixels(int[] pixels, int offset, int stride, Rect region) 读取指定区域像素的颜色值,输出到以起始偏移量、行像素大小描述的像素数组，返回的颜色格式为PixelFormat.ARGB_8888。 readPixels(Buffer dst) 读取像素的颜色值到缓冲区,返回的数据是PixelMap中像素数据的原样拷贝，即返回的颜色数据格式与PixelMap中像素格式一致。 resetConfig(Size size, PixelFormat pixelFormat) 重置PixelMap的大小和像素格式配置，但不会改变原有的像素数据也不会重新分配像素数据的内存，重置后图像数据的字节数不能超过PixelMap的内存容量。 setAlphaType(AlphaType alphaType) 设置PixelMap的Alpha类型。 writePixel(Position pos, int color) 向指定位置像素写入颜色值,写入颜色格式为PixelFormat.ARGB_8888。 writePixels(int[] pixels, int offset, int stride, Rect region) 将像素颜色数组、起始偏移量、行像素的个数描述的源像素数据写入PixelMap的指定区域,写入颜色格式为PixelFormat.ARGB_8888。 writePixels(Buffer src) 将缓冲区描述的源像素数据写入PixelMap,写入的数据将原样覆盖PixelMap中的像素数据，即写入数据的颜色格式应与PixelMap的配置兼容。 writePixels(int color) 将所有像素都填充为指定的颜色值,写入颜色格式为 PixelFormat.ARGB_8888。 getPixelBytesNumber() 获取全部像素数据包含的字节数。 setBaseDensity(int baseDensity) 设置PixelMap的基础像素密度值。 getBaseDensity() 获取PixelMap的基础像素密度值。 setUseMipmap(boolean useMipmap) 设置PixelMap渲染是否使用mipmap。 useMipmap() 获取PixelMap渲染是否使用mipmap。 getNinePatchChunk() 获取图像的NinePatchChunk数据。 getFitDensitySize(int targetDensity) 获取适应目标像素密度的图像缩放的尺寸。 getImageInfo() 获取图像基本信息。 release() 释放对象关联的本地资源。 开发步骤 创建位图对象PixelMap。 // 从像素颜色数组创建int[] defaultColors = new int[] {5, 5, 5, 5, 6, 6, 3, 3, 3, 0};PixelMap.InitializationOptions initializationOptions = new PixelMap.InitializationOptions();initializationOptions.size = new Size(3, 2);initializationOptions.pixelFormat = PixelFormat.ARGB_8888;initializationOptions.editable = true;PixelMap pixelMap1 = PixelMap.create(defaultColors, initializationOptions); // 指定初始化选项创建PixelMap pixelMap2 = PixelMap.create(initializationOptions); // 以另外一个PixelMap作为数据源创建PixelMap pixelMap3 = PixelMap.create(pixelMap2, initializationOptions); 从位图对象中获取信息。 long capacity = pixelMap.getPixelBytesCapacity();long bytesNumber = pixelMap.getPixelBytesNumber();int rowBytes = pixelMap.getBytesNumberPerRow();byte[] ninePatchData = pixelMap.getNinePatchChunk(); 读写位图像素数据。 // 读取指定位置像素int color = pixelMap.readPixel(new Position(1, 1)); // 读取指定区域像素int[] pixelArray = new int[50];Rect region = new Rect(0, 0, 10, 5);pixelMap.readPixels(pixelArray, 0, 10, region); // 读取像素到BufferIntBuffer pixelBuf = IntBuffer.allocate(50);pixelMap.readPixels(pixelBuf); // 在指定位置写入像素pixelMap.writePixel(new Position(1, 1), 0xFF112233); // 在指定区域写入像素pixelMap.writePixels(pixelArray, 0, 10, region); // 写入Buffer中的像素pixelMap.writePixels(intBuf); "},"media-image-property-decoding.html":{"url":"media-image-property-decoding.html","title":"图像属性解码开发指导","keywords":"","body":"图像属性解码开发指导 场景介绍 图像属性解码就是获取图像中包含的属性信息，比如EXIF属性。 接口说明 图像属性解码的功能主要由ImageSource和ExifUtils提供。 接口名 描述 getThumbnailInfo() 获取嵌入图像文件的缩略图的基本信息。 getImageThumbnailBytes() 获取嵌入图像文件缩略图的原始数据。 getThumbnailFormat() 获取嵌入图像文件缩略图的格式。 接口名 描述 getLatLong(ImageSource imageSource) 获取嵌入图像文件的经纬度信息。 getAltitude(ImageSource imageSource, double defaultValue) 获取嵌入图像文件的海拔信息。 开发步骤 创建图像数据源ImageSource对象，可以通过SourceOptions指定数据源的格式信息，此格式信息仅为给解码器的提示，正确提供能帮助提高解码效率，如果不设置或设置不正确，会自动检测正确的图像格式。 ImageSource.SourceOptions srcOpts = new ImageSource.SourceOptions();srcOpts.formatHint = \"image/jpeg\";String pathName = \"/sdcard/image.jpg\";ImageSource imageSource = ImageSource.create(pathName, srcOpts); 获取缩略图信息。 int format = imageSource.getThumbnailFormat();byte[] thumbnailBytes = imageSource.getImageThumbnailBytes(); // 将缩略图解码为PixelMap对象ImageSource.DecodingOptions decodingOpts = new ImageSource.DecodingOptions();PixelMap thumbnailPixelmap = imageSource.createThumbnailPixelmap(decodingOpts, false); "}}